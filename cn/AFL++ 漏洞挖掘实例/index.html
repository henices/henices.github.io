<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AFL++ 漏洞挖掘实例 | 安全代码</title><meta name="author" content="曼福吉"><meta name="copyright" content="曼福吉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="☆ 1. 模糊测试工具 AFL &#x2F; AFL++介绍模糊测试是一种黑盒测试方法，它通过向软件输入随机或异常的数据，来触发软件中的错误或异常。AFL 是 Google 开发的一款 fuzz 工具，它最初由 Michal Zalewski 开发，被设计为一种模糊测试工具，用于自动发现程序中的漏洞。 在 AFL 之前，模糊测试工具大多采用随机生成输入数据的方法。这种方法虽然简单，但效率低下，很难">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL++ 漏洞挖掘实例">
<meta property="og:url" content="https://usmacd.com/cn/AFL++%20%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/index.html">
<meta property="og:site_name" content="安全代码">
<meta property="og:description" content="☆ 1. 模糊测试工具 AFL &#x2F; AFL++介绍模糊测试是一种黑盒测试方法，它通过向软件输入随机或异常的数据，来触发软件中的错误或异常。AFL 是 Google 开发的一款 fuzz 工具，它最初由 Michal Zalewski 开发，被设计为一种模糊测试工具，用于自动发现程序中的漏洞。 在 AFL 之前，模糊测试工具大多采用随机生成输入数据的方法。这种方法虽然简单，但效率低下，很难">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640">
<meta property="article:published_time" content="2024-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-31T16:00:00.000Z">
<meta property="article:author" content="曼福吉">
<meta property="article:tag" content="Security">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AFL++ 漏洞挖掘实例",
  "url": "https://usmacd.com/cn/AFL++%20%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/",
  "image": "https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640",
  "datePublished": "2024-03-31T16:00:00.000Z",
  "dateModified": "2024-03-31T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "曼福吉",
      "url": "https://usmacd.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://usmacd.com/cn/AFL++%20%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AFL++ 漏洞挖掘实例',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/self/atom-one-light.css"><link rel="stylesheet" href="/self/nord.css"><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="安全代码" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="安全代码" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">173</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/thoughts"><i class="fa-fw fas fa-cloud"></i><span> 想法</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/sitemap.xml"><span> sitemap</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><span> random</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">安全代码</span></a><a class="nav-page-title" href="/"><span class="site-name">AFL++ 漏洞挖掘实例</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/thoughts"><i class="fa-fw fas fa-cloud"></i><span> 想法</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/sitemap.xml"><span> sitemap</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><span> random</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">AFL++ 漏洞挖掘实例</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-31T16:00:00.000Z" title="发表于 2024-04-01 00:00:00">2024-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-31T16:00:00.000Z" title="更新于 2024-04-01 00:00:00">2024-04-01</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="☆-1-模糊测试工具-AFL-AFL-介绍"><a href="#☆-1-模糊测试工具-AFL-AFL-介绍" class="headerlink" title="☆ 1. 模糊测试工具 AFL &#x2F; AFL++介绍"></a>☆ 1. 模糊测试工具 AFL &#x2F; AFL++介绍</h2><p>模糊测试是一种黑盒测试方法，它通过向软件输入随机或异常的数据，来触发软件中的错误或异常。AFL 是 Google 开发的一款 fuzz 工具，它最初由 Michal Zalewski 开发，被设计为一种模糊测试工具，用于自动发现程序中的漏洞。</p>
<p>在 AFL 之前，模糊测试工具大多采用随机生成输入数据的方法。这种方法虽然简单，但效率低下，很难发现软件中的隐藏路径。AFL 引入了覆盖率导向的模糊测试方法，它会根据软件的执行路径来优化输入数据。这种方法可以有效地提高模糊测试的效率，并更容易发现软件中的隐藏路径。</p>
<p>AFL 的发布，标志着模糊测试工具进入了新的时代。AFL 的成功，激发了许多其他研究人员和开发人员对模糊测试工具的改进和研究。它对软件安全领域产生了深远的影响。AFL 的成功，证明了模糊测试是一种有效的软件安全测试方法。</p>
<p>AFL 在模糊测试工具发展史上的具体贡献主要有：<br>1）开创了覆盖率导向模糊测试的新时代<br>2）极大地提高了模糊测试的效率和效果<br>3）激发了其他研究人员和开发人员对模糊测试工具的改进和研究</p>
<p>AFL作为一款开创性的模糊测试工具，通过不断的发展和改进，已经在网络安全领域取得了显著的历史地位。其自动化特性和有效的漏洞发现能力使其成为安全专业人员首选的工具之一，对软件安全性的提升产生了积极影响。AFL 的成功，证明了模糊测试是一种有效的软件安全测试方法。AFL 的出现，为软件安全领域提供了新的工具和手段，帮助开发人员和安全研究人员发现软件中的安全漏洞。</p>
<p>AFLplusplus （简称 AFL++）是 AFL 的一个分支，它由 Marc “van Hauser 和其他开发者开发。AFLplusplus 在 AFL 的基础上进行了许多改进，包括：</p>
<ul>
<li>更快的执行速度：AFLplusplus 使用了新的编译器插件和其他技术来提高 fuzz 的速度。</li>
<li>更强大的变异算法：AFLplusplus 提供了更强大的变异算法，可以生成更复杂的输入数据。</li>
<li>更全面的覆盖率：AFLplusplus 提供了更全面的覆盖率分析，可以帮助开发人员发现软件中的隐藏路径。</li>
</ul>
<p>目前 Google 的 oss-fuzz 项目已经使用 AFL++ 替换 AFL 作为其主要 fuzz 工具，AFL++ 在速度、变异算法和覆盖率分析方面都比 AFL 更优秀。</p>
<h2 id="☆-2-AFL-的安装"><a href="#☆-2-AFL-的安装" class="headerlink" title="☆ 2. AFL++ 的安装"></a>☆ 2. AFL++ 的安装</h2><p>AFL++ 的源码有两个分支，stable 分支 [2] 为发布分支，dev 分支 [3] 为开发分支。dev 分支代码的更新频率很高，也不是很稳定可能出现 bug，推荐使用 stable 分支的源码。以 ubuntu 18.04 为例介绍如何安装 AFLplusplus</p>
<p>下载源码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure>

<p><strong>git submodule</strong> 这条命令很重要，要不编译一些 AFL++ mode 的时候会因为缺少源码而报错。</p>
<p>要从源码编译 AFL++ 需要先安装系统的依赖库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools curl ninja-build<br></code></pre></td></tr></table></figure>

<p>AFL++ 在文档中推荐使用 llvm 13+ ,  所以先要升级 Ubuntu 系统的 llvm ，<a target="_blank" rel="noopener" href="https://apt.llvm.org/">https://apt.llvm.org/</a> 提供了编译好的 llvm binary 可以下载，也提供了 llvm.sh 可以非常方面的安装新版本的 llvm，下面的例子演示安装 llvm 15</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://apt.llvm.org/llvm.sh<br><span class="hljs-built_in">chmod</span> +x llvm.sh<br><span class="hljs-built_in">sudo</span> ./llvm.sh 15 all<br></code></pre></td></tr></table></figure>

<p>编译 AFL++</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-15&quot;</span><br>make distrib<br></code></pre></td></tr></table></figure>
<h2 id="☆-3-AFL-Linux-系统环境配置"><a href="#☆-3-AFL-Linux-系统环境配置" class="headerlink" title="☆ 3. AFL++ Linux 系统环境配置"></a>☆ 3. AFL++ Linux 系统环境配置</h2><p>为了使 AFL++ 在 fuzz 时获得更好的性能，可以使用 root 用户执行下面的脚本， 调整 linux 内核的参数。</p>
<p><code>sudo bash afl-init.sh</code> </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 1 &gt;/proc/sys/kernel/sched_child_runs_first<br><span class="hljs-built_in">echo</span> 1 &gt;/proc/sys/kernel/sched_autogroup_enabled<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/vm/overcommit_memory<br><span class="hljs-built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern<br><span class="hljs-built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br><span class="hljs-built_in">test</span> -e /sys/devices/system/cpu/cpufreq/scaling_governor &amp;&amp; <span class="hljs-built_in">echo</span> performance | <span class="hljs-built_in">tee</span> /sys/devices/system/cpu/cpufreq/scaling_governor<br><span class="hljs-built_in">test</span> -e /sys/devices/system/cpu/cpufreq/policy0/scaling_governor &amp;&amp; <span class="hljs-built_in">echo</span> performance | <span class="hljs-built_in">tee</span> /sys/devices/system/cpu/cpufreq/policy*/scaling_governor<br><span class="hljs-built_in">test</span> -e /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor &amp;&amp; <span class="hljs-built_in">echo</span> performance | <span class="hljs-built_in">tee</span> /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor<br><span class="hljs-built_in">test</span> -e /sys/devices/system/cpu/cpufreq/boost &amp;&amp; <span class="hljs-built_in">echo</span> 1 &gt; /sys/devices/system/cpu/cpufreq/boost<br></code></pre></td></tr></table></figure>

<h2 id="☆-4-AFL-的基本使用方法"><a href="#☆-4-AFL-的基本使用方法" class="headerlink" title="☆ 4. AFL++ 的基本使用方法"></a>☆ 4. AFL++ 的基本使用方法</h2><h3 id="4-1-编译插桩模糊测试目标软件"><a href="#4-1-编译插桩模糊测试目标软件" class="headerlink" title="4.1 编译插桩模糊测试目标软件"></a>4.1 编译插桩模糊测试目标软件</h3><p>优先使用 llvm clang 对目标软件进行插桩，在最近几年的实战文章中已经很少看到使用 gcc 插桩目标软件的例子。AFL++ 提供了多种插桩方式，可以参考:<br><a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/instrumentation">https://github.com/AFLplusplus/AFLplusplus/tree/stable/instrumentation</a></p>
<p>使用  afl-clang-fast&#x2F;afl-clang-fast++ 或者 afl-clang-lto&#x2F;afl-clang-lto++ 可以应对大多数情况，afl-clang-lto&#x2F;afl-clang-lto++ 在编译大型程序的时候可能会失败，如果出现失败的情况，可以换用 afl-clang-fast&#x2F;afl-clang-fast++ 。 下面的示例分别针对三种不同编译系统情况，[a] 使用 Makefile , [b] 使用 cmake，[c] 使用 meson , 需要根据具体情况选择。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">CC=afl-cc CXX=afl-c++ ./configure --disable-shared <span class="hljs-comment"># [a]</span><br>cmake -DCMAKE_C_COMPILERC=afl-cc -DCMAKE_CXX_COMPILER=afl-c++ . <span class="hljs-comment"># [b]</span><br>CC=afl-cc CXX=afl-c++ meson <span class="hljs-comment"># [c]</span><br></code></pre></td></tr></table></figure>

<p>下载 Xpdf 3.02 作为 fuzz 目标。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz<br>tar -xvzf xpdf-3.02.tar.gz<br></code></pre></td></tr></table></figure>

<p>编译 Xpdf</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> xpdf<br>CC=afl-cc CXX=afl-c++ ./configure --disable-shared --prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzz_xpdf/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure>

<p>将得到我们的 fuzz 目标  <code>$HOME/fuzz_xpdf/install/bin/pdftotext</code></p>
<h3 id="4-2-AFL-的命令行参数"><a href="#4-2-AFL-的命令行参数" class="headerlink" title="4.2 AFL++ 的命令行参数"></a>4.2 AFL++ 的命令行参数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">afl-fuzz -i <span class="hljs-variable">$HOME</span>/AFLplusplus/testcases/others/pdf -o <span class="hljs-variable">$HOME</span>/fuzz_xpdf/out/ -s 123 -- <span class="hljs-variable">$HOME</span>/fuzz_xpdf/install/bin/pdftotext @@ <span class="hljs-variable">$HOME</span>/fuzz_xpdf/output<br></code></pre></td></tr></table></figure>

<ul>
<li>-i  输入目录，用于存放初始 testcase</li>
<li>-o 输出目录，用于存放 afl-fuzz 生成的 testcase</li>
<li>– 后面接 fuzz 目标的命令行   @@ 代表文件，不写 @@ 代表是从标准输入读取数据</li>
<li>-s  RNG 的 seed</li>
</ul>
<h2 id="☆-5-实战-vim-漏洞挖掘"><a href="#☆-5-实战-vim-漏洞挖掘" class="headerlink" title="☆ 5. 实战 vim 漏洞挖掘"></a>☆ 5. 实战 vim 漏洞挖掘</h2><p>首先需要研究 vim 的命令行参数，默认的配置下 vim 启动速度慢，并且有可能执行外部shell 命令 （不安全），最终需要使用的命令行参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">- -u NONE 跳过初始化<br>- -X 加快启动速度<br>- -s 安静模式<br>- -Z 受限模式 (All commands that make use of an external shell are disabled.)<br>- -e 以 Ex 模式运行 vim<br>- -S 加载第一个文件后执行文件 &lt;session&gt;<br>- -c &lt;command&gt; 加载第一个文件后执行 &lt;command&gt;<br>- -n 不使用交换文件，只使用内存<br>- -m Modifications not allowed to be written<br></code></pre></td></tr></table></figure>

<h3 id="5-0-vim-的-Ex-模式介绍"><a href="#5-0-vim-的-Ex-模式介绍" class="headerlink" title="5.0 vim 的 Ex 模式介绍"></a>5.0 vim 的 Ex 模式介绍</h3><p>Vim 编译器有三种模式：普通模式、插入模式和 ex 模式。ex 模式是 Vim 的底层命令模式，用于执行各种文件操作，如打开、编辑、保存、搜索、替换、排序等。要进入 ex 模式，可以按下 : 键。在 ex 模式下，可以输入各种命令来执行操作。命令由行号和命令组成，以回车键结束。</p>
<p>最基本的 ex 命令是 p 命令，用于打印指定行号的行。例如，要打印第 10 行，可以输入 10p。</p>
<p>其他常用的 ex 命令包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">e 命令：打开另一个文件<br>w 命令：保存当前文件<br>q 命令：退出 Vim<br>s 命令：将当前行替换为指定文本<br>g/pattern/s/old/new/ 命令：将所有匹配模式 pattern 的行替换为 old 替换为 new。<br>:sort 命令：对当前文件进行排序。<br></code></pre></td></tr></table></figure>

<p>ex 模式的使用方法如下：在普通模式下，按下 : 键进入 ex 模式，输入命令，按下回车键执行命令。</p>
<p>以下是一些 ex 模式的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 打开文件<br>:e test.txt<br><br># 编辑文件<br>10iHello, world!<br><br># 保存文件<br>:w<br><br># 退出 Vim<br>:q<br></code></pre></td></tr></table></figure>

<p>ex 模式提供了丰富的命令，可以用于执行各种文件操作。熟练掌握 ex 模式可以提高 Vim 的使用效率。</p>
<h3 id="5-1-攻击面分析"><a href="#5-1-攻击面分析" class="headerlink" title="5.1 攻击面分析"></a>5.1 攻击面分析</h3><p>研究历史漏洞发现，vim 主要有两个攻击面， vim 正则表达式引擎和vim 脚本执行引擎。</p>
<h4 id="vim-的正则表达式引擎"><a href="#vim-的正则表达式引擎" class="headerlink" title="vim 的正则表达式引擎"></a>vim 的正则表达式引擎</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">./vim -u NONE -i NONE -X -Z -m -n -e -s -c &#x27;call search(getline(&quot;.&quot;))&#x27; -c &#x27;:qa!&#x27; ./poc<br></code></pre></td></tr></table></figure>

<h4 id="vim-的脚本执行引擎"><a href="#vim-的脚本执行引擎" class="headerlink" title="vim 的脚本执行引擎"></a>vim 的脚本执行引擎</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">vim -u NONE -i NONE -X -Z -m -n -e -s -S ./poc -c &#x27;:qa!&#x27;<br></code></pre></td></tr></table></figure>

<h3 id="5-2-编译-vim"><a href="#5-2-编译-vim" class="headerlink" title="5.2 编译 vim"></a>5.2 编译 vim</h3><p>首先下载 vim 的源码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/vim/vim.git<br></code></pre></td></tr></table></figure>

<p>编译 vim ，使用 afl-cc 插桩</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-15&quot;</span><br><span class="hljs-built_in">export</span> CFLAGS=<span class="hljs-string">&quot;-O1 -g -fno-omit-frame-pointer&quot;</span><br><span class="hljs-built_in">cd</span> vim<br>CC=afl-cc CXX=afl-c++ ./configure --with-features=huge --enable-gui=none --disable-shared<br>make<br></code></pre></td></tr></table></figure>

<h3 id="5-3-寻找-fuzz-vim-的-testcases-corpus"><a href="#5-3-寻找-fuzz-vim-的-testcases-corpus" class="headerlink" title="5.3 寻找 fuzz vim 的 testcases ( corpus)"></a>5.3 寻找 fuzz vim 的 testcases ( corpus)</h3><p>vim 官方仓库里有历史上造成 vim crash 的 poc ，正好拿来用。<br><a target="_blank" rel="noopener" href="https://github.com/vim/vim/tree/master/src/testdir/crash">https://github.com/vim/vim/tree/master/src/testdir/crash</a></p>
<h3 id="5-4-fuzz-vim"><a href="#5-4-fuzz-vim" class="headerlink" title="5.4 fuzz vim"></a>5.4 fuzz vim</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir -p ~/fuzz/vim<br>mkdir -p /tmp/afl++<br>afl-fuzz -i testdir/crash/ -o ~/fuzz/vim -mnone -p fast -- ./vim -u NONE -i NONE -X -Z -m -n -e -s -S @@ -c &#x27;:qa!&#x27;<br></code></pre></td></tr></table></figure>

<ul>
<li>-x 指定字典文件</li>
<li>-mnone 不限制使用内存</li>
</ul>
<h3 id="5-5-fuzz-结果"><a href="#5-5-fuzz-结果" class="headerlink" title="5.5  fuzz 结果"></a>5.5  fuzz 结果</h3><p>经过 2天 16 小时的 fuzz， AFL++ 报告有 789 个 Crashes.</p>
<h3 id="5-6-调整和改进"><a href="#5-6-调整和改进" class="headerlink" title="5.6 调整和改进"></a>5.6 调整和改进</h3><p><code>~/fuzz/vim/default</code> 目录出现了大量的 <code> _cur_inp.*</code> 文件，这是 AFL++ 生成的的临时文件，为了取得更好的效果，需要把这些文件放到 &#x2F;tmp 目录。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> AFL_TMPDIR=/tmp/afl++<br></code></pre></td></tr></table></figure>

<p>使用 AFL++ 的 cmplog 特性，解决一些  fuzz 上的路径约束, 主要思路来自 <a target="_blank" rel="noopener" href="https://github.com/RUB-SysSec/redqueen">https://github.com/RUB-SysSec/redqueen</a> 。<br><a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.cmplog.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.cmplog.md</a></p>
<p>要使用 cmplog，需要重新编译 vim，使用 <code>AFL_LLVM_CMPLOG</code> 环境变量，指定使用 cmplog 的编译。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> src/vim src/vim-afl<br>make distclean<br><br><span class="hljs-built_in">export</span> LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-15&quot;</span><br><span class="hljs-built_in">export</span> CFLAGS=<span class="hljs-string">&quot;-O1 -g -fno-omit-frame-pointer&quot;</span><br><span class="hljs-built_in">cd</span> vim-cmplog<br><span class="hljs-built_in">export</span> AFL_LLVM_CMPLOG=1<br>CC=afl-cc CXX=afl-c++ ./configure --with-features=huge --enable-gui=none<br>make<br><span class="hljs-built_in">mv</span> src/vim src/vim-cmplog<br></code></pre></td></tr></table></figure>

<p>编译完成后，将编译好的 vim 重命名成 vim-cmplog，可以使用下面的 AFL++ 命令行，启用 cmplog</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> AFL_TMPDIR=/tmp/afl++-cmplog<br>afl-fuzz -i testdir/crash/ -o ~/fuzz/vim -mnone -p fast -S cmplog -c ./vim-cmplog -- ./vim-afl -u NONE -i NONE -X -Z -m -n -e -s -S @@ -c <span class="hljs-string">&#x27;:qa!&#x27;</span><br></code></pre></td></tr></table></figure>

<p>同时运行两个 AFL++ 对 vim 进行 fuzz。</p>
<h2 id="Trophy"><a href="#Trophy" class="headerlink" title="Trophy"></a>Trophy</h2><p>历史上使用上述方法发现了许多 vim 漏洞，部分漏洞 vim 官方已经修复。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vim/vim/commit/0fb375aae608d7306b4baf9c1f906961f32e2abf">https://github.com/vim/vim/commit/0fb375aae608d7306b4baf9c1f906961f32e2abf</a><br><a target="_blank" rel="noopener" href="https://github.com/vim/vim/commit/b39b240c386a5a29241415541f1c99e2e6b8ce47">https://github.com/vim/vim/commit/b39b240c386a5a29241415541f1c99e2e6b8ce47</a><br><a target="_blank" rel="noopener" href="https://github.com/vim/vim/commit/eec0c2b3a4cfab93dd8d4adaa60638d47a2bbc8a">https://github.com/vim/vim/commit/eec0c2b3a4cfab93dd8d4adaa60638d47a2bbc8a</a><br><a target="_blank" rel="noopener" href="https://github.com/vim/vim/commit/abfa13ebe92d81aaf66669c428d767847b577453">https://github.com/vim/vim/commit/abfa13ebe92d81aaf66669c428d767847b577453</a></p>
<h2 id="☆-参考资料"><a href="#☆-参考资料" class="headerlink" title="☆  参考资料"></a>☆  参考资料</h2><p>[1]  <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md</a><br>[2]  <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/tree/stable">AFL ++ stable branch</a><br>[3]  <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/tree/dev">AFL++ dev branch</a><br>[4] <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.llvm.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.llvm.md</a><br>[5] <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.cmplog.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.cmplog.md</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://usmacd.com">曼福吉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://usmacd.com/cn/AFL++%20%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/">https://usmacd.com/cn/AFL++%20%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E4%BE%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://usmacd.com" target="_blank">安全代码</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Security/">Security</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/cn/lilu/" title="李录谈价值投资"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">李录谈价值投资</div></div><div class="info-2"><div class="info-item-1">价值投资的基本理念1&#x2F; 买股票是投资一个公司：股票是公司的所有权，公司在创造价值的过程中，作为部分所有者，拥有的部分价值也会增长2&#x2F; 忽略短期波动：市场不能告诉你价值，只能告诉你价格，你只能把它当作一个可以利用的工具3&#x2F; 注重安全边际：因为无法对未来预测，做判断是要预留很大空间，买入价格要大大低于内在价值 前三条自来本杰明·格雷厄姆。 4&#x2F; 建立能力圈：通过不断努力，在某些行业获得比几乎所有人更深认识，从而能对公司长期表现作出比所有其他人更准确的判断 第四条来自沃伦·巴菲特。 5&#x2F; 在有鱼的湖里钓鱼：不必关注所有的投资机会。 这个生动的比喻来自查理·芒格。 6&#x2F; 财富是经济体中的购买力占比：在最具活力的经济体中，持有最有活力的公司的股份，来保持和增长财富。 第六条来自李录对文明范式变化的总结。 价值投资的难点价值投资虽然是通向成功的大路，但是这条道路太长了。也许你买的时候价格远低于内在价值，但你不知道市场什么时候变得理性。 同时公司的价值要增长，要公司管理层和上上下下的人员共同努力，是一个很艰难的过程。 你对未来的判断也...</div></div></div></a><a class="pagination-related" href="/cn/logseq_practice/" title="我的 Logseq 使用实践"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">我的 Logseq 使用实践</div></div><div class="info-2"><div class="info-item-1">近两年陆陆续续发表了一系列关于 Logseq 实践的文字，零散不易查找阅读，抽空整理成一篇文章，希望能对大家有所帮助。 Logseq 光速入门Logseq 是个不错的工具，就是学习曲线有点陡峭，上手不太容易，最开始可以从 journal 开始，进行日常记事并使用任务管理功能安排日程。 Logseq 的高阶用法是利用 query 建立自己的工作流 （workflow），使用基于 Query 的 workflow 提示 next action 是 Logseq 最精华的功能，Logseq 的资深用户都是 Query base workflow 的爱好者。 但是入门还是建议从基础功能的使用开始 （日志，双链，大纲，本地存储 ）。我自己写过 Logseq 四篇，现在由于笔记系统上手熟练，输出反倒不如从前，有点惭愧。 Logseq 试用报告Logseq 使用小结（二）Logseq 使用小结（三）我正在使用的 Logseq Plugin 关于 Logseq 的使用，Luhmann 写了不少高质量的 Logseq 文章，放在他个人的网站上 https://luhmann-logseq.noti...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cn/onefuzz/" title="onefuzz 简单分析"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">onefuzz 简单分析</div></div><div class="info-2"><div class="info-item-1">deploy agent (部署)123unzip onefuzz-deployment-$VERSION.zippip install -r requirements.txt./deploy.py $REGION $RESOURCE_GROUP_NAME $ONEFUZZ_INSTANCE_NAME $CONTACT_EMAIL_ADDRESS  Azure CLI logged in 后，执行上面命令可以在 Azure 上部署 agent 需要订阅 Azure， 可能要收费 安装 onefuzz CLI123wget https://github.com/microsoft/onefuzz/releases/download/1.0.0/onefuzz-1.0.0-py3-none-any.whlwget https://github.com/microsoft/onefuzz/releases/download/1.0.0/onefuzztypes-1.0.0-py3-none-any.whlpip install ./onefuzz*.whl  执行 fuzz 任务1on...</div></div></div></a><a class="pagination-related" href="/en/How_do_you_actually_find_bugs/" title="Keynote - How Do You Actually Find Bugs?"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">Keynote - How Do You Actually Find Bugs?</div></div><div class="info-2"><div class="info-item-1">https://www.youtube.com/watch?v=7Ysy6iA2sqA&amp;ab_channel=OffensiveCon  Temperament Curiosity Detail-oriented Ability to deal with failure and continual evidence that you’re wrong   Learn how to deal with failure Two projects (can be unrealeted, or different parts of the same) Learn to recognize whe you have hit a wall and have become unproductive Switch to your secondary project   Consider having a development project as your seconary project Do an achiveable, measurable task Regain a sense...</div></div></div></a><a class="pagination-related" href="/cn/afl/" title="afl-fuzz 框架"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">afl-fuzz 框架</div></div><div class="info-2"><div class="info-item-1">afl-fuzz 的整体架构，新手理解起来还是比较费劲，网络上发现一张图觉得不错，放上来大家看看，感谢原作者。  </div></div></div></a><a class="pagination-related" href="/cn/search_sql_injection/" title="站内搜索写法的一个 SQL inject 漏洞"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2004-10-13</div><div class="info-item-2">站内搜索写法的一个 SQL inject 漏洞</div></div><div class="info-2"><div class="info-item-1">最近sql inject 可是说是红遍了整个中国，不知道多少网站在sql inject 面前轰然倒下，其实 Sql inject 在国外技术已经很成熟了，而国内则是在近一两年内慢慢走向成熟。在一个个惨痛的实例面前，脚本工作者不得不重视起来，最好的例子就是动网了。然而今天脚本是不是就很安全的呢。请看我对几个安全站点的测试结果。结果是令人吃惊的， 影子鹰， 华夏， 黑客动画吧 都存在着这个站内搜索的漏洞。 请看一段常见的站内搜索写法。 例一： 123456789101112131415161718&lt;form name=&quot;form4&quot; method=&quot;post&quot; action=&quot;search.asp&quot;&gt;&lt;tr&gt;&lt;td height=&quot;25&quot;&gt; &lt;div align=center&gt;&lt;input type=&quot;text&quot; name=&quot;txtfind&quot; size=&quot;18&quot; onMouseOver=&qu...</div></div></div></a><a class="pagination-related" href="/cn/process_injection/" title="Windows 进程注入"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="info-item-2">Windows 进程注入</div></div><div class="info-2"><div class="info-item-1">1. Process Injection 方法总结  进程注入是windows病毒和恶意软件最常用的手法之一，Windows下进程注入的方法比较多，这里介绍常见的一些方法，以及相应的检查手段。 1.1 SetWindowsHookEx SetWindowsHookEx估计是大家最熟悉的方法了，这个是微软提供给我们使用正规用法。往Windows的hook chain中安装hook 例程，监控系统某种类型的event, 使用这种方法需要实现一个dll。 123456HHOOK WINAPI SetWindowsHookEx(  _In_  int idHook,  _In_  HOOKPROC lpfn,  _In_  HINSTANCE hMod,  _In_  DWORD dwThreadId);   dwThread 为0，将监管系统中所有线程。 idHook        指定监控event的类型 hMod          dll句柄 lpfn          hook例程的指针  MSDN给出了一个使用的例子： 123456789101112HOOKPROC hkprc...</div></div></div></a><a class="pagination-related" href="/cn/sqlserver2005_xpcmdshell/" title="SQL Server 2005 xp_cmdshell"><img class="cover" src="https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2009-09-18</div><div class="info-item-2">SQL Server 2005 xp_cmdshell</div></div><div class="info-2"><div class="info-item-1">SQL Server 2005 中引入的 xp_cmdshell 选项是服务器配置选项，使系统管理员能够控制是否可以在系统上执行 xp_cmdshell 扩展存储过程。 1.  如何在sql server 2005 中开启xp_cmdshell123456789101112-- To allow advanced options to be changed.EXEC sp_configure &#x27;show advanced options&#x27;, 1GO-- To update the currently configured value for advanced options.RECONFIGUREGO-- To enable the feature.EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1GO-- To update the currently configured value for this feature.RECONFIGUREGO  2. 如何查询sql server 2005 拓展存储过程xp_cmds...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">曼福吉</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">173</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="/rss.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #4c566a;"></i></a><a class="social-icon" href="https://x.com/henices" target="_blank" title="Twitter"><i class="fab fa-x-twitter" style="color: #4c566a;"></i></a><a class="social-icon" href="mailto:zhouzhenster@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4c566a;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86-1-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-AFL-AFL-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">☆ 1. 模糊测试工具 AFL &#x2F; AFL++介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86-2-AFL-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">☆ 2. AFL++ 的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86-3-AFL-Linux-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">☆ 3. AFL++ Linux 系统环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86-4-AFL-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">☆ 4. AFL++ 的基本使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9B%AE%E6%A0%87%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 编译插桩模糊测试目标软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-AFL-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 AFL++ 的命令行参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86-5-%E5%AE%9E%E6%88%98-vim-%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98"><span class="toc-number">5.</span> <span class="toc-text">☆ 5. 实战 vim 漏洞挖掘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-0-vim-%E7%9A%84-Ex-%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">5.0 vim 的 Ex 模式介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">5.1 攻击面分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vim-%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E"><span class="toc-number">5.2.1.</span> <span class="toc-text">vim 的正则表达式引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vim-%E7%9A%84%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">5.2.2.</span> <span class="toc-text">vim 的脚本执行引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%96%E8%AF%91-vim"><span class="toc-number">5.3.</span> <span class="toc-text">5.2 编译 vim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%AF%BB%E6%89%BE-fuzz-vim-%E7%9A%84-testcases-corpus"><span class="toc-number">5.4.</span> <span class="toc-text">5.3 寻找 fuzz vim 的 testcases ( corpus)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-fuzz-vim"><span class="toc-number">5.5.</span> <span class="toc-text">5.4 fuzz vim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-fuzz-%E7%BB%93%E6%9E%9C"><span class="toc-number">5.6.</span> <span class="toc-text">5.5  fuzz 结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E8%B0%83%E6%95%B4%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">5.7.</span> <span class="toc-text">5.6 调整和改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trophy"><span class="toc-number">6.</span> <span class="toc-text">Trophy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">☆  参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/gemini_in_chrome/" title="开启 Gemini in Chrome 的方法">开启 Gemini in Chrome 的方法</a><time datetime="2026-01-29T16:00:00.000Z" title="发表于 2026-01-30 00:00:00">2026-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/sucess_is_the_mother_of_sucess/" title="成功是成功之母">成功是成功之母</a><time datetime="2026-01-27T16:00:00.000Z" title="发表于 2026-01-28 00:00:00">2026-01-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/ai_studio_podcast_transcript/" title="利用 AI Studio 整理播客音频的逐字稿">利用 AI Studio 整理播客音频的逐字稿</a><time datetime="2026-01-07T16:00:00.000Z" title="发表于 2026-01-08 00:00:00">2026-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/anti-weakness-learning/" title="反脆弱式的学习方法">反脆弱式的学习方法</a><time datetime="2025-12-30T16:00:00.000Z" title="发表于 2025-12-31 00:00:00">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/cn/keep_hard/" title="坚持的秘诀">坚持的秘诀</a><time datetime="2025-12-15T16:00:00.000Z" title="发表于 2025-12-16 00:00:00">2025-12-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://images.unsplash.com/photo-1646026371686-79950ceb6daa?w=640);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 曼福吉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="/js/tw_cn.js?v=5.5.4"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>